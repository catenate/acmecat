UNIXTM TIME-SHARING SYSTEM:


        UNIX PROGRAMMER’S MANUAL

                 Seventh Edition, Volume 2A


                         January, 1979




             Bell Telephone Laboratories, Incorporated
                      Murray Hill, New Jersey
                                    UNIX Programmer’s Manual
                                Volume 2 — Supplementary Documents

                                             Seventh Edition
                                             January 10, 1979



      This volume contains documents which supplement the information contained in Volume 1 of The
UNIX† Programmer’s Manual. The documents here are grouped roughly into the areas of basics, editing,
language tools, document preparation, and system maintenance. Further general information may be
found in the Bell System Technical Journal special issue on UNIX, July-August, 1978.
      Many of the documents cited within this volume as Bell Laboratories internal memoranda or Com-
puting Science Technical Reports (CSTR) are also contained here.
    These documents contain occasional localisms, typically references to other operating systems like
GCOS and IBM. In all cases, such references may be safely ignored by UNIX users.

General Works
1.      7th Edition UNIX — Summary.
              A concise summary of the facilities available on UNIX.
2.      The UNIX Time-Sharing System. D. M. Ritchie and K. Thompson.
             The original UNIX paper, reprinted from CACM.

Getting Started
3.      UNIX for Beginners — Second Edition. B. W. Kernighan.
            An introduction to the most basic use of the system.
4.      A Tutorial Introduction to the UNIX Text Editor. B. W. Kernighan.
             An easy way to get started with the editor.
5.      Advanced Editing on UNIX. B. W. Kernighan.
             The next step.
6.      An Introduction to the UNIX Shell. S. R. Bourne.
             An introduction to the capabilities of the command interpreter, the shell.
7.      Learn — Computer Aided Instruction on UNIX. M. E. Lesk and B. W. Kernighan.
              Describes a computer-aided instruction program that walks new users through the basics of
              ﬁles, the editor, and document preparation software.

Document Preparation
8.      Typing Documents on the UNIX System. M. E. Lesk.
             Describes the basic use of the formatting tools. Also describes ‘‘– ms’’, a standardized
             package of formatting requests that can be used to lay out most documents (including those
             in this volume).



__________________
†UNIX is a Trademark of Bell Laboratories.
                                                  -2-


9.    A System for Typesetting Mathematics. B. W. Kernighan and L. L. Cherry.
           Describes EQN. an easy-to-learn language for doing high-quality mathematical typesetting,
10.   TBL — A Program to Format Tables. M. E. Lesk.
          A program to permit easy speciﬁcation of tabular material for typesetting. Again, easy to
          learn and use.
11.   Some Applications of Inverted Indexes on the UNIX System. M. E. Lesk.
           Describes, among other things, the program REFER which ﬁlls in bibliographic citations
           from a data base automatically.
12.   NROFF/TROFF User’s Manual. J. F. Ossanna.
          The basic formatting program.
13.   A TROFF Tutorial. B. W. Kernighan.
          An introduction to TROFF for those who really want to know such things.

Programming
14.   The C Programming Language — Reference Manual. D. M. Ritchie.
           Ofﬁcial statement of the syntax and semantics of C. Should be supplemented by The C
           Programming Language, B. W. Kernighan and D. M. Ritchie, Prentice-Hall, 1978, which
           contains a tutorial introduction and many examples.
15.   Lint, A C Program Checker. S. C. Johnson.
            Checks C programs for syntax errors, type violations, portability problems, and a variety of
            probable errors.
16.   Make — A Program for Maintaining Computer Programs. S. I. Feldman.
           Indispensable tool for making sure that large programs are properly compiled with minimal
           effort.
17.   UNIX Programming. B. W. Kernighan and D. M. Ritchie.
          Describes the programming interface to the operating system and the standard I/O library.
18.   A Tutorial Introduction to ADB. J. F. Maranzano and S. R. Bourne.
           How to use the ADB debugger.

Supporting Tools and Languages
19.   YACC: Yet Another Compiler-Compiler. S. C. Johnson.
          Converts a BNF speciﬁcation of a language and semantic actions written in C into a com-
          piler for the language.
20.   LEX — A Lexical Analyzer Generator. M. E. Lesk and E. Schmidt.
          Creates a recognizer for a set of regular expressions; each regular expression can be fol-
          lowed by arbitrary C code which will be executed when the regular expression is found.
21.   A Portable Fortran 77 Compiler. S. I. Feldman and P. J. Weinberger.
           The ﬁrst Fortran 77 compiler, and still one of the best.
22.   Ratfor — A Preprocessor for a Rational Fortran. B. W. Kernighan.
            Converts a Fortran with C-like control structures and cosmetics into real, ugly Fortran.
23.   The M4 Macro Processor. B. W. Kernighan and D. M. Ritchie.
           M4 is a macro processor useful as a front end for C, Ratfor, Cobol, and in its own right.
24.   SED — A Non-interactive Text Editor. L. E. McMahon.
          A variant of the editor for processing large inputs.
25.   AWK — A Pattern Scanning and Processing Language. A. V. Aho, B. W. Kernighan and
         P. J. Weinberger.
         Makes it easy to specify many data transformation and selection operations.
                                                 -3-


26.   DC — An Interactive Desk Calculator. R. H. Morris and L. L. Cherry.
          A super HP calculator, if you don’t need ﬂoating point.
27.   BC — An Arbitrary Precision Desk-Calculator Language. L. L. Cherry and R. H. Morris.
          A front end for DC that provides inﬁx notation, control ﬂow, and built-in functions.
28.   UNIX Assembler Reference Manual. D. M. Ritchie.
          The ultimate dead language.

Implementation, Maintenance, and Miscellaneous
29.   Setting Up UNIX — Seventh Edition. C. B. Haley and D. M. Ritchie.
            How to conﬁgure and get your system running.
30.   Regenerating System Software. C. B. Haley and D. M. Ritchie.
           What do do when you have to change things.
31.   UNIX Implementation. K. Thompson.
          How the system actually works inside.
32.   The UNIX I/O System. D. M. Ritchie.
           How the I/O system really works.
33.   A Tour Through the UNIX C Compiler. D. M. Ritchie.
           How the PDP-11 compiler works inside.
34.   A Tour Through the Portable C Compiler. S. C. Johnson.
           How the portable C compiler works inside.
35.   A Dial-Up Network of UNIX Systems. D. A. Nowitz and M. E. Lesk.
           Describes UUCP, a program for communicating ﬁles between UNIX systems.
36.   UUCP Implementation Description. D. A. Nowitz.
          How UUCP works, and how to administer it.
37.   On the Security of UNIX. D. M. Ritchie.
           Hints on how to break UNIX, and how to avoid doing so.
38.   Password Security: A Case History. R. H. Morris and K. Thompson.
           How the bad guys used to be able to break the password algorithm, and why they can’t
           now, at least not so easily.
                                       7th Edition UNIX — Summary

                                                    September 6, 1978
                                                    Bell Laboratories
                                              Murray Hill, New Jersey 07974




A. What’s new: highlights of the 7th edition UNIX† System
Aimed at larger systems. Devices are addressable to 231 bytes, ﬁles to 230 bytes. 128K memory
(separate instruction and data space) is needed for some utilities.
Portability. Code of the operating system and most utilities has been extensively revised to minimize
its dependence on particular hardware.
Fortran 77. F77 compiler for the new standard language is compatible with C at the object level. A
Fortran structurer, STRUCT, converts old, ugly Fortran into RATFOR, a structured dialect usable with
F77.
Shell. Completely new SH program supports string variables, trap handling, structured programming,
user proﬁles, settable search path, multilevel ﬁle name generation, etc.
Document preparation. TROFF phototypesetter utility is standard. NROFF (for terminals) is now
highly compatible with TROFF. MS macro package provides canned commands for many common for-
matting and layout situations. TBL provides an easy to learn language for preparing complicated tabular
material. REFER ﬁlls in bibliographic citations from a data base.
UNIX-to-UNIX ﬁle copy. UUCP performs spooled ﬁle transfers between any two machines.
Data processing. SED stream editor does multiple editing functions in parallel on a data stream of
indeﬁnite length. AWK report generator does free-ﬁeld pattern selection and arithmetic operations.
Program development. MAKE controls re-creation of complicated software, arranging for minimal
recompilation.
Debugging. ADB does postmortem and breakpoint debugging, handles separate instruction and data
spaces, ﬂoating point, etc.
C language. The language now supports deﬁnable data types, generalized initialization, block structure,
long integers, unions, explicit type conversions. The LINT veriﬁer does strong type checking and detec-
tion of probable errors and portability problems even across separately compiled functions.
Lexical analyzer generator. LEX converts speciﬁcation of regular expressions and semantic actions
into a recognizing subroutine. Analogous to YACC.
Graphics. Simple graph-drawing utility, graphic subroutines, and generalized plotting ﬁlters adapted to
various devices are now standard.
Standard input-output package. Highly efﬁcient buffered stream I/O is integrated with formatted
input and output.
Other. The operating system and utilities have been enhanced and freed of restrictions in many other
ways too numerous to relate.



__________________
† UNIX is a Trademark of Bell Laboratories.
                                                        -2-


B. Hardware
     The 7th edition UNIX operating system runs on a DEC PDP-11/45 or 11/70* with at least the fol-
lowing equipment:
       128K to 2M words of managed memory; parity not used.
       disk: RP03, RP04, RP06, RK05 (more than 1 RK05) or equivalent.
       console typewriter.
       clock: KW11-L or KW11-P.
The following equipment is strongly recommended:
       communications controller such as DL11 or DH11.
       full duplex 96-character ASCII terminals.
       9-track tape or extra disk for system backup.
The system is normally distributed on 9-track tape. The minimum memory and disk space speciﬁed is
enough to run and maintain UNIX. More will be needed to keep all source on line, or to handle a large
number of users, big data bases, diversiﬁed complements of devices, or large programs. The resident
code occupies 12-20K words depending on conﬁguration; system data occupies 10-28K words.
       There is no commitment to provide 7th edition UNIX on PDP-11/34, 11/40 and 11/60 hardware.

C. Software
       Most of the programs available as UNIX commands are listed. Source code and printed manuals
are distributed for all of the listed software except games. Almost all of the code is written in C. Com-
mands are self-contained and do not require extra setup information, unless speciﬁcally noted as
‘‘interactive.’’ Interactive programs can be made to run from a prepared script simply by redirecting
input. Most programs intended for interactive use (e.g., the editor) allow for an escape to command
level (the Shell). Most ﬁle processing commands can also go from standard input to standard output
(‘‘ﬁlters’’). The piping facility of the Shell may be used to connect such ﬁlters directly to the input or
output of other programs.

1. Basic Software
      This includes the time-sharing operating system with utilities, a machine language assembler and a
compiler for the programming language C—enough software to write and run new applications and to
maintain or modify UNIX itself.

1.1. Operating System
  UNIX              The basic resident code on which everything else depends. Supports the system calls,
                    and maintains the ﬁle system. A general description of UNIX design philosophy and
                    system facilities appeared in the Communications of the ACM, July, 1974. A more
                    extensive survey is in the Bell System Technical Journal for July-August 1978. Capa-
                    bilities include:
                       Reentrant code for user processes.
                       Separate instruction and data spaces.
                       ‘‘Group’’ access permissions for cooperative projects, with overlapping member-
                       ships.
                       Alarm-clock timeouts.
                       Timer-interrupt sampling and interprocess monitoring for debugging and measure-
                       ment.


__________________
*PDP is a Trademark of Digital Equipment Corporation.
                                                 -3-


                 Multiplexed I/O for machine-to-machine communication.
 DEVICES       All I/O is logically synchronous. I/O devices are simply ﬁles in the ﬁle system. Nor-
               mally, invisible buffering makes all physical record structure and device characteristics
               transparent and exploits the hardware’s ability to do overlapped I/O. Unbuffered phy-
               sical record I/O is available for unusual applications. Drivers for these devices are
               available; others can be easily written:
                  Asynchronous interfaces: DH11, DL11. Support for most common ASCII terminals.
                  Synchronous interface: DP11.
                  Automatic calling unit interface: DN11.
                  Line printer: LP11.
                  Magnetic tape: TU10 and TU16.
                  DECtape: TC11.
                  Fixed head disk: RS11, RS03 and RS04.
                  Pack type disk: RP03, RP04, RP06; minimum-latency seek scheduling.
                  Cartridge-type disk: RK05, one or more physical devices per logical device.
                  Null device.
                  Physical memory of PDP-11, or mapped memory in resident system.
                  Phototypesetter: Graphic Systems System/1 through DR11C.
 BOOT          Procedures to get UNIX started.
 MKCONF        Tailor device-dependent system code to hardware conﬁguration. As distributed, UNIX
               can be brought up directly on any acceptable CPU with any acceptable disk, any
               sufﬁcient amount of core, and either clock. Other changes, such as optimal assignment
               of directories to devices, inclusion of ﬂoating point simulator, or installation of device
               names in ﬁle system, can then be made at leisure.

1.2. User Access Control

 LOGIN         Sign on as a new user.
                 Verify password and establish user’s individual and group (project) identity.
                 Adapt to characteristics of terminal.
                 Establish working directory.
                 Announce presence of mail (from MAIL).
                 Publish message of the day.
                 Execute user-speciﬁed proﬁle.
                 Start command interpreter or other initial program.
 PASSWD        Change a password.
                 User can change his own password.
                 Passwords are kept encrypted for security.
 NEWGRP        Change working group (project). Protects against unauthorized changes to projects.

1.3. Terminal Handling

 TABS          Set tab stops appropriately for speciﬁed terminal type.
 STTY          Set up options for optimal control of a terminal. In so far as they are deducible from
               the input, these options are set automatically by LOGIN.
                  Half vs. full duplex.
                  Carriage return+line feed vs. newline.
                  Interpretation of tabs.
                  Parity.
                                                 -4-


                  Mapping of upper case to lower.
                  Raw vs. edited input.
                  Delays for tabs, newlines and carriage returns.

1.4. File Manipulation

 CAT           Concatenate one or more ﬁles onto standard output. Particularly used for unadorned
               printing, for inserting data into a pipeline, and for buffering output that comes in dribs
               and drabs. Works on any ﬁle regardless of contents.
 CP            Copy one ﬁle to another, or a set of ﬁles to a directory. Works on any ﬁle regardless
               of contents.
 PR            Print ﬁles with title, date, and page number on every page.
                 Multicolumn output.
                 Parallel column merge of several ﬁles.
 LPR           Off-line print. Spools arbitrary ﬁles to the line printer.
 CMP           Compare two ﬁles and report if different.
 TAIL          Print last n lines of input
                 May print last n characters, or from n lines or characters to end.
 SPLIT         Split a large ﬁle into more manageable pieces. Occasionally necessary for editing
               (ED).
 DD            Physical ﬁle format translator, for exchanging data with foreign systems, especially
               IBM 370’s.
 SUM           Sum the words of a ﬁle.

1.5. Manipulation of Directories and File Names

 RM            Remove a ﬁle. Only the name goes away if any other names are linked to the ﬁle.
                 Step through a directory deleting ﬁles interactively.
                 Delete entire directory hierarchies.
 LN            ‘‘Link’’ another name (alias) to an existing ﬁle.
 MV            Move a ﬁle or ﬁles. Used for renaming ﬁles.
 CHMOD         Change permissions on one or more ﬁles. Executable by ﬁles’ owner.
 CHOWN         Change owner of one or more ﬁles.
 CHGRP         Change group (project) to which a ﬁle belongs.
 MKDIR         Make a new directory.
 RMDIR         Remove a directory.
 CD            Change working directory.
 FIND          Prowl the directory hierarchy ﬁnding every ﬁle that meets speciﬁed criteria.
                 Criteria include:
                      name matches a given pattern,
                      creation date in given range,
                      date of last use in given range,
                      given permissions,
                      given owner,
                      given special ﬁle characteristics,
                      boolean combinations of above.
                                               -5-


                Any directory may be considered to be the root.
                Perform speciﬁed command on each ﬁle found.

1.6. Running of Programs

 SH           The Shell, or command language interpreter.
                Supply arguments to and run any executable program.
                Redirect standard input, standard output, and standard error ﬁles.
                Pipes: simultaneous execution with output of one process connected to the input of
                another.
                Compose compound commands using:
                      if ... then ... else,
                      case switches,
                      while loops,
                      for loops over lists,
                      break, continue and exit,
                      parentheses for grouping.
                Initiate background processes.
                Perform Shell programs, i.e., command scripts with substitutable arguments.
                Construct argument lists from all ﬁle names satisfying speciﬁed patterns.
                Take special action on traps and interrupts.
                User-settable search path for ﬁnding commands.
                Executes user-settable proﬁle upon login.
                Optionally announces presence of mail as it arrives.
                Provides variables and parameters with default setting.
 TEST         Tests for use in Shell conditionals.
                String comparison.
                File nature and accessibility.
                Boolean combinations of the above.
 EXPR         String computations for calculating command arguments.
                Integer arithmetic
                Pattern matching
 WAIT         Wait for termination of asynchronously running processes.
 READ         Read a line from terminal, for interactive Shell procedure.
 ECHO         Print remainder of command line. Useful for diagnostics or prompts in Shell pro-
              grams, or for inserting data into a pipeline.
 SLEEP        Suspend execution for a speciﬁed time.
 NOHUP        Run a command immune to hanging up the terminal.
 NICE         Run a command in low (or high) priority.
 KILL         Terminate named processes.
 CRON         Schedule regular actions at speciﬁed times.
                Actions are arbitrary programs.
                Times are conjunctions of month, day of month, day of week, hour and minute.
                Ranges are speciﬁable for each.
 AT           Schedule a one-shot action for an arbitrary time.
 TEE          Pass data between processes and divert a copy into one or more ﬁles.
                                                  -6-


1.7. Status Inquiries

 LS             List the names of one, several, or all ﬁles in one or more directories.
                  Alphabetic or temporal sorting, up or down.
                  Optional information: size, owner, group, date last modiﬁed, date last accessed, per-
                  missions, i-node number.
 FILE           Try to determine what kind of information is in a ﬁle by consulting the ﬁle system
                index and by reading the ﬁle itself.
 DATE           Print today’s date and time. Has considerable knowledge of calendric and horological
                peculiarities.
                  May set UNIX’s idea of date and time.
 DF             Report amount of free space on ﬁle system devices.
 DU             Print a summary of total space occupied by all ﬁles in a hierarchy.
 QUOT           Print summary of ﬁle space usage by user id.
 WHO            Tell who’s on the system.
                  List of presently logged in users, ports and times on.
                  Optional history of all logins and logouts.
 PS             Report on active processes.
                  List your own or everybody’s processes.
                  Tell what commands are being executed.
                  Optional status information: state and scheduling info, priority, attached terminal,
                  what it’s waiting for, size.
 IOSTAT         Print statistics about system I/O activity.
 TTY            Print name of your terminal.
 PWD            Print name of your working directory.

1.8. Backup and Maintenance

 MOUNT          Attach a device containing a ﬁle system to the tree of directories. Protects against
                nonsense arrangements.
 UMOUNT         Remove the ﬁle system contained on a device from the tree of directories. Protects
                against removing a busy device.
 MKFS           Make a new ﬁle system on a device.
 MKNOD          Make an i-node (ﬁle system entry) for a special ﬁle. Special ﬁles are physical devices,
                virtual devices, physical memory, etc.
 TP
 TAR            Manage ﬁle archives on magnetic tape or DECtape. TAR is newer.
                 Collect ﬁles into an archive.
                 Update DECtape archive by date.
                 Replace or delete DECtape ﬁles.
                 Print table of contents.
                 Retrieve from archive.
 DUMP           Dump the ﬁle system stored on a speciﬁed device, selectively by date, or indiscrim-
                inately.
                                                   -7-


 RESTOR           Restore a dumped ﬁle system, or selectively retrieve parts thereof.
 SU               Temporarily become the super user with all the rights and privileges thereof. Requires
                  a password.
 DCHECK
 ICHECK
 NCHECK           Check consistency of ﬁle system.
                    Print gross statistics: number of ﬁles, number of directories, number of special ﬁles,
                    space used, space free.
                    Report duplicate use of space.
                    Retrieve lost space.
                    Report inaccessible ﬁles.
                    Check consistency of directories.
                    List names of all ﬁles.
 CLRI             Peremptorily expunge a ﬁle and its space from a ﬁle system. Used to repair damaged
                  ﬁle systems.
 SYNC             Force all outstanding I/O on the system to completion. Used to shut down gracefully.

1.9. Accounting
The timing information on which the reports are based can be manually cleared or shut off completely.
 AC               Publish cumulative connect time report.
                    Connect time by user or by day.
                    For all users or for selected users.
 SA               Publish Shell accounting report. Gives usage information on each command executed.
                    Number of times used.
                    Total system time, user time and elapsed time.
                    Optional averages and percentages.
                    Sorting on various ﬁelds.

1.10. Communication

 MAIL             Mail a message to one or more users. Also used to read and dispose of incoming
                  mail. The presence of mail is announced by LOGIN and optionally by SH.
                    Each message can be disposed of individually.
                    Messages can be saved in ﬁles or forwarded.
 CALENDAR Automatic reminder service for events of today and tomorrow.
 WRITE            Establish direct terminal communication with another user.
 WALL             Write to all users.
 MESG             Inhibit receipt of messages from WRITE and WALL.
 CU               Call up another time-sharing system.
                    Transparent interface to remote machine.
                    File transmission.
                    Take remote input from local ﬁle or put remote output into local ﬁle.
                    Remote system need not be UNIX.
 UUCP             UNIX to UNIX copy.
                                                    -8-


                    Automatic queuing until line becomes available and remote machine is up.
                    Copy between two remote machines.
                    Differences, mail, etc., between two machines.

1.11. Basic Program Development Tools
Some of these utilities are used as integral parts of the higher level languages described in section 2.
  AR              Maintain archives and libraries. Combines several ﬁles into one for housekeeping
                  efﬁciency.
                    Create new archive.
                    Update archive by date.
                    Replace or delete ﬁles.
                    Print table of contents.
                    Retrieve from archive.
  AS              Assembler. Similar to PAL-11, but different in detail.
                    Creates object program consisting of
                         code, possibly read-only,
                         initialized data or read-write code,
                         uninitialized data.
                    Relocatable object code is directly executable without further transformation.
                    Object code normally includes a symbol table.
                    Multiple source ﬁles.
                    Local labels.
                    Conditional assembly.
                    ‘‘Conditional jump’’ instructions become branches or branches plus jumps depend-
                    ing on distance.
  Library         The basic run-time library. These routines are used freely by all software.
                    Buffered character-by-character I/O.
                    Formatted input and output conversion (SCANF and PRINTF) for standard input and
                    output, ﬁles, in-memory conversion.
                    Storage allocator.
                    Time conversions.
                    Number conversions.
                    Password encryption.
                    Quicksort.
                    Random number generator.
                    Mathematical function library, including trigonometric functions and inverses,
                    exponential, logarithm, square root, bessel functions.
  ADB             Interactive debugger.
                     Postmortem dumping.
                     Examination of arbitrary ﬁles, with no limit on size.
                     Interactive breakpoint debugging with the debugger as a separate process.
                     Symbolic reference to local and global variables.
                     Stack trace for C programs.
                     Output formats:
                          1-, 2-, or 4-byte integers in octal, decimal, or hex
                          single and double ﬂoating point
                          character and string
                          disassembled machine instructions
                     Patching.
                                                -9-


                 Searching for integer, character, or ﬂoating patterns.
                 Handles separated instruction and data space.
 OD            Dump any ﬁle. Output options include any combination of octal or decimal by words,
               octal by bytes, ASCII, opcodes, hexadecimal.
                 Range of dumping is controllable.
 LD            Link edit. Combine relocatable object ﬁles. Insert required routines from speciﬁed
               libraries.
                  Resulting code may be sharable.
                  Resulting code may have separate instruction and data spaces.
 LORDER        Places object ﬁle names in proper order for loading, so that ﬁles depending on others
               come after them.
 NM            Print the namelist (symbol table) of an object program. Provides control over the style
               and order of names that are printed.
 SIZE          Report the core requirements of one or more object ﬁles.
 STRIP         Remove the relocation and symbol table information from an object ﬁle to save space.
 TIME          Run a command and report timing information on it.
 PROF          Construct a proﬁle of time spent per routine from statistics gathered by time-sampling
               the execution of a program. Uses ﬂoating point.
                  Subroutine call frequency and average times for C programs.
 MAKE          Controls creation of large programs. Uses a control ﬁle specifying source ﬁle depen-
               dencies to make new version; uses time last changed to deduce minimum amount of
               work necessary.
                 Knows about CC, YACC, LEX, etc.

1.12. UNIX Programmer’s Manual

 Manual        Machine-readable version of the UNIX Programmer’s Manual.
                System overview.
                All commands.
                All system calls.
                All subroutines in C and assembler libraries.
                All devices and other special ﬁles.
                Formats of ﬁle system and kinds of ﬁles known to system software.
                Boot and maintenance procedures.
 MAN           Print speciﬁed manual section on your terminal.

1.13. Computer-Aided Instruction

 LEARN         A program for interpreting CAI scripts, plus scripts for learning about UNIX by using
               it.
                   Scripts for basic ﬁles and commands, editor, advanced ﬁles and commands, EQN,
                   MS macros, C programming language.

2. Languages

2.1. The C Language
                                                 - 10 -


 CC            Compile and/or link edit programs in the C language. The UNIX operating system,
               most of the subsystems and C itself are written in C. For a full description of C, read
               The C Programming Language, Brian W. Kernighan and Dennis M. Ritchie, Prentice-
               Hall, 1978.
                 General purpose language designed for structured programming.
                 Data types include character, integer, ﬂoat, double, pointers to all types, functions
                 returning above types, arrays of all types, structures and unions of all types.
                 Operations intended to give machine-independent control of full machine facility,
                 including to-memory operations and pointer arithmetic.
                 Macro preprocessor for parameterized code and inclusion of standard ﬁles.
                 All procedures recursive, with parameters by value.
                 Machine-independent pointer manipulation.
                 Object code uses full addressing capability of the PDP-11.
                 Runtime library gives access to all system facilities.
                 Deﬁnable data types.
                 Block structure
 LINT          Veriﬁer for C programs. Reports questionable or nonportable usage such as:
                   Mismatched data declarations and procedure interfaces.
                   Nonportable type conversions.
                   Unused variables, unreachable code, no-effect operations.
                   Mistyped pointers.
                   Obsolete syntax.
                 Full cross-module checking of separately compiled programs.
 CB            A beautiﬁer for C programs. Does proper indentation and placement of braces.

2.2. Fortran

 F77           A full compiler for ANSI Standard Fortran 77.
                 Compatible with C and supporting tools at object level.
                 Optional source compatibility with Fortran 66.
                 Free format source.
                 Optional subscript-range checking, detection of uninitialized variables.
                 All widths of arithmetic: 2- and 4-byte integer; 4- and 8-byte real; 8- and 16-byte
                 complex.
 RATFOR        Ratfor adds rational control structure a la C to Fortran.
                                                        `
                 Compound statements.
                 If-else, do, for, while, repeat-until, break, next statements.
                 Symbolic constants.
                 File insertion.
                 Free format source
                 Translation of relationals like >, >=.
                 Produces genuine Fortran to carry away.
                 May be used with F77.
 STRUCT        Converts ordinary ugly Fortran into structured Fortran (i.e., Ratfor), using statement
               grouping, if-else, while, for, repeat-until.

2.3. Other Algorithmic Languages

 BAS           An interactive interpreter, similar in style to BASIC. Interpret unnumbered statements
               immediately, numbered statements upon ‘run’.
                                                 - 11 -


                 Statements include:
                      comment,
                      dump,
                      for...next,
                      goto,
                      if...else...ﬁ,
                      list,
                      print,
                      prompt,
                      return,
                      run,
                      save.
                 All calculations double precision.
                 Recursive function deﬁning and calling.
                 Builtin functions include log, exp, sin, cos, atn, int, sqr, abs, rnd.
                 Escape to ED for complex program editing.
 DC            Interactive programmable desk calculator. Has named storage locations as well as con-
               ventional stack for holding integers or programs.
                  Unlimited precision decimal arithmetic.
                  Appropriate treatment of decimal fractions.
                  Arbitrary input and output radices, in particular binary, octal, decimal and hexade-
                  cimal.
                  Reverse Polish operators:
                       +– */
                       remainder, power, square root,
                       load, store, duplicate, clear,
                       print, enter program text, execute.
 BC            A C-like interactive interface to the desk calculator DC.
                 All the capabilities of DC with a high-level syntax.
                 Arrays and recursive functions.
                 Immediate evaluation of expressions and evaluation of functions upon call.
                 Arbitrary precision elementary functions: exp, sin, cos, atan.
                 Go-to-less programming.

2.4. Macroprocessing

 M4            A general purpose macroprocessor.
                 Stream-oriented, recognizes macros anywhere in text.
                 Syntax ﬁts with functional syntax of most higher-level languages.
                 Can evaluate integer arithmetic expressions.

2.5. Compiler-compilers

 YACC          An LR(1)-based compiler writing system. During execution of resulting parsers, arbi-
               trary C functions may be called to do code generation or semantic actions.
                  BNF syntax speciﬁcations.
                  Precedence relations.
                  Accepts formally ambiguous grammars with non-BNF resolution rules.
 LEX           Generator of lexical analyzers. Arbitrary C functions may be called upon isolation of
               each lexical token.
                                                - 12 -


                 Full regular expression, plus left and right context dependence.
                 Resulting lexical analysers interface cleanly with YACC parsers.

3. Text Processing

3.1. Document Preparation

 ED            Interactive context editor. Random access to all lines of a ﬁle.
                  Find lines by number or pattern. Patterns may include: speciﬁed characters, don’t
                  care characters, choices among characters, repetitions of these constructs, beginning
                  of line, end of line.
                  Add, delete, change, copy, move or join lines.
                  Permute or split contents of a line.
                  Replace one or all instances of a pattern within a line.
                  Combine or split ﬁles.
                  Escape to Shell (command language) during editing.
                  Do any of above operations on every pattern-selected line in a given range.
                  Optional encryption for extra security.
 PTX           Make a permuted (key word in context) index.
 SPELL         Look for spelling errors by comparing each word in a document against a word list.
                 25,000-word list includes proper names.
                 Handles common preﬁxes and sufﬁxes.
                 Collects words to help tailor local spelling lists.
 LOOK          Search for words in dictionary that begin with speciﬁed preﬁx.
 TYPO          Look for spelling errors by a statistical technique; not limited to English.
 CRYPT         Encrypt and decrypt ﬁles for security.

3.2. Document Formatting

 ROFF          A typesetting program for terminals. Easy for nontechnical people to learn, and good
               for simple documents. Input consists of data lines intermixed with control lines, such
               as


                                                ROFF is deemed to be obsolete;
               it is intended only for casual use.
                  Justiﬁcation of either or both margins.
                  Automatic hyphenation.
                  Generalized running heads and feet, with even-odd page capability, numbering, etc.
                  Deﬁnable macros for frequently used control sequences (no substitutable arguments).
                  All 4 margins and page size dynamically adjustable.
                  Hanging indents and one-line indents.
                  Absolute and relative parameter settings.
                  Optional legal-style numbering of output lines.
                  Multiple ﬁle capability.
                  Not usable as a ﬁlter.
 TROFF
 NROFF         Advanced typesetting. TROFF drives a Graphic Systems phototypesetter; NROFF
               drives ascii terminals of all types. This summary was typeset using TROFF. TROFF
               and NROFF style is similar to ROFF, but they are capable of much more elaborate
               feats of formatting, when appropriately programmed. TROFF and NROFF accept the
                                                 - 13 -


                 same input language.
                   All ROFF capabilities available or deﬁnable.
                   Completely deﬁnable page format keyed to dynamically planted ‘‘interrupts’’ at
                   speciﬁed lines.
                   Maintains several separately deﬁnable typesetting environments (e.g., one for body
                   text, one for footnotes, and one for unusually elaborate headings).
                   Arbitrary number of output pools can be combined at will.
                   Macros with substitutable arguments, and macros invocable in mid-line.
                   Computation and printing of numerical quantities.
                   Conditional execution of macros.
                   Tabular layout facility.
                   Positions expressible in inches, centimeters, ems, points, machine units or arithmetic
                   combinations thereof.
                   Access to character-width computation for unusually difﬁcult layout problems.
                   Overstrikes, built-up brackets, horizontal and vertical line drawing.
                   Dynamic relative or absolute positioning and size selection, globally or at the char-
                   acter level.
                   Can exploit the characteristics of the terminal being used, for approximating special
                   characters, reverse motions, proportional spacing, etc.
The Graphic Systems typesetter has a vocabulary of several 102-character fonts (4 simultaneously) in 15
sizes. TROFF provides terminal output for rough sampling of the product.
NROFF will produce multicolumn output on terminals capable of reverse line feed, or through the post-
processor COL.
High programming skill is required to exploit the formatting capabilities of TROFF and NROFF,
although unskilled personnel can easily be trained to enter documents according to canned formats such
as those provided by MS, below. TROFF and EQN are essentially identical to NROFF and NEQN so it
is usually possible to deﬁne interchangeable formats to produce approximate proof copy on terminals
before actual typesetting. The preprocessors MS, TBL, and REFER are fully compatible with TROFF
and NROFF.
 MS              A standardized manuscript layout package for use with NROFF/TROFF. This docu-
                 ment was formatted with MS.
                   Page numbers and draft dates.
                   Automatically numbered subheads.
                   Footnotes.
                   Single or double column.
                   Paragraphing, display and indentation.
                   Numbered equations.
 EQN             A mathematical typesetting preprocessor for TROFF. Translates easily readable formu-
                 las, either in-line or displayed, into detailed typesetting instructions. Formulas are
                 written in a style like this:
                         sigma sup 2 ˜=˜ 1 over N sum from i=1 to N ( x sub i – x bar ) sup 2
                 which produces:
                                                1 N
                                           σ2 = __ Σ (xi  )2
                                                         −x
                                                N i =1
                   Automatic calculation of size changes for subscripts, sub-subscripts, etc.
                   Full vocabulary of Greek letters and special symbols, such as ‘gamma’, ‘GAMMA’,
                   ‘integral’.
                                                - 14 -


                 Automatic calculation of large bracket sizes.
                 Vertical ‘‘piling’’ of formulae for matrices, conditional alternatives, etc.
                 Integrals, sums, etc., with arbitrarily complex limits.
                 Diacriticals: dots, double dots, hats, bars, etc.
                 Easily learned by nonprogrammers and mathematical typists.
 NEQN          A version of EQN for NROFF; accepts the same input language. Prepares formulas
               for display on any terminal that NROFF knows about, for example, those based on
               Diablo printing mechanism.
                  Same facilities as EQN within graphical capability of terminal.
 TBL           A preprocessor for NROFF/TROFF that translates simple descriptions of table layouts
               and contents into detailed typesetting instructions.
                 Computes column widths.
                 Handles left- and right-justiﬁed columns, centered columns and decimal-point align-
                 ment.
                 Places column titles.
                 Table entries can be text, which is adjusted to ﬁt.
                 Can box all or parts of table.
 REFER         Fills in bibliographic citations in a document from a data base (not supplied).
                  References may be printed in any style, as they occur or collected at the end.
                  May be numbered sequentially, by name of author, etc.
 TC            Simulate Graphic Systems typesetter on Tektronix 4014 scope. Useful for checking
               TROFF page layout before typesetting.
 GREEK         Fancy printing on Diablo-mechanism terminals like DASI-300 and DASI-450, and on
               Tektronix 4014.
                 Gives half-line forward and reverse motions.
                 Approximates Greek letters and other special characters by overstriking.
 COL           Canonicalize ﬁles with reverse line feeds for one-pass printing.
 DEROFF        Remove all TROFF commands from input.
 CHECKEQ       Check document for possible errors in EQN usage.

4. Information Handling

 SORT          Sort or merge ASCII ﬁles line-by-line. No limit on input size.
                 Sort up or down.
                 Sort lexicographically or on numeric key.
                 Multiple keys located by delimiters or by character position.
                 May sort upper case together with lower into dictionary order.
                 Optionally suppress duplicate data.
 TSORT         Topological sort — converts a partial order into a total order.
 UNIQ          Collapse successive duplicate lines in a ﬁle into one line.
                 Publish lines that were originally unique, duplicated, or both.
                 May give redundancy count for each line.
 TR            Do one-to-one character translation according to an arbitrary code.
                 May coalesce selected repeated characters.
                 May delete selected characters.
 DIFF          Report line changes, additions and deletions necessary to bring two ﬁles into agree-
               ment.
                                                   - 15 -


                   May produce an editor script to convert one ﬁle into another.
                   A variant compares two new versions against one old one.
 COMM            Identify common lines in two sorted ﬁles. Output in up to 3 columns shows lines
                 present in ﬁrst ﬁle only, present in both, and/or present in second only.
 JOIN            Combine two ﬁles by joining records that have identical keys.
 GREP            Print all lines in a ﬁle that satisfy a pattern as used in the editor ED.
                   May print all lines that fail to match.
                   May print count of hits.
                   May print ﬁrst hit in each ﬁle.
 LOOK            Binary search in sorted ﬁle for lines with speciﬁed preﬁx.
 WC              Count the lines, ‘‘words’’ (blank-separated strings) and characters in a ﬁle.
 SED             Stream-oriented version of ED. Can perform a sequence of editing operations on each
                 line of an input stream of unbounded length.
                    Lines may be selected by address or range of addresses.
                    Control ﬂow and conditional testing.
                    Multiple output streams.
                    Multi-line capability.
 AWK             Pattern scanning and processing language. Searches input for patterns, and performs
                 actions on each line of input that satisﬁes the pattern.
                   Patterns include regular expressions, arithmetic and lexicographic conditions,
                   boolean combinations and ranges of these.
                   Data treated as string or numeric as appropriate.
                   Can break input into ﬁelds; ﬁelds are variables.
                   Variables and arrays (with non-numeric subscripts).
                   Full set of arithmetic operators and control ﬂow.
                   Multiple output streams to ﬁles and pipes.
                   Output can be formatted as desired.
                   Multi-line capabilities.

5. Graphics
The programs in this section are predominantly intended for use with Tektronix 4014 storage scopes.
 GRAPH           Prepares a graph of a set of input numbers.
                   Input scaled to ﬁt standard plotting area.
                   Abscissae may be supplied automatically.
                   Graph may be labeled.
                   Control over grid style, line style, graph orientation, etc.
 SPLINE          Provides a smooth curve through a set of points intended for GRAPH.
 PLOT            A set of ﬁlters for printing graphs produced by GRAPH and other programs on various
                 terminals. Filters provided for 4014, DASI terminals, Versatec printer/plotter.

6. Novelties, Games, and Things That Didn’t Fit Anywhere Else

 BACKGAMMON
          A player of modest accomplishment.
 CHESS           Plays good class D chess.
                                              - 16 -


CHECKERS     Ditto, for checkers.
BCD          Converts ascii to card-image form.
PPT          Converts ascii to paper tape form.
BJ           A blackjack dealer.
CUBIC        An accomplished player of 4×4×4 tic-tac-toe.
MAZE         Constructs random mazes for you to solve.
MOO          A fascinating number-guessing game.
CAL          Print a calendar of speciﬁed month and year.
BANNER       Print output in huge letters.
CHING        The I Ching. Place your own interpretation on the output.
FORTUNE      Presents a random fortune cookie on each invocation. Limited jar of cookies included.
UNITS        Convert amounts between different scales of measurement. Knows hundreds of units.
             For example, how many km/sec is a parsec/megayear?
TTT          A tic-tac-toe program that learns. It never makes the same mistake twice.
ARITHMETIC
             Speed and accuracy test for number facts.
FACTOR       Factor large integers.
QUIZ         Test your knowledge of Shakespeare, Presidents, capitals, etc.
WUMP         Hunt the wumpus, thrilling search in a dangerous cave.
REVERSI      A two person board game, isomorphic to Othello®.
HANGMAN      Word-guessing game. Uses the dictionary supplied with SPELL.
FISH         Children’s card-guessing game.
                                     The UNIX Time-Sharing System*

                                            D. M. Ritchie and K. Thompson



                                                        ABSTRACT

                UNIX† is a general-purpose, multi-user, interactive operating system for the larger
          Digital Equipment Corporation PDP-11 and the Interdata 8/32 computers. It offers a
          number of features seldom found even in larger operating systems, including
          i       A hierarchical ﬁle system incorporating demountable volumes,
          ii      Compatible ﬁle, device, and inter-process I/O,
          iii     The ability to initiate asynchronous processes,
          iv      System command language selectable on a per-user basis,
          v      Over 100 subsystems including a dozen languages,
          vi      High degree of portability.
          This paper discusses the nature and implementation of the ﬁle system and of the user
          command interface.


1. INTRODUCTION
       There have been four versions of the UNIX time-sharing system. The earliest (circa 1969-70) ran
on the Digital Equipment Corporation PDP-7 and -9 computers. The second version ran on the unpro-
tected PDP-11/20 computer. The third incorporated multiprogramming and ran on the PDP-11/34, /40,
/45, /60, and /70 computers; it is the one described in the previously published version of this paper, and
is also the most widely used today. This paper describes only the fourth, current system that runs on the
PDP-11/70 and the Interdata 8/32 computers. In fact, the differences among the various systems is rather
small; most of the revisions made to the originally published version of this paper, aside from those con-
cerned with style, had to do with details of the implementation of the ﬁle system.
      Since PDP-11 UNIX became operational in February, 1971, over 600 installations have been put into
service. Most of them are engaged in applications such as computer science education, the preparation
and formatting of documents and other textual material, the collection and processing of trouble data
from various switching machines within the Bell System, and recording and checking telephone service
orders. Our own installation is used mainly for research in operating systems, languages, computer net-
works, and other topics in computer science, and also for document preparation.
      Perhaps the most important achievement of UNIX is to demonstrate that a powerful operating sys-
tem for interactive use need not be expensive either in equipment or in human effort: it can run on
hardware costing as little as $40,000, and less than two man-years were spent on the main system
software. We hope, however, that users ﬁnd that the most important characteristics of the system are its
simplicity, elegance, and ease of use.
         Besides the operating system proper, some major programs available under UNIX are
__________________
* Copyright 1974, Association for Computing Machinery, Inc., reprinted by permission. This is a revised version of an
article that appeared in Communications of the ACM, 17, No. 7 (July 1974), pp. 365-375. That article was a revised
version of a paper presented at the Fourth ACM Symposium on Operating Systems Principles, IBM Thomas J. Watson
Research Center, Yorktown Heights, New York, October 15-17, 1973.
†UNIX is a Trademark of Bell Laboratories.
                                                  -2-


        C compiler
        Text editor based on QED1
        Assembler, linking loader, symbolic debugger
        Phototypesetting and equation setting programs23
        Dozens of languages including Fortran 77, Basic, Snobol, APL, Algol 68, M6, TMG, Pascal
There is a host of maintenance, utility, recreation and novelty programs, all written locally. The UNIX
user community, which numbers in the thousands, has contributed many more programs and languages.
It is worth noting that the system is totally self-supporting. All UNIX software is maintained on the sys-
tem; likewise, this paper and all other documents in this issue were generated and formatted by the UNIX
editor and text formatting programs.

II. HARDWARE AND SOFTWARE ENVIRONMENT
      The PDP-11/70 on which the Research UNIX system is installed is a 16-bit word (8-bit byte) com-
puter with 768K bytes of core memory; the system kernel occupies 90K bytes about equally divided
between code and data tables. This system, however, includes a very large number of device drivers and
enjoys a generous allotment of space for I/O buffers and system tables; a minimal system capable of
running the software mentioned above can require as little as 96K bytes of core altogether. There are
even larger installations; see the description of the PWB/UNIX systems,45 for example. There are also
much smaller, though somewhat restricted, versions of the system.6
       Our own PDP-11 has two 200-Mb moving-head disks for ﬁle system storage and swapping. There
are 20 variable-speed communications interfaces attached to 300- and 1200-baud data sets, and an addi-
tional 12 communication lines hard-wired to 9600-baud terminals and satellite computers. There are
also several 2400- and 4800-baud synchronous communication interfaces used for machine-to-machine
ﬁle transfer. Finally, there is a variety of miscellaneous devices including nine-track magnetic tape, a
line printer, a voice synthesizer, a phototypesetter, a digital switching network, and a chess machine.
       The preponderance of UNIX software is written in the abovementioned C language.7 Early versions
of the operating system were written in assembly language, but during the summer of 1973, it was
rewritten in C. The size of the new system was about one-third greater than that of the old. Since the
new system not only became much easier to understand and to modify but also included many func-
tional improvements, including multiprogramming and the ability to share reentrant code among several
user programs, we consider this increase in size quite acceptable.

III. THE FILE SYSTEM
       The most important role of the system is to provide a ﬁle system. From the point of view of the
user, there are three kinds of ﬁles: ordinary disk ﬁles, directories, and special ﬁles.

3.1 Ordinary ﬁles
       A ﬁle contains whatever information the user places on it, for example, symbolic or binary
(object) programs. No particular structuring is expected by the system. A ﬁle of text consists simply of
a string of characters, with lines demarcated by the newline character. Binary programs are sequences
of words as they will appear in core memory when the program starts executing. A few user programs
manipulate ﬁles with more structure; for example, the assembler generates, and the loader expects, an
object ﬁle in a particular format. However, the structure of ﬁles is controlled by the programs that use
them, not by the system.

3.2 Directories
      Directories provide the mapping between the names of ﬁles and the ﬁles themselves, and thus
induce a structure on the ﬁle system as a whole. Each user has a directory of his own ﬁles; he may also
create subdirectories to contain groups of ﬁles conveniently treated together. A directory behaves
exactly like an ordinary ﬁle except that it cannot be written on by unprivileged programs, so that the
system controls the contents of directories. However, anyone with appropriate permission may read a
directory just like any other ﬁle.
                                                    -3-


      The system maintains several directories for its own use. One of these is the root directory. All
ﬁles in the system can be found by tracing a path through a chain of directories until the desired ﬁle is
reached. The starting point for such searches is often the root. Other system directories contain all the
programs provided for general use; that is, all the commands. As will be seen, however, it is by no
means necessary that a program reside in one of these directories for it to be executed.
       Files are named by sequences of 14 or fewer characters. When the name of a ﬁle is speciﬁed to
the system, it may be in the form of a path name, which is a sequence of directory names separated by
slashes, ‘‘/ ’’, and ending in a ﬁle name. If the sequence begins with a slash, the search begins in the
root directory. The name /alpha/beta/gamma causes the system to search the root for directory alpha,
then to search alpha for beta, ﬁnally to ﬁnd gamma in beta. gamma may be an ordinary ﬁle, a direc-
tory, or a special ﬁle. As a limiting case, the name ‘‘/ ’’ refers to the root itself.
      A path name not starting with ‘‘/ ’’ causes the system to begin the search in the user’s current
directory. Thus, the name alpha/beta speciﬁes the ﬁle named beta in subdirectory alpha of the current
directory. The simplest kind of name, for example, alpha, refers to a ﬁle that itself is found in the
current directory. As another limiting case, the null ﬁle name refers to the current directory.
       The same non-directory ﬁle may appear in several directories under possibly different names.
This feature is called linking; a directory entry for a ﬁle is sometimes called a link. The UNIX system
differs from other systems in which linking is permitted in that all links to a ﬁle have equal status. That
is, a ﬁle does not exist within a particular directory; the directory entry for a ﬁle consists merely of its
name and a pointer to the information actually describing the ﬁle. Thus a ﬁle exists independently of
any directory entry, although in practice a ﬁle is made to disappear along with the last link to it.
      Each directory always has at least two entries. The name ‘‘ . ’’ in each directory refers to the
directory itself. Thus a program may read the current directory under the name ‘‘ . ’’ without knowing
its complete path name. The name ‘‘ . . ’’ by convention refers to the parent of the directory in which it
appears, that is, to the directory in which it was created.
       The directory structure is constrained to have the form of a rooted tree. Except for the special
entries ‘‘ . ’’ and ‘‘ . . ’’, each directory must appear as an entry in exactly one other directory, which is
its parent. The reason for this is to simplify the writing of programs that visit subtrees of the directory
structure, and more important, to avoid the separation of portions of the hierarchy. If arbitrary links to
directories were permitted, it would be quite difﬁcult to detect when the last connection from the root to
a directory was severed.

3.3 Special ﬁles
       Special ﬁles constitute the most unusual feature of the UNIX ﬁle system. Each supported I/O dev-
ice is associated with at least one such ﬁle. Special ﬁles are read and written just like ordinary disk
ﬁles, but requests to read or write result in activation of the associated device. An entry for each special
ﬁle resides in directory /dev, although a link may be made to one of these ﬁles just as it may to an ordi-
nary ﬁle. Thus, for example, to write on a magnetic tape one may write on the ﬁle /dev/mt. Special
ﬁles exist for each communication line, each disk, each tape drive, and for physical main memory. Of
course, the active disks and the memory special ﬁle are protected from indiscriminate access.
      There is a threefold advantage in treating I/O devices this way: ﬁle and device I/O are as similar
as possible; ﬁle and device names have the same syntax and meaning, so that a program expecting a ﬁle
name as a parameter can be passed a device name; ﬁnally, special ﬁles are subject to the same protection
mechanism as regular ﬁles.

3.4 Removable ﬁle systems
      Although the root of the ﬁle system is always stored on the same device, it is not necessary that
the entire ﬁle system hierarchy reside on this device. There is a mount system request with two argu-
ments: the name of an existing ordinary ﬁle, and the name of a special ﬁle whose associated storage
volume (e.g., a disk pack) should have the structure of an independent ﬁle system containing its own
directory hierarchy. The effect of mount is to cause references to the heretofore ordinary ﬁle to refer
instead to the root directory of the ﬁle system on the removable volume. In effect, mount replaces a
                                                    -4-


leaf of the hierarchy tree (the ordinary ﬁle) by a whole new subtree (the hierarchy stored on the remov-
able volume). After the mount, there is virtually no distinction between ﬁles on the removable volume
and those in the permanent ﬁle system. In our installation, for example, the root directory resides on a
small partition of one of our disk drives, while the other drive, which contains the user’s ﬁles, is
mounted by the system initialization sequence. A mountable ﬁle system is generated by writing on its
corresponding special ﬁle. A utility program is available to create an empty ﬁle system, or one may
simply copy an existing ﬁle system.
      There is only one exception to the rule of identical treatment of ﬁles on different devices: no link
may exist between one ﬁle system hierarchy and another. This restriction is enforced so as to avoid the
elaborate bookkeeping that would otherwise be required to assure removal of the links whenever the
removable volume is dismounted.

3.5 Protection
      Although the access control scheme is quite simple, it has some unusual features. Each user of
the system is assigned a unique user identiﬁcation number. When a ﬁle is created, it is marked with the
user ID of its owner. Also given for new ﬁles is a set of ten protection bits. Nine of these specify
independently read, write, and execute permission for the owner of the ﬁle, for other members of his
group, and for all remaining users.
       If the tenth bit is on, the system will temporarily change the user identiﬁcation (hereafter, user ID)
of the current user to that of the creator of the ﬁle whenever the ﬁle is executed as a program. This
change in user ID is effective only during the execution of the program that calls for it. The set-user-ID
feature provides for privileged programs that may use ﬁles inaccessible to other users. For example, a
program may keep an accounting ﬁle that should neither be read nor changed except by the program
itself. If the set-user-ID bit is on for the program, it may access the ﬁle although this access might be
forbidden to other programs invoked by the given program’s user. Since the actual user ID of the
invoker of any program is always available, set-user-ID programs may take any measures desired to
satisfy themselves as to their invoker’s credentials. This mechanism is used to allow users to execute
the carefully written commands that call privileged system entries. For example, there is a system entry
invokable only by the ‘‘super-user’’ (below) that creates an empty directory. As indicated above, direc-
tories are expected to have entries for ‘‘ . ’’ and ‘‘ . . ’’. The command which creates a directory is
owned by the super-user and has the set-user-ID bit set. After it checks its invoker’s authorization to
create the speciﬁed directory, it creates it and makes the entries for ‘‘ . ’’ and ‘‘ . . ’’.
      Because anyone may set the set-user-ID bit on one of his own ﬁles, this mechanism is generally
available without administrative intervention. For example, this protection scheme easily solves the MOO
accounting problem posed by ‘‘Aleph-null.’’8
      The system recognizes one particular user ID (that of the ‘‘super-user’’) as exempt from the usual
constraints on ﬁle access; thus (for example), programs may be written to dump and reload the ﬁle sys-
tem without unwanted interference from the protection system.

3.6 I/O calls
      The system calls to do I/O are designed to eliminate the differences between the various devices
and styles of access. There is no distinction between ‘‘random’’ and ‘‘sequential’’ I/O, nor is any logi-
cal record size imposed by the system. The size of an ordinary ﬁle is determined by the number of
bytes written on it; no predetermination of the size of a ﬁle is necessary or possible.
       To illustrate the essentials of I/O, some of the basic calls are summarized below in an anonymous
language that will indicate the required parameters without getting into the underlying complexities.
Each call to the system may potentially result in an error return, which for simplicity is not represented
in the calling sequence.
      To read or write a ﬁle assumed to exist already, it must be opened by the following call:
         ﬁlep = open ( name, ﬂag )
where name indicates the name of the ﬁle. An arbitrary path name may be given. The flag argument
                                                    -5-


indicates whether the ﬁle is to be read, written, or ‘‘updated,’’ that is, read and written simultaneously.
      The returned value filep is called a file descriptor. It is a small integer used to identify the ﬁle in
subsequent calls to read, write, or otherwise manipulate the ﬁle.
      To create a new ﬁle or completely rewrite an old one, there is a create system call that creates the
given ﬁle if it does not exist, or truncates it to zero length if it does exist; create also opens the new ﬁle
for writing and, like open, returns a ﬁle descriptor.
      The ﬁle system maintains no locks visible to the user, nor is there any restriction on the number
of users who may have a ﬁle open for reading or writing. Although it is possible for the contents of a
ﬁle to become scrambled when two users write on it simultaneously, in practice difﬁculties do not arise.
We take the view that locks are neither necessary nor sufﬁcient, in our environment, to prevent interfer-
ence between users of the same ﬁle. They are unnecessary because we are not faced with large, single-
ﬁle data bases maintained by independent processes. They are insufﬁcient because locks in the ordinary
sense, whereby one user is prevented from writing on a ﬁle that another user is reading, cannot prevent
confusion when, for example, both users are editing a ﬁle with an editor that makes a copy of the ﬁle
being edited.
      There are, however, sufﬁcient internal interlocks to maintain the logical consistency of the ﬁle sys-
tem when two users engage simultaneously in activities such as writing on the same ﬁle, creating ﬁles in
the same directory, or deleting each other’s open ﬁles.
      Except as indicated below, reading and writing are sequential. This means that if a particular byte
in the ﬁle was the last byte written (or read), the next I/O call implicitly refers to the immediately fol-
lowing byte. For each open ﬁle there is a pointer, maintained inside the system, that indicates the next
byte to be read or written. If n bytes are read or written, the pointer advances by n bytes.
      Once a ﬁle is open, the following calls may be used:
         n = read ( ﬁlep, buffer, count )
         n = write ( ﬁlep, buffer, count )
Up to count bytes are transmitted between the ﬁle speciﬁed by filep and the byte array speciﬁed by
buffer. The returned value n is the number of bytes actually transmitted. In the write case, n is the
same as count except under exceptional conditions, such as I/O errors or end of physical medium on
special ﬁles; in a read, however, n may without error be less than count. If the read pointer is so near
the end of the ﬁle that reading count characters would cause reading beyond the end, only sufﬁcient
bytes are transmitted to reach the end of the ﬁle; also, typewriter-like terminals never return more than
one line of input. When a read call returns with n equal to zero, the end of the ﬁle has been reached.
For disk ﬁles this occurs when the read pointer becomes equal to the current size of the ﬁle. It is possi-
ble to generate an end-of-ﬁle from a terminal by use of an escape sequence that depends on the device
used.
      Bytes written affect only those parts of a ﬁle implied by the position of the write pointer and the
count; no other part of the ﬁle is changed. If the last byte lies beyond the end of the ﬁle, the ﬁle is
made to grow as needed.
     To do random (direct-access) I/O it is only necessary to move the read or write pointer to the
appropriate location in the ﬁle.
         location = lseek ( ﬁlep, offset, base )
The pointer associated with filep is moved to a position offset bytes from the beginning of the ﬁle, from
the current position of the pointer, or from the end of the ﬁle, depending on base. offset may be nega-
tive. For some devices (e.g., paper tape and terminals) seek calls are ignored. The actual offset from
the beginning of the ﬁle to which the pointer was moved is returned in location.
      There are several additional system entries having to do with I/O and with the ﬁle system that will
not be discussed. For example: close a ﬁle, get the status of a ﬁle, change the protection mode or the
owner of a ﬁle, create a directory, make a link to an existing ﬁle, delete a ﬁle.
                                                   -6-


IV. IMPLEMENTATION OF THE FILE SYSTEM
      As mentioned in Section 3.2 above, a directory entry contains only a name for the associated ﬁle
and a pointer to the ﬁle itself. This pointer is an integer called the i-number (for index number) of the
ﬁle. When the ﬁle is accessed, its i-number is used as an index into a system table (the i-list ) stored in
a known part of the device on which the directory resides. The entry found thereby (the ﬁle’s i-node )
contains the description of the ﬁle:
i     the user and group-ID of its owner
ii    its protection bits
iii   the physical disk or tape addresses for the ﬁle contents
iv    its size
v     time of creation, last use, and last modiﬁcation
vi    the number of links to the ﬁle, that is, the number of times it appears in a directory
vii   a code indicating whether the ﬁle is a directory, an ordinary ﬁle, or a special ﬁle.
The purpose of an open or create system call is to turn the path name given by the user into an i-
number by searching the explicitly or implicitly named directories. Once a ﬁle is open, its device, i-
number, and read/write pointer are stored in a system table indexed by the ﬁle descriptor returned by the
open or create. Thus, during a subsequent call to read or write the ﬁle, the descriptor may be easily
related to the information necessary to access the ﬁle.
      When a new ﬁle is created, an i-node is allocated for it and a directory entry is made that contains
the name of the ﬁle and the i-node number. Making a link to an existing ﬁle involves creating a direc-
tory entry with the new name, copying the i-number from the original ﬁle entry, and incrementing the
link-count ﬁeld of the i-node. Removing (deleting) a ﬁle is done by decrementing the link-count of the
i-node speciﬁed by its directory entry and erasing the directory entry. If the link-count drops to 0, any
disk blocks in the ﬁle are freed and the i-node is de-allocated.
      The space on all disks that contain a ﬁle system is divided into a number of 512-byte blocks logi-
cally addressed from 0 up to a limit that depends on the device. There is space in the i-node of each
ﬁle for 13 device addresses. For nonspecial ﬁles, the ﬁrst 10 device addresses point at the ﬁrst 10
blocks of the ﬁle. If the ﬁle is larger than 10 blocks, the 11 device address points to an indirect block
containing up to 128 addresses of additional blocks in the ﬁle. Still larger ﬁles use the twelfth device
address of the i-node to point to a double-indirect block naming 128 indirect blocks, each pointing to
128 blocks of the ﬁle. If required, the thirteenth device address is a triple-indirect block. Thus ﬁles
may conceptually grow to [ (10+128+1282+1283).512 ] bytes. Once opened, bytes numbered below 5120
can be read with a single disk access; bytes in the range 5120 to 70,656 require two accesses; bytes in
the range 70,656 to 8,459,264 require three accesses; bytes from there to the largest ﬁle (1,082,201,088)
require four accesses. In practice, a device cache mechanism (see below) proves effective in eliminating
most of the indirect fetches.
      The foregoing discussion applies to ordinary ﬁles. When an I/O request is made to a ﬁle whose
i-node indicates that it is special, the last 12 device address words are immaterial, and the ﬁrst speciﬁes
an internal device name, which is interpreted as a pair of numbers representing, respectively, a device
type and subdevice number. The device type indicates which system routine will deal with I/O on that
device; the subdevice number selects, for example, a disk drive attached to a particular controller or one
of several similar terminal interfaces.
      In this environment, the implementation of the mount system call (Section 3.4) is quite straight-
forward. mount maintains a system table whose argument is the i-number and device name of the ordi-
nary ﬁle speciﬁed during the mount, and whose corresponding value is the device name of the indicated
special ﬁle. This table is searched for each i-number/device pair that turns up while a path name is
being scanned during an open or create; if a match is found, the i-number is replaced by the i-number
of the root directory and the device name is replaced by the table value.
    To the user, both reading and writing of ﬁles appear to be synchronous and unbuffered. That is,
immediately after return from a read call the data are available; conversely, after a write the user’s
                                                   -7-


workspace may be reused. In fact, the system maintains a rather complicated buffering mechanism that
reduces greatly the number of I/O operations required to access a ﬁle. Suppose a write call is made
specifying transmission of a single byte. The system will search its buffers to see whether the affected
disk block currently resides in main memory; if not, it will be read in from the device. Then the
affected byte is replaced in the buffer and an entry is made in a list of blocks to be written. The return
from the write call may then take place, although the actual I/O may not be completed until a later time.
Conversely, if a single byte is read, the system determines whether the secondary storage block in which
the byte is located is already in one of the system’s buffers; if so, the byte can be returned immediately.
If not, the block is read into a buffer and the byte picked out.
      The system recognizes when a program has made accesses to sequential blocks of a ﬁle, and asyn-
chronously pre-reads the next block. This signiﬁcantly reduces the running time of most programs while
adding little to system overhead.
      A program that reads or writes ﬁles in units of 512 bytes has an advantage over a program that
reads or writes a single byte at a time, but the gain is not immense; it comes mainly from the avoidance
of system overhead. If a program is used rarely or does no great volume of I/O, it may quite reasonably
read and write in units as small as it wishes.
       The notion of the i-list is an unusual feature of UNIX. In practice, this method of organizing the
ﬁle system has proved quite reliable and easy to deal with. To the system itself, one of its strengths is
the fact that each ﬁle has a short, unambiguous name related in a simple way to the protection, address-
ing, and other information needed to access the ﬁle. It also permits a quite simple and rapid algorithm
for checking the consistency of a ﬁle system, for example, veriﬁcation that the portions of each device
containing useful information and those free to be allocated are disjoint and together exhaust the space
on the device. This algorithm is independent of the directory hierarchy, because it need only scan the
linearly organized i-list. At the same time the notion of the i-list induces certain peculiarities not found
in other ﬁle system organizations. For example, there is the question of who is to be charged for the
space a ﬁle occupies, because all directory entries for a ﬁle have equal status. Charging the owner of a
ﬁle is unfair in general, for one user may create a ﬁle, another may link to it, and the ﬁrst user may
delete the ﬁle. The ﬁrst user is still the owner of the ﬁle, but it should be charged to the second user.
The simplest reasonably fair algorithm seems to be to spread the charges equally among users who have
links to a ﬁle. Many installations avoid the issue by not charging any fees at all.

V. PROCESSES AND IMAGES
      An image is a computer execution environment. It includes a memory image, general register
values, status of open ﬁles, current directory and the like. An image is the current state of a pseudo-
computer.
      A process is the execution of an image. While the processor is executing on behalf of a process,
the image must reside in main memory; during the execution of other processes it remains in main
memory unless the appearance of an active, higher-priority process forces it to be swapped out to the
disk.
       The user-memory part of an image is divided into three logical segments. The program text seg-
ment begins at location 0 in the virtual address space. During execution, this segment is write-protected
and a single copy of it is shared among all processes executing the same program. At the ﬁrst hardware
protection byte boundary above the program text segment in the virtual address space begins a non-
shared, writable data segment, the size of which may be extended by a system call. Starting at the
highest address in the virtual address space is a stack segment, which automatically grows downward as
the stack pointer ﬂuctuates.

5.1 Processes
      Except while the system is bootstrapping itself into operation, a new process can come into
existence only by use of the fork system call:
        processid = fork ( )
                                                   -8-


When fork is executed, the process splits into two independently executing processes. The two
processes have independent copies of the original memory image, and share all open ﬁles. The new
processes differ only in that one is considered the parent process: in the parent, the returned processid
actually identiﬁes the child process and is never 0, while in the child, the returned value is always 0.
      Because the values returned by fork in the parent and child process are distinguishable, each pro-
cess may determine whether it is the parent or child.

5.2 Pipes
       Processes may communicate with related processes using the same system read and write calls
that are used for ﬁle-system I/O. The call:
        ﬁlep = pipe ( )
returns a ﬁle descriptor filep and creates an inter-process channel called a pipe. This channel, like other
open ﬁles, is passed from parent to child process in the image by the fork call. A read using a pipe ﬁle
descriptor waits until another process writes using the ﬁle descriptor for the same pipe. At this point,
data are passed between the images of the two processes. Neither process need know that a pipe, rather
than an ordinary ﬁle, is involved.
      Although inter-process communication via pipes is a quite valuable tool (see Section 6.2), it is not
a completely general mechanism, because the pipe must be set up by a common ancestor of the
processes involved.

5.3 Execution of programs
      Another major system primitive is invoked by
           execute ( ﬁle, arg1, arg2, . . . , argn )
which requests the system to read in and execute the program named by file, passing it string arguments
arg1 , arg2 , . . . , argn. All the code and data in the process invoking execute is replaced from the file,
but open ﬁles, current directory, and inter-process relationships are unaltered. Only if the call fails, for
example because file could not be found or because its execute-permission bit was not set, does a return
take place from the execute primitive; it resembles a ‘‘jump’’ machine instruction rather than a subrou-
tine call.

5.4 Process synchronization
      Another process control system call:
        processid = wait ( status )
causes its caller to suspend execution until one of its children has completed execution. Then wait
returns the processid of the terminated process. An error return is taken if the calling process has no
descendants. Certain status from the child process is also available.

5.5 Termination
      Lastly:
        exit ( status )
terminates a process, destroys its image, closes its open ﬁles, and generally obliterates it. The parent is
notiﬁed through the wait primitive, and status is made available to it. Processes may also terminate as
a result of various illegal actions or user-generated signals (Section VII below).

VI. THE SHELL
      For most users, communication with the system is carried on with the aid of a program called the
shell. The shell is a command-line interpreter: it reads lines typed by the user and interprets them as
requests to execute other programs. (The shell is described fully elsewhere,9 so this section will discuss
                                                    -9-


only the theory of its operation.) In simplest form, a command line consists of the command name fol-
lowed by arguments to the command, all separated by spaces:
         command arg1 arg2 . . . argn
The shell splits up the command name and the arguments into separate strings. Then a ﬁle with name
command is sought; command may be a path name including the ‘‘/’’ character to specify any ﬁle in
the system. If command is found, it is brought into memory and executed. The arguments collected by
the shell are accessible to the command. When the command is ﬁnished, the shell resumes its own exe-
cution, and indicates its readiness to accept another command by typing a prompt character.
      If ﬁle command cannot be found, the shell generally preﬁxes a string such as / bin / to command
and attempts again to ﬁnd the ﬁle. Directory / bin contains commands intended to be generally used.
(The sequence of directories to be searched may be changed by user request.)

6.1 Standard I/O
      The discussion of I/O in Section III above seems to imply that every ﬁle used by a program must
be opened or created by the program in order to get a ﬁle descriptor for the ﬁle. Programs executed by
the shell, however, start off with three open ﬁles with ﬁle descriptors 0, 1, and 2. As such a program
begins execution, ﬁle 1 is open for writing, and is best understood as the standard output ﬁle. Except
under circumstances indicated below, this ﬁle is the user’s terminal. Thus programs that wish to write
informative information ordinarily use ﬁle descriptor 1. Conversely, ﬁle 0 starts off open for reading,
and programs that wish to read messages typed by the user read this ﬁle.
       The shell is able to change the standard assignments of these ﬁle descriptors from the user’s termi-
nal printer and keyboard. If one of the arguments to a command is preﬁxed by ‘‘>’’, ﬁle descriptor 1
will, for the duration of the command, refer to the ﬁle named after the ‘‘>’’. For example:
         ls
ordinarily lists, on the typewriter, the names of the ﬁles in the current directory. The command:
         ls >there
creates a ﬁle called there and places the listing there. Thus the argument >there means ‘‘place output
on there.’’ On the other hand:
         ed
ordinarily enters the editor, which takes requests from the user via his keyboard. The command
         ed <script
interprets script as a ﬁle of editor commands; thus <script means ‘‘take input from script.’’
        Although the ﬁle name following ‘‘<’’ or ‘‘>’’ appears to be an argument to the command, in fact
it is interpreted completely by the shell and is not passed to the command at all. Thus no special coding
to handle I/O redirection is needed within each command; the command need merely use the standard
ﬁle descriptors 0 and 1 where appropriate.
      File descriptor 2 is, like ﬁle 1, ordinarily associated with the terminal output stream. When an
output-diversion request with ‘‘>’’ is speciﬁed, ﬁle 2 remains attached to the terminal, so that commands
may produce diagnostic messages that do not silently end up in the output ﬁle.

6.2 Filters
      An extension of the standard I/O notion is used to direct output from one command to the input of
another. A sequence of commands separated by vertical bars causes the shell to execute all the com-
mands simultaneously and to arrange that the standard output of each command be delivered to the stan-
dard input of the next command in the sequence. Thus in the command line:
         ls  pr −2  opr
ls lists the names of the ﬁles in the current directory; its output is passed to pr, which paginates its input
                                                     - 10 -


with dated headings. (The argument ‘‘−2’’ requests double-column output.) Likewise, the output from
pr is input to opr; this command spools its input onto a ﬁle for off-line printing.
         This procedure could have been carried out more clumsily by:
           ls >temp1
           pr −2 <temp1 >temp2
           opr <temp2
followed by removal of the temporary ﬁles. In the absence of the ability to redirect output and input, a
still clumsier method would have been to require the ls command to accept user requests to paginate its
output, to print in multi-column format, and to arrange that its output be delivered off-line. Actually it
would be surprising, and in fact unwise for efﬁciency reasons, to expect authors of commands such as ls
to provide such a wide variety of output options.
      A program such as pr which copies its standard input to its standard output (with processing) is
called a filter. Some ﬁlters that we have found useful perform character transliteration, selection of lines
according to a pattern, sorting of the input, and encryption and decryption.

6.3 Command separators; multitasking
       Another feature provided by the shell is relatively straightforward. Commands need not be on dif-
ferent lines; instead they may be separated by semicolons:
           ls; ed
will ﬁrst list the contents of the current directory, then enter the editor.
      A related feature is more interesting. If a command is followed by ‘‘&,’’ the shell will not wait
for the command to ﬁnish before prompting again; instead, it is ready immediately to accept a new com-
mand. For example:
           as source >output &
causes source to be assembled, with diagnostic output going to output; no matter how long the assem-
bly takes, the shell returns immediately. When the shell does not wait for the completion of a com-
mand, the identiﬁcation number of the process running that command is printed. This identiﬁcation may
be used to wait for the completion of the command or to terminate it. The ‘‘&’’ may be used several
times in a line:
           as source >output & ls >ﬁles &
does both the assembly and the listing in the background. In these examples, an output ﬁle other than
the terminal was provided; if this had not been done, the outputs of the various commands would have
been intermingled.
         The shell also allows parentheses in the above operations. For example:
           ( date; ls ) >x &
writes the current date and time followed by a list of the current directory onto the ﬁle x. The shell also
returns immediately for another request.

6.4 The shell as a command; command ﬁles
         The shell is itself a command, and may be called recursively. Suppose ﬁle tryout contains the
lines:
           as source
           mv a.out testprog
           testprog
The mv command causes the ﬁle a.out to be renamed testprog. a.out is the (binary) output of the
assembler, ready to be executed. Thus if the three lines above were typed on the keyboard, source
would be assembled, the resulting program renamed testprog, and testprog executed. When the lines
                                                   - 11 -


are in tryout, the command:
         sh <tryout
would cause the shell sh to execute the commands sequentially.
       The shell has further capabilities, including the ability to substitute parameters and to construct
argument lists from a speciﬁed subset of the ﬁle names in a directory. It also provides general condi-
tional and looping constructions.

6.5 Implementation of the shell
       The outline of the operation of the shell can now be understood. Most of the time, the shell is
waiting for the user to type a command. When the newline character ending the line is typed, the
shell’s read call returns. The shell analyzes the command line, putting the arguments in a form
appropriate for execute. Then fork is called. The child process, whose code of course is still that of
the shell, attempts to perform an execute with the appropriate arguments. If successful, this will bring
in and start execution of the program whose name was given. Meanwhile, the other process resulting
from the fork, which is the parent process, waits for the child process to die. When this happens, the
shell knows the command is ﬁnished, so it types its prompt and reads the keyboard to obtain another
command.
      Given this framework, the implementation of background processes is trivial; whenever a com-
mand line contains ‘‘&,’’ the shell merely refrains from waiting for the process that it created to execute
the command.
       Happily, all of this mechanism meshes very nicely with the notion of standard input and output
ﬁles. When a process is created by the fork primitive, it inherits not only the memory image of its
parent but also all the ﬁles currently open in its parent, including those with ﬁle descriptors 0, 1, and 2.
The shell, of course, uses these ﬁles to read command lines and to write its prompts and diagnostics, and
in the ordinary case its children—the command programs—inherit them automatically. When an argu-
ment with ‘‘<’’ or ‘‘>’’ is given, however, the offspring process, just before it performs execute, makes
the standard I/O ﬁle descriptor (0 or 1, respectively) refer to the named ﬁle. This is easy because, by
agreement, the smallest unused ﬁle descriptor is assigned when a new ﬁle is opened (or created); it is
only necessary to close ﬁle 0 (or 1) and open the named ﬁle. Because the process in which the com-
mand program runs simply terminates when it is through, the association between a ﬁle speciﬁed after
‘‘<’’ or ‘‘>’’ and ﬁle descriptor 0 or 1 is ended automatically when the process dies. Therefore the shell
need not know the actual names of the ﬁles that are its own standard input and output, because it need
never reopen them.
      Filters are straightforward extensions of standard I/O redirection with pipes used instead of ﬁles.
      In ordinary circumstances, the main loop of the shell never terminates. (The main loop includes
the branch of the return from fork belonging to the parent process; that is, the branch that does a wait,
then reads another command line.) The one thing that causes the shell to terminate is discovering an
end-of-ﬁle condition on its input ﬁle. Thus, when the shell is executed as a command with a given
input ﬁle, as in:
         sh <comﬁle
the commands in comfile will be executed until the end of comfile is reached; then the instance of the
shell invoked by sh will terminate. Because this shell process is the child of another instance of the
shell, the wait executed in the latter will return, and another command may then be processed.

6.6 Initialization
      The instances of the shell to which users type commands are themselves children of another pro-
cess. The last step in the initialization of the system is the creation of a single process and the invoca-
tion (via execute) of a program called init. The role of init is to create one process for each terminal
channel. The various subinstances of init open the appropriate terminals for input and output on ﬁles 0,
1, and 2, waiting, if necessary, for carrier to be established on dial-up lines. Then a message is typed
                                                  - 12 -


out requesting that the user log in. When the user types a name or other identiﬁcation, the appropriate
instance of init wakes up, receives the log-in line, and reads a password ﬁle. If the user’s name is
found, and if he is able to supply the correct password, init changes to the user’s default current direc-
tory, sets the process’s user ID to that of the person logging in, and performs an execute of the shell. At
this point, the shell is ready to receive commands and the logging-in protocol is complete.
      Meanwhile, the mainstream path of init (the parent of all the subinstances of itself that will later
become shells) does a wait. If one of the child processes terminates, either because a shell found an end
of ﬁle or because a user typed an incorrect name or password, this path of init simply recreates the
defunct process, which in turn reopens the appropriate input and output ﬁles and types another log-in
message. Thus a user may log out simply by typing the end-of-ﬁle sequence to the shell.

6.7 Other programs as shell
     The shell as described above is designed to allow users full access to the facilities of the system,
because it will invoke the execution of any program with appropriate protection mode. Sometimes,
however, a different interface to the system is desirable, and this feature is easily arranged for.
      Recall that after a user has successfully logged in by supplying a name and password, init ordi-
narily invokes the shell to interpret command lines. The user’s entry in the password ﬁle may contain
the name of a program to be invoked after log-in instead of the shell. This program is free to interpret
the user’s messages in any way it wishes.
       For example, the password ﬁle entries for users of a secretarial editing system might specify that
the editor ed is to be used instead of the shell. Thus when users of the editing system log in, they are
inside the editor and can begin work immediately; also, they can be prevented from invoking programs
not intended for their use. In practice, it has proved desirable to allow a temporary escape from the edi-
tor to execute the formatting program and other utilities.
      Several of the games (e.g., chess, blackjack, 3D tic-tac-toe) available on the system illustrate a
much more severely restricted environment. For each of these, an entry exists in the password ﬁle
specifying that the appropriate game-playing program is to be invoked instead of the shell. People who
log in as a player of one of these games ﬁnd themselves limited to the game and unable to investigate
the (presumably more interesting) offerings of the UNIX system as a whole.

VII. TRAPS
       The PDP-11 hardware detects a number of program faults, such as references to non-existent
memory, unimplemented instructions, and odd addresses used where an even address is required. Such
faults cause the processor to trap to a system routine. Unless other arrangements have been made, an
illegal action causes the system to terminate the process and to write its image on ﬁle core in the current
directory. A debugger can be used to determine the state of the program at the time of the fault.
      Programs that are looping, that produce unwanted output, or about which the user has second
thoughts may be halted by the use of the interrupt signal, which is generated by typing the ‘‘delete’’
character. Unless special action has been taken, this signal simply causes the program to cease execu-
tion without producing a core ﬁle. There is also a quit signal used to force an image ﬁle to be pro-
duced. Thus programs that loop unexpectedly may be halted and the remains inspected without prear-
rangement.
       The hardware-generated faults and the interrupt and quit signals can, by request, be either ignored
or caught by a process. For example, the shell ignores quits to prevent a quit from logging the user out.
The editor catches interrupts and returns to its command level. This is useful for stopping long printouts
without losing work in progress (the editor manipulates a copy of the ﬁle it is editing). In systems
without ﬂoating-point hardware, unimplemented instructions are caught and ﬂoating-point instructions
are interpreted.
                                                  - 13 -


VIII. PERSPECTIVE
       Perhaps paradoxically, the success of the UNIX system is largely due to the fact that it was not
designed to meet any predeﬁned objectives. The ﬁrst version was written when one of us (Thompson),
dissatisﬁed with the available computer facilities, discovered a little-used PDP-7 and set out to create a
more hospitable environment. This (essentially personal) effort was sufﬁciently successful to gain the
interest of the other author and several colleagues, and later to justify the acquisition of the PDP-11/20,
speciﬁcally to support a text editing and formatting system. When in turn the 11/20 was outgrown, the
system had proved useful enough to persuade management to invest in the PDP-11/45, and later in the
PDP-11/70 and Interdata 8/32 machines, upon which it developed to its present form. Our goals
throughout the effort, when articulated at all, have always been to build a comfortable relationship with
the machine and to explore ideas and inventions in operating systems and other software. We have not
been faced with the need to satisfy someone else’s requirements, and for this freedom we are grateful.
      Three considerations that inﬂuenced the design of UNIX are visible in retrospect.
       First: because we are programmers, we naturally designed the system to make it easy to write,
test, and run programs. The most important expression of our desire for programming convenience was
that the system was arranged for interactive use, even though the original version only supported one
user. We believe that a properly designed interactive system is much more productive and satisfying to
use than a ‘‘batch’’ system. Moreover, such a system is rather easily adaptable to noninteractive use,
while the converse is not true.
       Second: there have always been fairly severe size constraints on the system and its software.
Given the partially antagonistic desires for reasonable efﬁciency and expressive power, the size con-
straint has encouraged not only economy, but also a certain elegance of design. This may be a thinly
disguised version of the ‘‘salvation through suffering’’ philosophy, but in our case it worked.
      Third: nearly from the start, the system was able to, and did, maintain itself. This fact is more
important than it might seem. If designers of a system are forced to use that system, they quickly
become aware of its functional and superﬁcial deﬁciencies and are strongly motivated to correct them
before it is too late. Because all source programs were always available and easily modiﬁed on-line, we
were willing to revise and rewrite the system and its software when new ideas were invented,
discovered, or suggested by others.
      The aspects of UNIX discussed in this paper exhibit clearly at least the ﬁrst two of these design
considerations. The interface to the ﬁle system, for example, is extremely convenient from a program-
ming standpoint. The lowest possible interface level is designed to eliminate distinctions between the
various devices and ﬁles and between direct and sequential access. No large ‘‘access method’’ routines
are required to insulate the programmer from the system calls; in fact, all user programs either call the
system directly or use a small library program, less than a page long, that buffers a number of characters
and reads or writes them all at once.
      Another important aspect of programming convenience is that there are no ‘‘control blocks’’ with
a complicated structure partially maintained by and depended on by the ﬁle system or other system calls.
Generally speaking, the contents of a program’s address space are the property of the program, and we
have tried to avoid placing restrictions on the data structures within that address space.
       Given the requirement that all programs should be usable with any ﬁle or device as input or out-
put, it is also desirable to push device-dependent considerations into the operating system itself. The
only alternatives seem to be to load, with all programs, routines for dealing with each device, which is
expensive in space, or to depend on some means of dynamically linking to the routine appropriate to
each device when it is actually needed, which is expensive either in overhead or in hardware.
       Likewise, the process-control scheme and the command interface have proved both convenient and
efﬁcient. Because the shell operates as an ordinary, swappable user program, it consumes no ‘‘wired-
down’’ space in the system proper, and it may be made as powerful as desired at little cost. In particu-
lar, given the framework in which the shell executes as a process that spawns other processes to perform
commands, the notions of I/O redirection, background processes, command ﬁles, and user-selectable sys-
tem interfaces all become essentially trivial to implement.
                                                  - 14 -


Inﬂuences
      The success of UNIX lies not so much in new inventions but rather in the full exploitation of a
carefully selected set of fertile ideas, and especially in showing that they can be keys to the implementa-
tion of a small yet powerful operating system.
      The fork operation, essentially as we implemented it, was present in the GENIE time-sharing sys-
tem.10 On a number of points we were inﬂuenced by Multics, which suggested the particular form of the
I/O system calls11 and both the name of the shell and its general functions. The notion that the shell
should create a process for each command was also suggested to us by the early design of Multics,
although in that system it was later dropped for efﬁciency reasons. A similar scheme is used by
TENEX.12


IX. STATISTICS
      The following numbers are presented to suggest the scale of the Research UNIX operation. Those
of our users not involved in document preparation tend to use the system for program development,
especially language work. There are few important ‘‘applications’’ programs.
      Overall, we have today:

                              125       user population
                               33       maximum simultaneous users
                            1,630       directories
                           28,300       ﬁles
                          301,700       512-byte secondary storage blocks used

There is a ‘‘background’’ process that runs at the lowest possible priority; it is used to soak up any idle
CPU time. It has been used to produce a million-digit approximation to the constant e, and other semi-
inﬁnite problems. Not counting this background work, we average daily:

                                       13,500       commands
                                           9.6      CPU hours
                                          230       connect hours
                                            62      different users
                                          240       log-ins


X. ACKNOWLEDGMENTS
      The contributors to UNIX are, in the traditional but here especially apposite phrase, too numerous
to mention. Certainly, collective salutes are due to our colleagues in the Computing Science Research
Center. R. H. Canaday contributed much to the basic design of the ﬁle system. We are particularly
appreciative of the inventiveness, thoughtful criticism, and constant support of R. Morris, M. D. McIl-
roy, and J. F. Ossanna.

References
1.    L. P. Deutsch and B. W. Lampson, ‘‘An online editor,’’ Comm. Assoc. Comp. Mach. 10(12),
      pp.793-799, 803 (December 1967).
2.    B. W. Kernighan and L. L. Cherry, ‘‘A System for Typesetting Mathematics,’’ Comm. Assoc.
      Comp. Mach. 18, pp.151-157 (March 1975).
3.    B. W. Kernighan, M. E. Lesk, and J. F. Ossanna, ‘‘UNIX Time-Sharing System: Document
      Preparation,’’ Bell Sys. Tech. J. 57(6), pp.2115-2135 (1978).
                                                - 15 -


4.    T. A. Dolotta and J. R. Mashey, ‘‘An Introduction to the Programmer’s Workbench,’’ Proc. 2nd
      Int. Conf. on Software Engineering, pp.164-168 (October 13-15, 1976).
5.    T. A. Dolotta, R. C. Haight, and J. R. Mashey, ‘‘UNIX Time-Sharing System: The Programmer’s
      Workbench,’’ Bell Sys. Tech. J. 57(6), pp.2177-2200 (1978).
6.    H. Lycklama, ‘‘UNIX Time-Sharing System: UNIX on a Microprocessor,’’ Bell Sys. Tech. J. 57(6),
      pp.2087-2101 (1978).
7.    B. W. Kernighan and D. M. Ritchie, The C Programming Language, Prentice-Hall, Englewood
      Cliffs, New Jersey (1978).
8.    Aleph-null, ‘‘Computer Recreations,’’ Software Practice and Experience 1(2), pp.201-204 (April-
      June 1971).
9.    S. R. Bourne, ‘‘UNIX Time-Sharing System: The UNIX Shell,’’ Bell Sys. Tech. J. 57(6), pp.1971-
      1990 (1978).
10.   L. P. Deutsch and B. W. Lampson, ‘‘SDS 930 time-sharing system preliminary reference manual,’’
      Doc. 30.10.10, Project GENIE, Univ. Cal. at Berkeley (April 1965).
11.   R. J. Feiertag and E. I. Organick, ‘‘The Multics input-output system,’’ Proc. Third Symposium on
      Operating Systems Principles, pp.35-41 (October 18-20, 1971).
12.   D. G. Bobrow, J. D. Burchﬁel, D. L. Murphy, and R. S. Tomlinson, ‘‘TENEX, a Paged Time Shar-
      ing System for the PDP-10,’’ Comm. Assoc. Comp. Mach. 15(3), pp.135-143 (March 1972).
                                UNIX For Beginners — Second Edition

                                                  Brian W. Kernighan
                                                   Bell Laboratories
                                             Murray Hill, New Jersey 07974



                                                      ABSTRACT

              This paper is meant to help new users get started on the UNIX† operating system. It
          includes:
           • basics needed for day-to-day use of the system — typing commands, correcting
             typing mistakes, logging in and out, mail, inter-terminal communication, the ﬁle
             system, printing ﬁles, redirecting I/O, pipes, and the shell.
           • document preparation — a brief discussion of the major formatting programs and
             macro packages, hints on preparing documents, and capsule descriptions of some
             supporting software.
           • UNIX programming — using the editor, programming the shell, programming in C,
             other languages and tools.
           • An annotated UNIX bibliography.



October 2, 1978




_
______________
†UNIX is a Trademark of Bell Laboratories.
                               UNIX For Beginners — Second Edition

                                                Brian W. Kernighan
                                               Bell Laboratories
                                         Murray Hill, New Jersey 07974



INTRODUCTION                                                 4. Writing Programs: UNIX is an excellent system
      From the user’s point of view, the UNIX operat-           for developing programs. This section talks
ing system is easy to learn and use, and presents few           about some of the tools, but again is not a
of the usual impediments to getting the job done. It            tutorial in any of the programming languages
is hard, however, for the beginner to know where to             provided by the system.
start, and how to make the best use of the facilities        5. A UNIX Reading List. An annotated bibliogra-
available. The purpose of this introduction is to help          phy of documents that new users should be
new users get used to the main ideas of the UNIX sys-           aware of.
tem and start making effective use of it quickly.
      You should have a couple of other documents           I. GETTING STARTED
with you for easy reference as you read this one. The
most important is The UNIX Programmer’s Manual ;            Logging In
it’s often easier to tell you to read about something in         You must have a UNIX login name, which you
the manual than to repeat its contents here. The other      can get from whoever administers your system. You
useful document is A Tutorial Introduction to the           also need to know the phone number, unless your
UNIX Text Editor, which will tell you how to use the        system uses permanently connected terminals. The
editor to get text — programs, data, documents —            UNIX system is capable of dealing with a wide
into the computer.                                          variety of terminals: Terminet 300’s; Execuport, TI
      A word of warning: the UNIX system has                and similar portables; video (CRT) terminals like the
become quite popular, and there are several major           HP2640, etc.; high-priced graphics terminals like the
variants in widespread use. Of course details also          Tektronix 4014; plotting terminals like those from
change with time. So although the basic structure of        GSI and DASI; and even the venerable Teletype in its
UNIX and how to use it is common to all versions,           various forms. But note: UNIX is strongly oriented
there will certainly be a few things which are dif-         towards devices with lower case. If your terminal
ferent on your system from what is described here.          produces only upper case (e.g., model 33 Teletype,
We have tried to minimize the problem, but be aware         some video and portable terminals), life will be so
of it. In cases of doubt, this paper describes Version      difﬁcult that you should look for another terminal.
7 UNIX.                                                          Be sure to set the switches appropriately on your
     This paper has ﬁve sections:                           device. Switches that might need to be adjusted
                                                            include the speed, upper/lower case mode, full
 1. Getting Started: How to log in, how to type,            duplex, even parity, and any others that local wisdom
    what to do about mistakes in typing, how to log         advises. Establish a connection using whatever magic
    out. Some of this is dependent on which system          is needed for your terminal; this may involve dialing
    you log into (phone numbers, for example) and           a telephone call or merely ﬂipping a switch. In either
    what terminal you use, so this section must             case, UNIX should type ‘‘login:’’ at you. If it types
    necessarily be supplemented by local informa-           garbage, you may be at the wrong speed; check the
    tion.                                                   switches. If that fails, push the ‘‘break’’ or ‘‘inter-
 2. Day-to-day Use: Things you need every day to            rupt’’ key a few times, slowly. If that fails to pro-
    use the system effectively: generally useful            duce a login message, consult a guru.
    commands; the ﬁle system.                                    When you get a login: message, type your login
 3. Document Preparation: Preparing manuscripts is          name in lower case. Follow it by a RETURN; the sys-
    one of the most common uses for UNIX systems.           tem will not do anything until you type a RETURN.
    This section contains advice, but not extensive         If a password is required, you will be asked for it,
    instructions on any of the formatting tools.            and (if possible) printing will be turned off while you
                                                            type it. Don’t forget RETURN.
                                                          -2-


     The culmination of your login efforts is a                 and the system will convert each tab into the right
‘‘prompt character,’’ a single character that indicates         number of blanks for you. If your terminal does have
that the system is ready to accept commands from                computer-settable tabs, the command tabs will set the
you. The prompt character is usually a dollar sign $            stops correctly for you.
or a percent sign %. (You may also get a message
of the day just before the prompt character, or a               Mistakes in Typing
notiﬁcation that you have mail.)                                     If you make a typing mistake, and see it before
                                                                RETURN has been typed, there are two ways to
Typing Commands                                                 recover. The sharp-character # erases the last charac-
     Once you’ve seen the prompt character, you can             ter typed; in fact successive uses of # erase characters
type commands, which are requests that the system               back to the beginning of the line (but not beyond).
do something. Try typing                                        So if you type badly, you can correct as you go:
       date                                                             dd#atte##e
followed by RETURN. You should get back some-                   is the same as date.
thing like                                                           The at-sign @ erases all of the characters typed
       Mon Jan 16 14:17:10 EST 1978                             so far on the current input line, so if the line is irre-
                                                                trievably fouled up, type an @ and start the line over.
Don’t forget the RETURN after the command, or noth-
ing will happen. If you think you’re being ignored,                   What if you must enter a sharp or at-sign as part
type a RETURN; something should happen. RETURN                  of the text? If you precede either # or @ by a
won’t be mentioned again, but don’t forget it — it              backslash \, it loses its erase meaning. So to enter a
has to be there at the end of each line.                        sharp or at-sign in something, type \# or \@. The
                                                                system will always echo a newline at you after your
      Another command you might try is who, which               at-sign, even if preceded by a backslash. Don’t worry
tells you everyone who is currently logged in:                  — the at-sign has been recorded.
       who                                                           To erase a backslash, you have to type two
gives something like                                            sharps or two at-signs, as in \##. The backslash is
                                                                used extensively in UNIX to indicate that the follow-
       mb          tty01   Jan 16    09:11                      ing character is in some way special.
       ski         tty05   Jan 16    09:33
       gam         tty11   Jan 16    13:07                      Read-ahead
The time is when the user logged in; ‘‘ttyxx’’ is the                UNIX has full read-ahead, which means that you
system’s idea of what terminal the user is on.                  can type as fast as you want, whenever you want,
     If you make a mistake typing the command                   even when some command is typing at you. If you
name, and refer to a non-existent command, you will             type during output, your input characters will appear
be told. For example, if you type                               intermixed with the output characters, but they will be
                                                                stored away and interpreted in the correct order. So
       whom                                                     you can type several commands one after another
you will be told                                                without waiting for the ﬁrst to ﬁnish or even begin.

       whom: not found                                          Stopping a Program
Of course, if you inadvertently type the name of some                You can stop most programs by typing the char-
other command, it will run, with more or less mys-              acter ‘‘DEL’’ (perhaps called ‘‘delete’’ or ‘‘rubout’’
terious results.                                                on your terminal). The ‘‘interrupt’’ or ‘‘break’’ key
                                                                found on most terminals can also be used. In a few
Strange Terminal Behavior                                       programs, like the text editor, DEL stops whatever the
     Sometimes you can get into a state where your              program is doing but leaves you in that program.
terminal acts strangely. For example, each letter may           Hanging up the phone will stop most programs.
be typed twice, or the RETURN may not cause a line
feed or a return to the left margin. You can often ﬁx           Logging Out
this by logging out and logging back in. Or you can                 The easiest way to log out is to hang up the
read the description of the command stty in section I           phone. You can also type
of the manual. To get intelligent treatment of tab
                                                                        login
characters (which are much used in UNIX) if your ter-
minal doesn’t have tabs, type the command                       and let someone else use the terminal you were on.
                                                                It is usually not sufﬁcient just to turn off the terminal.
       stty – tabs
                                                                Most UNIX systems do not use a time-out mechanism,
                                                          -3-


so you’ll be there forever unless you hang up.                  on yours and vice versa. The path is slow, rather like
                                                                talking to the moon. (If you are in the middle of
Mail                                                            something, you have to get to a state where you can
    When you log in, you may sometimes get the                  type a command. Normally, whatever program you
message                                                         are running has to terminate or be terminated. If
                                                                you’re editing, you can escape temporarily from the
       You have mail.                                           editor — read the editor tutorial.)
UNIX provides a postal system so you can communi-                     A protocol is needed to keep what you type from
cate with other users of the system. To read your               getting garbled up with what Joe types. Typically it’s
mail, type the command                                          like this:
       mail                                                             Joe types write smith and waits.
                                                                        Smith types write joe and waits.
Your mail will be printed, one message at a time,
                                                                        Joe now types his message (as many lines as
most recent message ﬁrst. After each message, mail
                                                                        he likes). When he’s ready for a reply, he
waits for you to say what to do with it. The two
                                                                        signals it by typing (o), which stands for
basic responses are d, which deletes the message, and
                                                                        ‘‘over’’.
RETURN, which does not (so it will still be there the
                                                                        Now Smith types a reply, also terminated by
next time you read your mailbox). Other responses
                                                                        (o).
are described in the manual. (Earlier versions of mail
                                                                        This cycle repeats until someone gets tired; he
do not process one message at a time, but are other-
                                                                        then signals his intent to quit with (oo), for
wise similar.)
                                                                        ‘‘over and out’’.
    How do you send mail to someone else? Sup-                          To terminate the conversation, each side must
pose it is to go to ‘‘joe’’ (assuming ‘‘joe’’ is                        type a ‘‘control-d’’ character alone on a line.
someone’s login name). The easiest way is this:                         (‘‘Delete’’ also works.) When the other
       mail joe                                                         person types his ‘‘control-d’’, you will get the
       now type in the text of the letter                               message EOF on your terminal.
       on as many lines as you like ...
                                                                     If you write to someone who isn’t logged in, or
       After the last line of the letter
                                                                who doesn’t want to be disturbed, you’ll be told. If
       type the character ‘‘control– d’’,
                                                                the target is logged in but doesn’t answer after a
       that is, hold down ‘‘control’’ and type
                                                                decent interval, simply type ‘‘control-d’’.
       a letter ‘‘d’’.
And that’s it. The ‘‘control-d’’ sequence, often called         On-line Manual
‘‘EOF’’ for end-of-ﬁle, is used throughout the system                The UNIX Programmer’s Manual is typically
to mark the end of input from a terminal, so you                kept on-line. If you get stuck on something, and
might as well get used to it.                                   can’t ﬁnd an expert to assist you, you can print on
     For practice, send mail to yourself. (This isn’t           your terminal some manual section that might help.
as strange as it might sound — mail to oneself is a             This is also useful for getting the most up-to-date
handy reminder mechanism.)                                      information on a command. To print a manual sec-
    There are other ways to send mail — you can                 tion, type ‘‘man command-name’’. Thus to read up
send a previously prepared letter, and you can mail to          on the who command, type
a number of people all at once. For more details see                    man who
mail(1). (The notation mail(1) means the command
mail in section 1 of the UNIX Programmer’s Manual.)             and, of course,
                                                                        man man
Writing to other users
                                                                tells all about the man command.
     At some point, out of the blue will come a mes-
sage like                                                       Computer Aided Instruction
       Message from joe tty07...                                     Your UNIX system may have available a program
accompanied by a startling beep. It means that Joe              called learn, which provides computer aided instruc-
wants to talk to you, but unless you take explicit              tion on the ﬁle system and basic commands, the edi-
action you won’t be able to talk back. To respond,              tor, document preparation, and even C programming.
type the command                                                Try typing the command

       write joe                                                        learn

This establishes a two-way communication path.                  If learn exists on your system, it will tell you what to
Now whatever Joe types on his terminal will appear              do from there.
                                                                        -4-


II. DAY-TO-DAY USE
                                                                                     ls
Creating Files — The Editor                                                   the response will be
     If you have to type a paper or a letter or a pro-                               junk
gram, how do you get the information stored in the                                   temp
machine? Most of these tasks are done with the
UNIX ‘‘text editor’’ ed. Since ed is thoroughly docu-                         which are indeed the two ﬁles just created. The
mented in ed(1) and explained in A Tutorial Introduc-                         names are sorted into alphabetical order automati-
tion to the UNIX Text Editor, we won’t spend any                              cally, but other variations are possible. For example,
time here describing how to use it. All we want it                            the command
for right now is to make some ﬁles. (A ﬁle is just a                                 ls – t
collection of information stored in the machine, a
simplistic but adequate deﬁnition.)                                           causes the ﬁles to be listed in the order in which they
                                                                              were last changed, most recent ﬁrst. The – l option
     To create a ﬁle called junk with some text in it,                        gives a ‘‘long’’ listing:
do the following:
                                                                                      ls – l
         ed junk     (invokes the text editor)
         a           (command to ‘‘ed’’, to add text)                         will produce something like
         now type in                                                                  – rw– rw– rw– 1 bwk 41 Jul 22 2:56 junk
         whatever text you want ...                                                   – rw– rw– rw– 1 bwk 78 Jul 22 2:57 temp
         .           (signals the end of adding text)
                                                                              The date and time are of the last change to the ﬁle.
The ‘‘.’’ that signals the end of adding text must                be          The 41 and 78 are the number of characters (which
at the beginning of a line by itself. Don’t forget                it,         should agree with the numbers you got from ed).
for until it is typed, no other ed commands will                  be          bwk is the owner of the ﬁle, that is, the person who
recognized — everything you type will be treated                  as          created it. The – rw– rw– rw– tells who has permis-
text to be added.                                                             sion to read and write the ﬁle, in this case everyone.
     At this point you can do various editing opera-                                Options can be combined: ls – lt gives the same
tions on the text you typed in, such as correcting                            thing as ls – l, but sorted into time order. You can
spelling mistakes, rearranging paragraphs and the like.                       also name the ﬁles you’re interested in, and ls will
Finally, you must write the information you have                              list the information about them only. More details
typed into a ﬁle with the editor command w:                                   can be found in ls(1).
         w                                                                         The use of optional arguments that begin with a
ed will respond with the number of characters it                              minus sign, like – t and – lt, is a common convention
wrote into the ﬁle junk.                                                      for UNIX programs. In general, if a program accepts
                                                                              such optional arguments, they precede any ﬁlename
    Until the w command, nothing is stored per-                               arguments. It is also vital that you separate the vari-
manently, so if you hang up and go home the infor-                            ous arguments with spaces: ls– l is not the same as
mation is lost.† But after w the information is there                         ls – l.
permanently; you can re-access it any time by typing
         ed junk                                                              Printing Files

Type a q command to quit the editor. (If you try to                                Now that you’ve got a ﬁle of text, how do you
quit without writing, ed will print a ? to remind you.                        print it so people can look at it? There are a host of
A second q gets you out regardless.)                                          programs that do that, probably more than are needed.

     Now create a second ﬁle called temp in the                                    One simple thing is to use the editor, since print-
same manner. You should now have two ﬁles, junk                               ing is often done just before making changes anyway.
and temp.                                                                     You can say
                                                                                      ed junk
What ﬁles are out there?                                                              1,$p
     The ls (for ‘‘list’’) command lists the names (not                       ed will reply with the count of the characters in junk
contents) of any of the ﬁles that UNIX knows about.                           and then print all the lines in the ﬁle. After you learn
If you type                                                                   how to use the editor, you can be selective about the
_____________________                                                         parts you print.
† This is not strictly true — if you hang up while editing, the
                                                                                   There are times when it’s not feasible to use the
data you were working on is saved in a ﬁle called ed.hup,
which you can continue with at your next session.                             editor for printing. For example, there is a limit on
                                                                              how big a ﬁle ed can handle (several thousand lines).
                                                                              Secondly, it will only print one ﬁle at a time, and
                                                           -5-


sometimes you want to print several, one after
                                                                        cp precious temp1
another. So here are a couple of alternatives.
     First is cat, the simplest of all the printing pro-         makes a duplicate copy of precious in temp1.
grams. cat simply prints on the terminal the contents                 Finally, when you get tired of creating and mov-
of all the ﬁles named in a list. Thus                            ing ﬁles, there is a command to remove ﬁles from the
                                                                 ﬁle system, called rm.
       cat junk
                                                                        rm temp temp1
prints one ﬁle, and
                                                                 will remove both of the ﬁles named.
       cat junk temp
                                                                       You will get a warning message if one of the
prints two. The ﬁles are simply concatenated (hence              named ﬁles wasn’t there, but otherwise rm, like most
the name ‘‘cat’’) onto the terminal.                             UNIX commands, does its work silently. There is no
     pr produces formatted printouts of ﬁles. As with            prompting or chatter, and error messages are occa-
cat, pr prints all the ﬁles named in a list. The differ-         sionally curt. This terseness is sometimes disconcert-
ence is that it produces headings with date, time, page          ing to newcomers, but experienced users ﬁnd it desir-
number and ﬁle name at the top of each page, and                 able.
extra lines to skip over the fold in the paper. Thus,
                                                                 What’s in a Filename
        pr junk temp
                                                                       So far we have used ﬁlenames without ever say-
will print junk neatly, then skip to the top of a new            ing what’s a legal name, so it’s time for a couple of
page and print temp neatly.                                      rules. First, ﬁlenames are limited to 14 characters,
     pr can also produce multi-column output:                    which is enough to be descriptive. Second, although
                                                                 you can use almost any character in a ﬁlename, com-
        pr – 3 junk
                                                                 mon sense says you should stick to ones that are visi-
prints junk in 3-column format. You can use any                  ble, and that you should probably avoid characters
reasonable number in place of ‘‘3’’ and pr will do its           that might be used with other meanings. We have
best. pr has other capabilities as well; see pr(1).              already seen, for example, that in the ls command,
      It should be noted that pr is not a formatting             ls – t means to list in time order. So if you had a ﬁle
program in the sense of shufﬂing lines around and                whose name was – t, you would have a tough time
justifying margins. The true formatters are nroff and            listing it by name. Besides the minus sign, there are
troff, which we will get to in the section on docu-              other characters which have special meaning. To
ment preparation.                                                avoid pitfalls, you would do well to use only letters,
                                                                 numbers and the period until you’re familiar with the
     There are also programs that print ﬁles on a                situation.
high-speed printer. Look in your manual under opr
and lpr. Which to use depends on what equipment is                    On to some more positive suggestions. Suppose
attached to your machine.                                        you’re typing a large document like a book. Logi-
                                                                 cally this divides into many small pieces, like
Shufﬂing Files About                                             chapters and perhaps sections. Physically it must be
                                                                 divided too, for ed will not handle really big ﬁles.
     Now that you have some ﬁles in the ﬁle system               Thus you should type the document as a number of
and some experience in printing them, you can try                ﬁles. You might have a separate ﬁle for each chapter,
bigger things. For example, you can move a ﬁle from              called
one place to another (which amounts to giving it a
new name), like this:                                                   chap1
                                                                        chap2
       mv junk precious                                                 etc...
This means that what used to be ‘‘junk’’ is now                  Or, if each chapter were broken into several ﬁles, you
‘‘precious’’. If you do an ls command now, you will              might have
get
                                                                        chap1.1
       precious                                                         chap1.2
       temp                                                             chap1.3
Beware that if you move a ﬁle to another one that                       ...
already exists, the already existing contents are lost                  chap2.1
forever.                                                                chap2.2
                                                                        ...
    If you want to make a copy of a ﬁle (that is, to
have two versions of something), you can use the cp              You can now tell at a glance where a particular ﬁle
command:                                                         ﬁts into the whole.
                                                           -6-


     There are advantages to a systematic naming
                                                                        ls – l chap?.1
convention which are not obvious to the novice UNIX
user. What if you wanted to print the whole book?                lists information about the ﬁrst ﬁle of each chapter
You could say                                                    (chap1.1, chap2.1, etc.).
        pr chap1.1 chap1.2 chap1.3 ......                             Of these niceties, * is certainly the most useful,
                                                                 and you should get used to it. The others are frills,
but you would get tired pretty fast, and would prob-             but worth knowing.
ably even make mistakes. Fortunately, there is a
shortcut. You can say                                                 If you should ever have to turn off the special
                                                                 meaning of *, ?, etc., enclose the entire argument in
        pr chap*                                                 single quotes, as in
The * means ‘‘anything at all,’’ so this translates into                ls ′?′
‘‘print all ﬁles whose names begin with chap’’, listed
in alphabetical order.                                           We’ll see some more examples of this shortly.

      This shorthand notation is not a property of the           What’s in a Filename, Continued
pr command, by the way. It is system-wide, a ser-
vice of the program that interprets commands (the                      When you ﬁrst made that ﬁle called junk, how
‘‘shell,’’ sh(1)). Using that fact, you can see how to           did the system know that there wasn’t another junk
list the names of the ﬁles in the book:                          somewhere else, especially since the person in the
                                                                 next ofﬁce is also reading this tutorial? The answer
        ls chap*                                                 is that generally each user has a private directory,
produces                                                         which contains only the ﬁles that belong to him.
                                                                 When you log in, you are ‘‘in’’ your directory.
        chap1.1                                                  Unless you take special action, when you create a
        chap1.2                                                  new ﬁle, it is made in the directory that you are
        chap1.3                                                  currently in; this is most often your own directory,
        ...                                                      and thus the ﬁle is unrelated to any other ﬁle of the
The * is not limited to the last position in a ﬁlename           same name that might exist in someone else’s direc-
— it can be anywhere and can occur several times.                tory.
Thus                                                                   The set of all ﬁles is organized into a (usually
                                                                 big) tree, with your ﬁles located several branches into
        rm *junk* *temp*
                                                                 the tree. It is possible for you to ‘‘walk’’ around this
removes all ﬁles that contain junk or temp as any                tree, and to ﬁnd any ﬁle in the system, by starting at
part of their name. As a special case, * by itself               the root of the tree and walking along the proper set
matches every ﬁlename, so                                        of branches. Conversely, you can start where you are
                                                                 and walk toward the root.
        pr *
                                                                      Let’s try the latter ﬁrst. The basic tools is the
prints all your ﬁles (alphabetical order), and                   command pwd (‘‘print working directory’’), which
        rm *                                                     prints the name of the directory you are currently in.

removes all ﬁles. (You had better be very sure that’s                 Although the details will vary according to the
what you wanted to say!)                                         system you are on, if you give the command pwd, it
                                                                 will print something like
     The * is not the only pattern-matching feature
available. Suppose you want to print only chapters 1                     /usr/your-name
through 4 and 9. Then you can say                                This says that you are currently in the directory
        pr chap[12349]*                                          your-name, which is in turn in the directory /usr,
                                                                 which is in turn in the root directory called by con-
The [...] means to match any of the characters inside            vention just /. (Even if it’s not called /usr on your
the brackets. A range of consecutive letters or digits           system, you will get something analogous. Make the
can be abbreviated, so you can also do this with                 corresponding changes and read on.)
        pr chap[1– 49]*                                               If you now type
Letters can also be used within brackets: [a– z]                         ls /usr/your-name
matches any character in the range a through z.
                                                                 you should get exactly the same list of ﬁle names as
     The ? pattern matches any single character, so              you get from a plain ls: with no arguments, ls lists
        ls ?                                                     the contents of the current directory; given the name
                                                                 of a directory, it lists the contents of that directory.
lists all ﬁles which have single-character names, and
                                                            -7-


     Next, try
                                                                          ls /usr/neighbor-name
        ls /usr
                                                                  or make your own copy of one of his ﬁles by
This should print a long series of names, among
                                                                          cp /usr/your-neighbor/his-file yourfile
which is your own login name your-name. On many
systems, usr is a directory that contains the direc-                   If your neighbor doesn’t want you poking around
tories of all the normal users of the system, like you.           in his ﬁles, or vice versa, privacy can be arranged.
     The next step is to try                                      Each ﬁle and directory has read-write-execute permis-
                                                                  sions for the owner, a group, and everyone else,
        ls /
                                                                  which can be set to control access. See ls(1) and
You should get a response something like this                     chmod(1) for details. As a matter of observed fact,
(although again the details may be different):                    most users most of the time ﬁnd openness of more
                                                                  beneﬁt than privacy.
        bin
        dev                                                            As a ﬁnal experiment with pathnames, try
        etc                                                               ls /bin /usr/bin
        lib
        tmp                                                       Do some of the names look familiar? When you run
        usr                                                       a program, by typing its name after the prompt char-
                                                                  acter, the system simply looks for a ﬁle of that name.
This is a collection of the basic directories of ﬁles             It normally looks ﬁrst in your directory (where it typi-
that the system knows about; we are at the root of the            cally doesn’t ﬁnd it), then in /bin and ﬁnally in
tree.                                                             /usr/bin. There is nothing magic about commands
     Now try                                                      like cat or ls, except that they have been collected
                                                                  into a couple of places to be easy to ﬁnd and admin-
        cat /usr/your-name/junk
                                                                  ister.
(if junk is still around in your directory). The name                   What if you work regularly with someone else
        /usr/your-name/junk                                       on common information in his directory? You could
                                                                  just log in as your friend each time you want to, but
is called the pathname of the ﬁle that you normally               you can also say ‘‘I want to work on his ﬁles instead
think of as ‘‘junk’’. ‘‘Pathname’’ has an obvious                 of my own’’. This is done by changing the directory
meaning: it represents the full name of the path you              that you are currently in:
have to follow from the root through the tree of direc-
tories to get to a particular ﬁle. It is a universal rule                 cd /usr/your-friend
in the UNIX system that anywhere you can use an                   (On some systems, cd is spelled chdir.) Now when
ordinary ﬁlename, you can use a pathname.                         you use a ﬁlename in something like cat or pr, it
     Here is a picture which may make this clearer:               refers to the ﬁle in your friend’s directory. Changing
                             (root)                               directories doesn’t affect any permissions associated
                               ⁄ \                               with a ﬁle — if you couldn’t access a ﬁle from your
                             ⁄  \                                own directory, changing to another directory won’t
                            ⁄  \                                 alter that fact. Of course, if you forget what directory
                   bin etc usr dev tmp                            you’re in, type
                  ⁄ \ ⁄ \ ⁄ \ ⁄ \ ⁄ \
                             ⁄  \                                        pwd
                            ⁄  \
                       adam eve mary                              to ﬁnd out.
                       ⁄       ⁄ \    \
                              ⁄     \  junk                             It is usually convenient to arrange your own ﬁles
                          junk temp                               so that all the ﬁles related to one thing are in a direc-
                                                                  tory separate from other projects. For example, when
Notice that Mary’s junk is unrelated to Eve’s.                    you write your book, you might want to keep all the
     This isn’t too exciting if all the ﬁles of interest          text in a directory called book. So make one with
are in your own directory, but if you work with                           mkdir book
someone else or on several projects concurrently, it
becomes handy indeed. For example, your friends                   then go to it with
can print your book by saying                                             cd book
        pr /usr/your-name/chap*                                   then start typing chapters. The book is now found in
Similarly, you can ﬁnd out what ﬁles your neighbor                (presumably)
has by saying                                                             /usr/your-name/book
                                                           -8-


To remove the directory book, type                               Pipes
       rm book/*                                                      One of the novel contributions of the UNIX sys-
       rmdir book                                                tem is the idea of a pipe. A pipe is simply a way to
                                                                 connect the output of one program to the input of
The ﬁrst command removes all ﬁles from the direc-                another program, so the two run as a sequence of
tory; the second removes the empty directory.                    processes — a pipeline.
     You can go up one level in the tree of ﬁles by                   For example,
saying
                                                                         pr f g h
       cd ..
                                                                 will print the ﬁles f, g, and h, beginning each on a
‘‘..’’ is the name of the parent of whatever directory           new page. Suppose you want them run together
you are currently in. For completeness, ‘‘.’’ is an              instead. You could say
alternate name for the directory you are in.
                                                                         cat f g h >temp
Using Files instead of the Terminal                                      pr <temp
                                                                         rm temp
     Most of the commands we have seen so far pro-
duce output on the terminal; some, like the editor,              but this is more work than necessary. Clearly what
also take their input from the terminal. It is universal         we want is to take the output of cat and connect it to
in UNIX systems that the terminal can be replaced by             the input of pr. So let us use a pipe:
a ﬁle for either or both of input and output. As one
                                                                         cat f g h  pr
example,
                                                                 The vertical bar  means to take the output from cat,
       ls
                                                                 which would normally have gone to the terminal, and
makes a list of ﬁles on your terminal. But if you say            put it into pr to be neatly formatted.
       ls >filelist                                                  There are many other examples of pipes. For
                                                                 example,
a list of your ﬁles will be placed in the ﬁle filelist
(which will be created if it doesn’t already exist, or                   ls  pr – 3
overwritten if it does). The symbol > means ‘‘put the            prints a list of your ﬁles in three columns. The pro-
output on the following ﬁle, rather than on the termi-           gram wc counts the number of lines, words and char-
nal.’’ Nothing is produced on the terminal. As                   acters in its input, and as we saw earlier, who prints a
another example, you could combine several ﬁles into             list of currently-logged on people, one per line. Thus
one by capturing the output of cat in a ﬁle:
                                                                         who  wc
       cat f1 f2 f3 >temp
                                                                 tells how many people are logged on. And of course
    The symbol >> operates very much like > does,
                                                                         ls  wc
except that it means ‘‘add to the end of.’’ That is,
                                                                 counts your ﬁles.
       cat f1 f2 f3 >>temp
                                                                      Any program that reads from the terminal can
means to concatenate f1, f2 and f3 to the end of                 read from a pipe instead; any program that writes on
whatever is already in temp, instead of overwriting              the terminal can drive a pipe. You can have as many
the existing contents. As with >, if temp doesn’t                elements in a pipeline as you wish.
exist, it will be created for you.
                                                                      Many UNIX programs are written so that they
     In a similar way, the symbol < means to take the            will take their input from one or more ﬁles if ﬁle
input for a program from the following ﬁle, instead of           arguments are given; if no arguments are given they
from the terminal. Thus, you could make up a script              will read from the terminal, and thus can be used in
of commonly used editing commands and put them                   pipelines. pr is one example:
into a ﬁle called script. Then you can run the script
on a ﬁle by saying                                                       pr – 3 a b c

       ed file <script                                           prints ﬁles a, b and c in order in three columns. But
                                                                 in
As another example, you can use ed to prepare a
letter in ﬁle let, then send it to several people with                   cat a b c  pr – 3

       mail adam eve mary joe <let                               pr prints the information coming down the pipeline,
                                                                 still in three columns.
                                                            -9-


The Shell                                                         commands. (Why not? The shell, after all, is just a
     We have already mentioned once or twice the                  program, albeit a clever one.) For instance, suppose
mysterious ‘‘shell,’’ which is in fact sh(1). The shell           you want to set tabs on your terminal, and ﬁnd out
is the program that interprets what you type as com-              the date and who’s on the system every time you log
mands and arguments. It also looks after translating              in. Then you can put the three necessary commands
*, etc., into lists of ﬁlenames, and <, >, and  into             (tabs, date, who) into a ﬁle, let’s call it startup, and
changes of input and output streams.                              then run it with

     The shell has other capabilities too. For exam-                      sh startup
ple, you can run two programs with one command                    This says to run the shell with the ﬁle startup as
line by separating the commands with a semicolon;                 input. The effect is as if you had typed the contents
the shell recognizes the semicolon and breaks the line            of startup on the terminal.
into two commands. Thus
                                                                       If this is to be a regular thing, you can eliminate
        date; who                                                 the need to type sh: simply type, once only, the com-
does both commands before returning with a prompt                 mand
character.                                                               chmod +x startup
      You can also have more than one program run-                and thereafter you need only say
ning simultaneously if you wish. For example, if you
are doing something time-consuming, like the editor                      startup
script of an earlier section, and you don’t want to               to run the sequence of commands. The chmod(1)
wait around for the results before starting something             command marks the ﬁle executable; the shell recog-
else, you can say                                                 nizes this and runs it as a sequence of commands.
        ed file <script &                                              If you want startup to run automatically every
The ampersand at the end of a command line says                   time you log in, create a ﬁle in your login directory
‘‘start this command running, then take further com-              called .profile, and place in it the line startup.
mands from the terminal immediately,’’ that is, don’t             When the shell ﬁrst gains control when you log in, it
wait for it to complete. Thus the script will begin,              looks for the .profile ﬁle and does whatever com-
but you can do something else at the same time. Of                mands it ﬁnds in it. We’ll get back to the shell in the
course, to keep the output from interfering with what             section on programming.
you’re doing on the terminal, it would be better to
say
                                                                  III. DOCUMENT PREPARATION
        ed file <script >script.out &
                                                                        UNIX systems are used extensively for document
which saves the output lines in a ﬁle called                      preparation. There are two major formatting pro-
script.out.                                                       grams, that is, programs that produce a text with
     When you initiate a command with &, the sys-                 justiﬁed right margins, automatic page numbering and
tem replies with a number called the process number,              titling, automatic hyphenation, and the like. nroff is
which identiﬁes the command in case you later want                designed to produce output on terminals and line-
to stop it. If you do, you can say                                printers. troff (pronounced ‘‘tee-roff’’) instead drives
                                                                  a phototypesetter, which produces very high quality
        kill process-number                                       output on photographic paper. This paper was for-
If you forget the process number, the command ps                  matted with troff.
will tell you about everything you have running. (If
you are desperate, kill 0 will kill all your processes.)          Formatting Packages
And if you’re curious about other people, ps a will                    The basic idea of nroff and troff is that the text
tell you about all programs that are currently running.           to be formatted contains within it ‘‘formatting com-
     You can say                                                  mands’’ that indicate in detail how the formatted text
                                                                  is to look. For example, there might be commands
        (command-1; command-2; command-3) &                       that specify how long lines are, whether to use single
to start three commands in the background, or you                 or double spacing, and what running titles to use on
can start a background pipeline with                              each page.
                                                                       Because nroff and troff are relatively hard to
        command-1  command-2 &
                                                                  learn to use effectively, several ‘‘packages’’ of
     Just as you can tell the editor or some similar              canned formatting requests are available to let you
program to take its input from a ﬁle instead of from              specify paragraphs, running titles, footnotes, multi-
the terminal, you can tell the shell to read a ﬁle to get         column output, and so on, with little effort and
                                                                  without having to learn nroff and troff. These pack-
                                                            - 10 -


ages take a modest effort to learn, but the rewards for              that closely resembles the way you would speak it
using them are so great that it is time well spent.                  aloud. For example, the eqn input
     In this section, we will provide a hasty look at                        sum from i=0 to n x sub i ˜=˜ pi over 2
the ‘‘manuscript’’ package known as – ms. Format-
ting requests typically consist of a period and two                  produces the output
upper-case letters, such as .TL, which is used to                                            n
                                                                                                     π
introduce a title, or .PP to begin a new paragraph.                                         Σ xi
                                                                                            i =0
                                                                                                   = __
                                                                                                     2
        A document is typed so it looks something like
this:                                                                     The program tbl provides an analogous service
                                                                     for preparing tabular material; it does all the computa-
          .TL                                                        tions necessary to align complicated columns with
          title of document                                          elements of varying widths.
          .AU
                                                                          refer prepares bibliographic citations from a data
          author name
                                                                     base, in whatever style is deﬁned by the formatting
          .SH
                                                                     package. It looks after all the details of numbering
          section heading
                                                                     references in sequence, ﬁlling in page and volume
          .PP
                                                                     numbers, getting the author’s initials and the journal
          paragraph ...
                                                                     name right, and so on.
          .PP
          another paragraph ...                                           spell and typo detect possible spelling mistakes
          .SH                                                        in a document. spell works by comparing the words
          another section heading                                    in your document to a dictionary, printing those that
          .PP                                                        are not in the dictionary. It knows enough about
          etc.                                                       English spelling to detect plurals and the like, so it
                                                                     does a very good job. typo looks for words which
The lines that begin with a period are the formatting                are ‘‘unusual’’, and prints those. Spelling mistakes
requests. For example, .PP calls for starting a new                  tend to be more unusual, and thus show up early
paragraph. The precise meaning of .PP depends on                     when the most unusual words are printed ﬁrst.
what output device is being used (typesetter or termi-
nal, for instance), and on what publication the docu-                     grep looks through a set of ﬁles for lines that
ment will appear in. For example, – ms normally                      contain a particular text pattern (rather like the
assumes that a paragraph is preceded by a space (one                 editor’s context search does, but on a bunch of ﬁles).
line in nroff, 1⁄2 line in troff), and the ﬁrst word is              For example,
indented. These rules can be changed if you like, but                        grep ′ing$′ chap*
they are changed by changing the interpretation of
.PP, not by re-typing the document.                                  will ﬁnd all lines that end with the letters ing in the
                                                                     ﬁles chap*. (It is almost always a good practice to
    To actually produce a document in standard for-                  put single quotes around the pattern you’re searching
mat using – ms, use the command                                      for, in case it contains characters like * or $ that have
          troff – ms files ...                                       a special meaning to the shell.) grep is often useful
                                                                     for ﬁnding out in which of a set of ﬁles the
for the typesetter, and                                              misspelled words detected by spell are actually
          nroff – ms files ...                                       located.
for a terminal. The – ms argument tells troff and                         diff prints a list of the differences between two
nroff to use the manuscript package of formatting                    ﬁles, so you can compare two versions of something
requests.                                                            automatically (which certainly beats proofreading by
                                                                     hand).
     There are several similar packages; check with a
local expert to determine which ones are in common                         wc counts the words, lines and characters in a
use on your machine.                                                 set of ﬁles. tr translates characters into other charac-
                                                                     ters; for example it will convert upper to lower case
Supporting Tools                                                     and vice versa. This translates upper into lower:
     In addition to the basic formatters, there is a host                    tr A– Z a– z <input >output
of supporting programs that help with document
preparation. The list in the next few paragraphs is far                   sort sorts ﬁles in a variety of ways; cref makes
from complete, so browse through the manual and                      cross-references; ptx makes a permuted index
check with people around you for other possibilities.                (keyword-in-context listing). sed provides many of
                                                                     the editing facilities of ed, but can apply them to
     eqn and neqn let you integrate mathematics into                 arbitrarily long inputs. awk provides the ability to do
the text of a document, in an easy-to-learn language                 both pattern matching and numeric computations, and
                                                            - 11 -


to conveniently process ﬁelds within lines. These                    The Shell
programs are for more advanced users, and they are                        The pipe mechanism lets you fabricate quite
not limited to document preparation. Put them on                     complicated operations out of spare parts that already
your list of things to learn about.                                  exist. For example, the ﬁrst draft of the spell pro-
    Most of these programs are either independently                  gram was (roughly)
documented (like eqn and tbl), or are sufﬁciently
                                                                            cat ...       collect the files
simple that the description in the UNIX Programmer’s
                                                                             tr ...      put each word on a new line
Manual is adequate explanation.
                                                                             tr ...      delete punctuation, etc.
                                                                             sort        into dictionary order
Hints for Preparing Documents
                                                                             uniq        discard duplicates
     Most documents go through several versions                              comm        print words in text
(always more than you expected) before they are                                             but not in dictionary
ﬁnally ﬁnished. Accordingly, you should do whatever
possible to make the job of changing them easy.                      More pieces have been added subsequently, but this
                                                                     goes a long way for such a small effort.
     First, when you do the purely mechanical opera-
tions of typing, type so that subsequent editing will                     The editor can be made to do things that would
be easy. Start each sentence on a new line. Make                     normally require special programs on other systems.
lines short, and break lines at natural places, such as              For example, to list the ﬁrst and last lines of each of
after commas and semicolons, rather than randomly.                   a set of ﬁles, such as a book, you could laboriously
Since most people change documents by rewriting                      type
phrases and adding, deleting and rearranging sen-                           ed
tences, these precautions simplify any editing you                          e chap1.1
have to do later.                                                           1p
     Keep the individual ﬁles of a document down to                         $p
modest size, perhaps ten to ﬁfteen thousand charac-                         e chap1.2
ters. Larger ﬁles edit more slowly, and of course if                        1p
you make a dumb mistake it’s better to have clob-                           $p
bered a small ﬁle than a big one. Split into ﬁles at                        etc.
natural boundaries in the document, for the same rea-                But you can do the job much more easily. One way
sons that you start each sentence on a new line.                     is to type
     The second aspect of making change easy is to
                                                                            ls chap* >temp
not commit yourself to formatting details too early.
One of the advantages of formatting packages like                    to get the list of ﬁlenames into a ﬁle. Then edit this
– ms is that they permit you to delay decisions to the               ﬁle to make the necessary series of editing commands
last possible moment. Indeed, until a document is                    (using the global commands of ed), and write it into
printed, it is not even decided whether it will be                   script. Now the command
typeset or put on a line printer.
                                                                             ed <script
     As a rule of thumb, for all but the most trivial
jobs, you should type a document in terms of a set of                will produce the same output as the laborious hand
requests like .PP, and then deﬁne them appropriately,                typing. Alternately (and more easily), you can use
either by using one of the canned packages (the better               the fact that the shell will perform loops, repeating a
way) or by deﬁning your own nroff and troff com-                     set of commands over and over again for a set of
mands. As long as you have entered the text in some                  arguments:
systematic way, it can always be cleaned up and re-                          for i in chap*
formatted by a judicious combination of editing com-                         do
mands and request deﬁnitions.                                                     ed $i <script
                                                                             done
IV. PROGRAMMING
                                                                     This sets the shell variable i to each ﬁle name in turn,
     There will be no attempt made to teach any of                   then does the command. You can type this command
the programming languages available but a few words                  at the terminal, or put it in a ﬁle for later execution.
of advice are in order. One of the reasons why the
UNIX system is a productive programming environ-                     Programming the Shell
ment is that there is already a rich set of tools avail-
able, and facilities like pipes, I/O redirection, and the                 An option often overlooked by newcomers is that
capabilities of the shell often make it possible to do a             the shell is itself a programming language, with vari-
job by pasting together programs that already exist                  ables, control ﬂow (if-else, while, for, case), subrou-
instead of writing from scratch.                                     tines, and interrupt handling. Since there are many
                                                           - 12 -


building-block programs, you can sometimes avoid                    mand time will give you the gross run-time statistics
writing a new program merely by piecing together                    of a program, but they are not super accurate or
some of the building blocks with shell command ﬁles.                reproducible.
     We will not go into any details here; examples
and rules can be found in An Introduction to the UNIX               Other Languages
Shell, by S. R. Bourne.                                                   If you have to use Fortran, there are two possi-
                                                                    bilities. You might consider Ratfor, which gives you
Programming in C                                                    the decent control structures and free-form input that
      If you are undertaking anything substantial, C is             characterize C, yet lets you write code that is still
the only reasonable choice of programming language:                 portable to other environments. Bear in mind that
everything in the UNIX system is tuned to it. The                   UNIX Fortran tends to produce large and relatively
system itself is written in C, as are most of the pro-              slow-running programs. Furthermore, supporting
grams that run on it. It is also a easy language to use             software like adb, prof, etc., are all virtually useless
once you get started. C is introduced and fully                     with Fortran programs. There may also be a Fortran
described in The C Programming Language by B. W.                    77 compiler on your system. If so, this is a viable
Kernighan and D. M. Ritchie (Prentice-Hall, 1978).                  alternative to Ratfor, and has the non-trivial advan-
Several sections of the manual describe the system                  tage that it is compatible with C and related pro-
interfaces, that is, how you do I/O and similar func-               grams. (The Ratfor processor and C tools can be
tions. Read UNIX Programming for more compli-                       used with Fortran 77 too.)
cated things.                                                            If your application requires you to translate a
     Most input and output in C is best handled with                language into a set of actions or another language,
the standard I/O library, which provides a set of I/O               you are in effect building a compiler, though probably
functions that exist in compatible form on most                     a small one. In that case, you should be using the
machines that have C compilers. In general, it’s                    yacc compiler-compiler, which helps you develop a
wisest to conﬁne the system interactions in a program               compiler quickly. The lex lexical analyzer generator
to the facilities provided by this library.                         does the same job for the simpler languages that can
                                                                    be expressed as regular expressions. It can be used
      C programs that don’t depend too much on spe-                 by itself, or as a front end to recognize inputs for a
cial features of UNIX (such as pipes) can be moved to               yacc-based program. Both yacc and lex require some
other computers that have C compilers. The list of                  sophistication to use, but the initial effort of learning
such machines grows daily; in addition to the original              them can be repaid many times over in programs that
PDP-11, it currently includes at least Honeywell 6000,              are easy to change later on.
IBM 370, Interdata 8/32, Data General Nova and
Eclipse, HP 2100, Harris /7, VAX 11/780, SEL 86,                         Most UNIX systems also make available other
and Zilog Z80. Calls to the standard I/O library will               languages, such as Algol 68, APL, Basic, Lisp, Pas-
work on all of these machines.                                      cal, and Snobol. Whether these are useful depends
                                                                    largely on the local environment: if someone cares
      There are a number of supporting programs that                about the language and has worked on it, it may be in
go with C. lint checks C programs for potential por-                good shape. If not, the odds are strong that it will be
tability problems, and detects errors such as                       more trouble than it’s worth.
mismatched argument types and uninitialized vari-
ables.                                                              V. UNIX READING LIST
     For larger programs (anything whose source is
on more than one ﬁle) make allows you to specify                    General:
the dependencies among the source ﬁles and the pro-                 K. L. Thompson and D. M. Ritchie, The UNIX
cessing steps needed to make a new version; it then                 Programmer’s Manual, Bell Laboratories, 1978.
checks the times that the pieces were last changed                  Lists commands, system routines and interfaces, ﬁle
and does the minimal amount of recompiling to create                formats, and some of the maintenance procedures.
a consistent updated version.                                       You can’t live without this, although you will prob-
     The debugger adb is useful for digging through                 ably only need to read section 1.
the dead bodies of C programs, but is rather hard to                Documents for Use with the UNIX Time-sharing Sys-
learn to use effectively. The most effective debug-                 tem. Volume 2 of the Programmer’s Manual. This
ging tool is still careful thought, coupled with judi-              contains more extensive descriptions of major com-
ciously placed print statements.                                    mands, and tutorials and reference manuals. All of
     The C compiler provides a limited instrumenta-                 the papers listed below are in it, as are descriptions of
tion service, so you can ﬁnd out where programs                     most of the programs mentioned above.
spend their time and what parts are worth optimizing.               D. M. Ritchie and K. L. Thompson, ‘‘The UNIX
Compile the routines with the – p option; after the test            Time-sharing System,’’ CACM, July 1974. An over-
run, use prof to print an execution proﬁle. The com-
                                                          - 13 -


view of the system, for people interested in operating             S. C. Johnson, ‘‘Yacc — Yet Another Compiler-
systems. Worth reading by anyone who programs.                     Compiler,’’ Bell Laboratories CSTR 32, 1978.
Contains a remarkable number of one-sentence obser-                M. E. Lesk, ‘‘Lex — A Lexical Analyzer Genera-
vations on how to do things right.                                 tor,’’ Bell Laboratories CSTR 39, 1975.
The Bell System Technical Journal (BSTJ) Special                   S. C. Johnson, ‘‘Lint, a C Program Checker,’’ Bell
Issue on UNIX, July/August, 1978, contains many                    Laboratories CSTR 65, 1977.
papers describing recent developments, and some
retrospective material.                                            S. I. Feldman, ‘‘MAKE — A Program for Maintain-
                                                                   ing Computer Programs,’’ Bell Laboratories CSTR
The 2nd International Conference on Software                       57, 1977.
Engineering (October, 1976) contains several papers
describing the use of the Programmer’s Workbench                   J. F. Maranzano and S. R. Bourne, ‘‘A Tutorial Intro-
(PWB) version of UNIX.                                             duction to ADB,’’ Bell Laboratories CSTR 62, 1977.
                                                                   An introduction to a powerful but complex debugging
Document Preparation:                                              tool.

B. W. Kernighan, ‘‘A Tutorial Introduction to       the            S. I. Feldman and P. J. Weinberger, ‘‘A Portable For-
UNIX Text Editor’’ and ‘‘Advanced Editing            on            tran 77 Compiler,’’ Bell Laboratories, 1978. A full
UNIX,’’ Bell Laboratories, 1978. Beginners need     the            Fortran 77 for UNIX systems.
introduction; the advanced material will help you   get
the most out of the editor.
M. E. Lesk, ‘‘Typing Documents on UNIX,’’ Bell
Laboratories, 1978. Describes the – ms macro pack-
age, which isolates the novice from the vagaries of
nroff and troff, and takes care of most formatting
situations. If this speciﬁc package isn’t available on
your system, something similar probably is. The
most likely alternative is the PWB/UNIX macro pack-
age – mm; see your local guru if you use PWB/UNIX.
B. W. Kernighan and L. L. Cherry, ‘‘A System for
Typesetting Mathematics,’’ Bell Laboratories Com-
puting Science Tech. Rep. 17.
M. E. Lesk, ‘‘Tbl — A Program to Format Tables,’’
Bell Laboratories CSTR 49, 1976.
J. F. Ossanna, Jr., ‘‘NROFF/TROFF User’s Manual,’’
Bell Laboratories CSTR 54, 1976. troff is the basic
formatter used by – ms, eqn and tbl. The reference
manual is indispensable if you are going to write or
maintain these or similar programs. But start with:
B. W. Kernighan, ‘‘A TROFF Tutorial,’’ Bell
Laboratories, 1976. An attempt to unravel the intrica-
cies of troff.

Programming:
B. W. Kernighan and D. M. Ritchie, The C Program-
ming Language, Prentice-Hall, 1978. Contains a
tutorial introduction, complete discussions of all
language features, and the reference manual.
B. W. Kernighan and D. M. Ritchie, ‘‘UNIX Program-
ming,’’ Bell Laboratories, 1978. Describes how to
interface with the system from C programs: I/O calls,
signals, processes.
S. R. Bourne, ‘‘An Introduction to the UNIX Shell,’’
Bell Laboratories, 1978. An introduction and refer-
ence manual for the Version 7 shell. Mandatory
reading if you intend to make effective use of the
programming power of this shell.
                         A Tutorial Introduction to the UNIX Text Editor

                                                  Brian W. Kernighan
                                                   Bell Laboratories
                                             Murray Hill, New Jersey 07974



                                                      ABSTRACT

             Almost all text input on the UNIX† operating system is done with the text-editor ed.
          This memorandum is a tutorial guide to help beginners get started with text editing.
              Although it does not cover everything, it does discuss enough for most users’ day-
          to-day needs. This includes printing, appending, changing, deleting, moving and
          inserting entire lines of text; reading and writing ﬁles; context searching and line
          addressing; the substitute command; the global commands; and the use of special char-
          acters for advanced editing.



September 21, 1978




_
______________
†UNIX is a Trademark of Bell Laboratories.
                         A Tutorial Introduction to the UNIX Text Editor

                                                 Brian W. Kernighan
                                                Bell Laboratories
                                          Murray Hill, New Jersey 07974



Introduction                                                 Creating Text – the Append command ‘‘a’’
    Ed is a ‘‘text editor’’, that is, an interactive pro-        As your ﬁrst problem, suppose you want to create
gram for creating and modifying ‘‘text’’, using direc-       some text starting from scratch. Perhaps you are typ-
tions provided by a user at a terminal. The text is          ing the very ﬁrst draft of a paper; clearly it will have
often a document like this one, or a program or              to start somewhere, and undergo modiﬁcations later.
perhaps data for a program.                                  This section will show how to get some text in, just
    This introduction is meant to simplify learning ed.      to get started. Later we’ll talk about how to change
The recommended way to learn ed is to read this              it.
document, simultaneously using ed to follow the                   When ed is ﬁrst started, it is rather like working
examples, then to read the description in section I of       with a blank piece of paper – there is no text or
the UNIX Programmer’s Manual, all the while experi-          information present. This must be supplied by the
menting with ed. (Solicitation of advice from experi-        person using ed; it is usually done by typing in the
enced users is also useful.)                                 text, or by reading it into ed from a ﬁle. We will
    Do the exercises! They cover material not com-           start by typing in some text, and return shortly to how
pletely discussed in the actual text. An appendix            to read ﬁles.
summarizes the commands.                                         First a bit of terminology. In ed jargon, the text
                                                             being worked on is said to be ‘‘kept in a buffer.’’
Disclaimer                                                   Think of the buffer as a work space, if you like, or
    This is an introduction and a tutorial. For this         simply as the information that you are going to be
reason, no attempt is made to cover more than a part         editing. In effect the buffer is like the piece of paper,
of the facilities that ed offers (although this fraction     on which we will write things, then change some of
includes the most useful and frequently used parts).         them, and ﬁnally ﬁle the whole thing away for
When you have mastered the Tutorial, try Advanced            another day.
Editing on UNIX. Also, there is not enough space to              The user tells ed what to do to his text by typing
explain basic UNIX procedures. We will assume that           instructions called ‘‘commands.’’ Most commands
you know how to log on to UNIX, and that you have            consist of a single letter, which must be typed in
at least a vague understanding of what a ﬁle is. For         lower case. Each command is typed on a separate
more on that, read UNIX for Beginners.                       line. (Sometimes the command is preceded by infor-
     You must also know what character to type as the        mation about what line or lines of text are to be
end-of-line on your particular terminal. This charac-        affected – we will discuss these shortly.) Ed makes
ter is the RETURN key on most terminals.                     no response to most commands – there is no prompt-
Throughout, we will refer to this character, whatever        ing or typing of messages like ‘‘ready’’. (This
it is, as RETURN.                                            silence is preferred by experienced users, but some-
                                                             times a hangup for beginners.)
Getting Started                                                  The ﬁrst command is append, written as the letter
     We’ll assume that you have logged in to your                  a
system and it has just printed the prompt character,
usually either a $ or a %. The easiest way to get ed         all by itself. It means ‘‘append (or add) text lines to
is to type                                                   the buffer, as I type them in.’’ Appending is rather
                                                             like writing fresh material on a piece of paper.
      ed
      ed        (followed by a return)
                (followed by return)
                                                                 So to enter lines of text into the buffer, just type
You are now ready to go – ed is waiting for you to           an a followed by a RETURN, followed by the lines of
tell it what to do.                                          text you want, like this:
                                                            -2-


                                                                  you give a w command. (Writing out the text onto a
      a
                                                                  ﬁle from time to time as it is being created is a good
      Now is the time
      Now is the time
                                                                  idea, since if the system crashes or if you make some
      for all good men
      for all good men
                                                                  horrible mistake, you will lose all the text in the
      to come to the aid of their party.
      to come to the aid of their party.
                                                                  buffer but any text that was written onto a ﬁle is rela-
      .                                                           tively safe.)
    The only way to stop appending is to type a line
that contains only a period. The ‘‘.’’ is used to tell            Leaving ed – the Quit command ‘‘q’’
ed that you have ﬁnished appending. (Even experi-                    To terminate a session with ed, save the text
enced users forget that terminating ‘‘.’’ sometimes. If           you’re working on by writing it onto a ﬁle using the
ed seems to be ignoring you, type an extra line with              w command, and then type the command
just ‘‘.’’ on it. You may then ﬁnd you’ve added
                                                                         q
some garbage lines to your text, which you’ll have to
take out later.)                                                  which stands for quit. The system will respond with
    After the append command has been done, the                   the prompt character ($ or %). At this point your
buffer will contain the three lines                               buffer vanishes, with all its text, which is why you
                                                                  want to write it out before quitting.†
      Now is the time
      Now is the time
      for all good men
      for all good men                                            Exercise 1:
      to come to the aid of their party.
      to come to the aid of their party.
                                                                       Enter ed and create some text using
The ‘‘a’’ and ‘‘.’’ aren’t there, because they are not
                                                                         a
text.
                                                                         . . . text . . .
                                                                               text
    To add more text to what you already have, just                      .
issue another a command, and continue typing.
                                                                  Write it out using w. Then leave ed with the q com-
Error Messages – ‘‘?’’                                            mand, and print the ﬁle, to see that everything
                                                                  worked. (To print a ﬁle, say
   If at any time you make an error in the com-
mands you type to ed, it will tell you by typing                         pr ﬁlename
                                                                         pr ﬁlename

      ?                                                           or

This is about as cryptic as it can be, but with practice,                cat ﬁlename
                                                                         cat ﬁlename
you can usually ﬁgure out how you goofed.                         in response to the prompt character. Try both.)

Writing text out as a ﬁle – the Write command                     Reading text from a ﬁle – the Edit command ‘‘e’’
‘‘w’’
                                                                      A common way to get text into the buffer is to
    It’s likely that you’ll want to save your text for            read it from a ﬁle in the ﬁle system. This is what
later use. To write out the contents of the buffer onto           you do to edit text that you saved with the w com-
a ﬁle, use the write command                                      mand in a previous session. The edit command e
      w                                                           fetches the entire contents of a ﬁle into the buffer.
                                                                  So if you had saved the three lines ‘‘Now is the
followed by the ﬁlename you want to write on. This                time’’, etc., with a w command in an earlier session,
will copy the buffer’s contents onto the speciﬁed ﬁle             the ed command
(destroying any previous information on the ﬁle). To
save the text on a ﬁle named junk, for example, type                     e junk
                                                                           junk

      w junk
        junk                                                      would fetch the entire contents of the ﬁle junk into
                                                                  the buffer, and respond
Leave a space between w and the ﬁle name. Ed will
respond by printing the number of characters it wrote                    68
                                                                         68
out. In this case, ed would respond with                          which is the number of characters in junk. If any-
      68
      68                                                          thing was already in the buffer, it is deleted ﬁrst.

(Remember that blanks and the return character at the                 If you use the e command to read a ﬁle into the
end of each line are included in the character count.)            buffer, then you need not use a ﬁle name after a sub-
Writing a ﬁle just makes a copy of the text – the                 sequent w command; ed remembers the last ﬁle name
                                                                  _____________________
buffer’s contents are not disturbed, so you can go on             † Actually, ed will print ? if you try to quit without writing.
adding lines to it. This is an important point. Ed at             At that point, write if you want; if not, another q will get you
all times works on a copy of a ﬁle, not the ﬁle itself.           out regardless.
No change in the contents of a ﬁle takes place until
                                                            -3-


used in an e command, and w will write on this ﬁle.               is exactly equivalent to
Thus a good way to operate is
                                                                          ed
                                                                          ed
      ed
      ed                                                                  e ﬁlename
                                                                            ﬁlename
      e ﬁle
        ﬁle
                                                                  What does
      [editing session]
      [editing session]
      w                                                                   f ﬁlename
                                                                            ﬁlename
      q
                                                                  do?
This way, you can simply say w from time to time,
and be secure in the knowledge that if you got the ﬁle            Printing the contents of the buffer – the Print
name right at the beginning, you are writing into the             command ‘‘p’’
proper ﬁle each time.                                                  To print or list the contents of the buffer (or parts
   You can ﬁnd out at any time what ﬁle name ed is                of it) on the terminal, use the print command
remembering by typing the ﬁle command f. In this
                                                                          p
example, if you typed
                                                                  The way this is done is as follows. Specify the lines
      f
                                                                  where you want printing to begin and where you want
ed would reply                                                    it to end, separated by a comma, and followed by the
                                                                  letter p. Thus to print the ﬁrst two lines of the
      junk
      junk
                                                                  buffer, for example, (that is, lines 1 through 2) say
                                                                          1,2p
                                                                          1,2p      (starting line=1, ending line=2 p)
                                                                                    (starting line=1, ending line=2 p)
Reading text from a ﬁle – the Read command ‘‘r’’
    Sometimes you want to read a ﬁle into the buffer              Ed will respond with
without destroying anything that is already there.                        Now is the time
                                                                          Now is the time
This is done by the read command r. The command                           for all good men
                                                                          for all good men
      r junk
        junk
                                                                      Suppose you want to print all the lines in the
will read the ﬁle junk into the buffer; it adds it to the         buffer. You could use 1,3p as above if you knew
end of whatever is already in the buffer. So if you               there were exactly 3 lines in the buffer. But in gen-
do a read after an edit:                                          eral, you don’t know how many there are, so what do
                                                                  you use for the ending line number? Ed provides a
      e junk
        junk
                                                                  shorthand symbol for ‘‘line number of last line in
      r junk
        junk
                                                                  buffer’’ – the dollar sign $. Use it this way:
the buffer will contain two copies of the text (six
                                                                          1,$p
                                                                          1,$p
lines).
                                                                  This will print all the lines in the buffer (line 1 to last
      Now is the time
      Now is the time
                                                                  line.) If you want to stop the printing before it is
      for all good men
      for all good men
                                                                  ﬁnished, push the DEL or Delete key; ed will type
      to come to the aid of their party.
      to come to the aid of their party.
      Now is the time
      Now is the time                                                     ?
      for all good men
      for all good men
                                                                  and wait for the next command.
      to come to the aid of their party.
      to come to the aid of their party.
                                                                        To print the last line of the buffer, you could use
Like the w and e commands, r prints the number of
characters read in, after the reading operation is com-                   $,$p
                                                                          $,$p
plete.                                                            but ed lets you abbreviate this to
    Generally speaking, r is much less used than e.
                                                                          $p
                                                                          $p
Exercise 2:                                                       You can print any single line by typing the line
    Experiment with the e command – try reading                   number followed by a p. Thus
and printing various ﬁles. You may get an error                           1p
                                                                          1p
?name, where name is the name of a ﬁle; this means
that the ﬁle doesn’t exist, typically because you                 produces the response
spelled the ﬁle name wrong, or perhaps that you are                       Now is the time
                                                                          Now is the time
not allowed to read or write it. Try alternately read-
ing and appending to see that they work similarly.                which is the ﬁrst line of the buffer.
Verify that                                                          In fact, ed lets you abbreviate even further: you
                                                                  can print any single line by typing just the line
      ed ﬁlename
      ed ﬁlename
                                                                  number – no need to type the letter p. So if you say
                                                            -4-


                                                                      Dot is most useful when used in combinations
      $
                                                                  like this one:
ed will print the last line of the buffer.
                                                                        .+1
                                                                         +1          (or equivalently, .+1p)
                                                                                     (or equivalently, +1p)
    You can also use $ in combinations like
                                                                  This means ‘‘print the next line’’ and is a handy way
      $– 1,$p
      $– 1,$p                                                     to step slowly through a buffer. You can also say
which prints the last two lines of the buffer. This                     .– 1         (or .– 1p )
                                                                                     (or 1p
helps when you want to see how far you got in typ-
ing.                                                              which means ‘‘print the line before the current line.’’
                                                                  This enables you to go backwards if you wish.
Exercise 3:                                                       Another useful one is something like

    As before, create some text using the a command                     .– 3,.– 1p
                                                                           3, 1p
and experiment with the p command. You will ﬁnd,                  which prints the previous three lines.
for example, that you can’t print line 0 or a line
beyond the end of the buffer, and that attempts to                    Don’t forget that all of these change the value of
print a buffer in reverse order by saying                         dot. You can ﬁnd out what dot is at any time by typ-
                                                                  ing
      3,1p
      3,1p
                                                                        .=
don’t work.
                                                                  Ed will respond by printing the value of dot.
The current line – ‘‘Dot’’ or ‘‘.’’                                    Let’s summarize some things about the p com-
   Suppose your buffer still contains the six lines as            mand and dot. Essentially p can be preceded by 0, 1,
above, that you have just typed                                   or 2 line numbers. If there is no line number given,
                                                                  it prints the ‘‘current line’’, the line that dot refers to.
      1,3p
      1,3p                                                        If there is one line number given (with or without the
and ed has printed the three lines for you. Try typing            letter p), it prints that line (and dot is set there); and
just                                                              if there are two line numbers, it prints all the lines in
                                                                  that range (and sets dot to the last line printed.) If
      p           (no line numbers)
                  (no line numbers)                               two line numbers are speciﬁed the ﬁrst can’t be
This will print                                                   bigger than the second (see Exercise 2.)
                                                                      Typing a single return will cause printing of the
      to come to the aid of their party.
      to come to the aid of their party.
                                                                  next line – it’s equivalent to .+1p. Try it. Try typ-
which is the third line of the buffer. In fact it is the          ing a – ; you will ﬁnd that it’s equivalent to .– 1p.
last (most recent) line that you have done anything
with. (You just printed it!) You can repeat this p                Deleting lines: the ‘‘d’’ command
command without line numbers, and it will continue                    Suppose you want to get rid of the three extra
to print line 3.                                                  lines in the buffer. This is done by the delete com-
     The reason is that ed maintains a record of the              mand
last line that you did anything to (in this case, line 3,
                                                                        d
which you just printed) so that it can be used instead
of an explicit line number. This most recent line is              Except that d deletes lines instead of printing them,
referred to by the shorthand symbol                               its action is similar to that of p. The lines to be
                                                                  deleted are speciﬁed for d exactly as they are for p:
      .           (pronounced ‘‘dot’’).
                  (pronounced ‘‘dot’’).
                                                                        starting line, ending line d
Dot is a line number in the same way that $ is; it
means exactly ‘‘the current line’’, or loosely, ‘‘the             Thus the command
line you most recently did something to.’’ You can
                                                                        4,$d
                                                                        4,$d
use it in several ways – one possibility is to say
                                                                  deletes lines 4 through the end. There are now three
      .,,$p
         $p
                                                                  lines left, as you can check by using
This will print all the lines from (including) the
                                                                        1,$p
                                                                        1,$p
current line to the end of the buffer. In our example
these are lines 3 through 6.                                      And notice that $ now is line 3! Dot is set to the
    Some commands change the value of dot, while                  next line after the last line deleted, unless the last line
others do not. The p command sets dot to the                      deleted is the last line in the buffer. In that case, dot
number of the last line printed; the last command will            is set to $.
set both . and $ to 6.
                                                           -5-


Exercise 4:                                                      of slashes is replaced by whatever is between the
    Experiment with a, e, r, w, p and d until you are            second pair, in all the lines between starting-line and
sure that you know what they do, and until you                   ending-line. Only the ﬁrst occurrence on each line is
understand how dot, $, and line numbers are used.                changed, however. If you want to change every
                                                                 occurrence, see Exercise 5. The rules for line
    If you are adventurous, try using line numbers               numbers are the same as those for p, except that dot
with a, r and w as well. You will ﬁnd that a will                is set to the last line changed. (But there is a trap for
append lines after the line number that you specify              the unwary: if no substitution took place, dot is not
(rather than after dot); that r reads a ﬁle in after the         changed. This causes an error ? as a warning.)
line number you specify (not necessarily at the end of
the buffer); and that w will write out exactly the lines             Thus you can say
you specify, not necessarily the whole buffer. These                      1,$s/speling/spelling/
                                                                          1,$s/speling/spelling/
variations are sometimes handy. For instance you can
insert a ﬁle at the beginning of a buffer by saying              and correct the ﬁrst spelling mistake on each line in
                                                                 the text. (This is useful for people who are consistent
      0r ﬁlename
      0r ﬁlename                                                 misspellers!)
and you can enter lines at the beginning of the buffer               If no line numbers are given, the s command
by saying                                                        assumes we mean ‘‘make the substitution on line
                                                                 dot’’, so it changes things only on the current line.
      0a
      0a
                                                                 This leads to the very common sequence
      . . . text . . .
      .                                                                   s/something/something else/p
                                                                          s/something/something else/p
Notice that .w is very different from                            which makes some correction on the current line, and
                                                                 then prints it, to make sure it worked out right. If it
      .                                                          didn’t, you can try again. (Notice that there is a p on
      w
                                                                 the same line as the s command. With few excep-
                                                                 tions, p can follow any command; no other multi-
Modifying text: the Substitute command ‘‘s’’                     command lines are legal.)
    We are now ready to try one of the most impor-                   It’s also legal to say
tant of all commands – the substitute command
                                                                          s/ . . . //
                                                                          s/       //
      s
                                                                 which means ‘‘change the ﬁrst string of characters to
This is the command that is used to change individual            ‘‘nothing’’, i.e., remove them. This is useful for
words or letters within a line or group of lines. It is          deleting extra words in a line or removing extra
what you use, for example, for correcting spelling               letters from words. For instance, if you had
mistakes and typing errors.
                                                                          Nowxx is the time
                                                                          Nowxx is the time
    Suppose that by a typing error, line 1 says
                                                                 you can say
      Now is th time
      Now is th time
                                                                          s/xx//p
                                                                          s/xx//p
– the e has been left off the. You can use s to ﬁx
this up as follows:                                              to get

      1s/th/the/
      1s/th/the/                                                          Now is the time
                                                                          Now is the time

This says: ‘‘in line 1, substitute for the characters th         Notice that // (two adjacent slashes) means ‘‘no char-
the characters the.’’ To verify that it works (ed will           acters’’, not a blank. There is a difference! (See
not print the result automatically) say                          below for another meaning of //.)

      p                                                          Exercise 5:
and get                                                              Experiment with the substitute command. See
                                                                 what happens if you substitute for some word on a
      Now is the time
      Now is the time
                                                                 line with several occurrences of that word. For
which is what you wanted. Notice that dot must have              example, do this:
been set to the line where the substitution took place,
                                                                          a
since the p command printed that line. Dot is always
                                                                          the other side of the coin
                                                                          the other side of the coin
set this way with the s command.
                                                                          .
    The general way to use the substitute command is                      s/the/on the/p
                                                                          s/the/on the/p
      starting-line, ending-line s/change this/ this/
                                 s/           /to   /            You will get
Whatever string of characters is between the ﬁrst pair
                                                            -6-



         on the other side of the coin
         on the other side of the coin                                  ?
A substitute command changes only the ﬁrst                        Otherwise it prints the line it found.
occurrence of the ﬁrst string. You can change all                    You can do both the search for the desired line
occurrences by adding a g (for ‘‘global’’) to the s               and a substitution all at once, like this:
command, like this:
                                                                        /their/s/their/the/p
                                                                        /their/s/their/the/p
         s/ . . . / . . . /gp
         s/               /gp
                                                                  which will yield
Try other characters instead of slashes to delimit the
two sets of characters in the s command – anything                      to come to the aid of the party.
                                                                        to come to the aid of the party.
should work except blanks or tabs.                                There were three parts to that last command: context
       (If you get funny results using any of the charac-         search for the desired line, make the substitution,
ters                                                              print the line.
         ˆ    .    $    [       ∗   \   &                             The expression /their/ is a context search expres-
                                                                  sion. In their simplest form, all context search
read the section on ‘‘Special Characters’’.)                      expressions are like this – a string of characters sur-
                                                                  rounded by slashes. Context searches are inter-
Context searching – ‘‘/ . . . /’’                                 changeable with line numbers, so they can be used by
    With the substitute command mastered, you can                 themselves to ﬁnd and print a desired line, or as line
move on to another highly important idea of ed –                  numbers for some other command, like s. They were
context searching.                                                used both ways in the examples above.
    Suppose you have the original three line text in                  Suppose the buffer contains the three familiar
the buffer:                                                       lines
         Now is the time
         Now is the time                                                Now is the time
                                                                        Now is the time
         for all good men
         for all good men                                               for all good men
                                                                        for all good men
         to come to the aid of their party.
         to come to the aid of their party.                             to come to the aid of their party.
                                                                        to come to the aid of their party.
Suppose you want to ﬁnd the line that contains their              Then the ed line numbers
so you can change it to the. Now with only three
                                                                        /Now/+1
                                                                        /Now/+1
lines in the buffer, it’s pretty easy to keep track of
                                                                        /good/
                                                                        /good/
what line the word their is on. But if the buffer con-
                                                                        /party/– 1
                                                                        /party/–
tained several hundred lines, and you’d been making
changes, deleting and rearranging lines, and so on,               are all context search expressions, and they all refer
you would no longer really know what this line                    to the same line (line 2). To make a change in line 2,
number would be. Context searching is simply a                    you could say
method of specifying the desired line, regardless of
                                                                        /Now/+1s/good/bad/
                                                                        /Now/+1s/good/bad/
what its number is, by specifying some context on it.
    The way to say ‘‘search for a line that contains              or
this particular string of characters’’ is to type                       /good/s/good/bad/
                                                                        /good/s/good/bad/
         /string of characters we want to ﬁnd/
         /                                   /                    or
For example, the ed command                                             /party/– 1s/good/bad/
                                                                        /party/– 1s/good/bad/
         /their/
         /their/                                                  The choice is dictated only by convenience. You
is a context search which is sufﬁcient to ﬁnd the                 could print all three lines by, for instance
desired line – it will locate the next occurrence of the                /Now/,/party/p
                                                                        /Now/,/party/p
characters between slashes (‘‘their’’). It also sets dot
to that line and prints the line for veriﬁcation:                 or

         to come to the aid of their party.
         to come to the aid of their party.                             /Now/,/Now/+2p
                                                                        /Now/,/Now/+2p

‘‘Next occurrence’’ means that ed starts looking for              or by any number of similar combinations. The ﬁrst
the string at line .+1, searches to the end of the                one of these might be better if you don’t know how
buffer, then continues at line 1 and searches to line             many lines are involved. (Of course, if there were
dot. (That is, the search ‘‘wraps around’’ from $ to              only three lines in the buffer, you’d use
1.) It scans all the lines in the buffer until it either                1,$p
                                                                        1,$p
ﬁnds the desired line or gets back to dot again. If the
given string of characters can’t be found in any line,            but not if there were several hundred.)
ed types the error message
                                                           -7-


    The basic rule is: a context search expression is            is used to replace a number of lines with different
the same as a line number, so it can be used wher-               lines, which are typed in at the terminal. For exam-
ever a line number is needed.                                    ple, to change lines .+1 through $ to something else,
                                                                 type
Exercise 6:
                                                                       .+1,$c
                                                                       .+1,$c
    Experiment with context searching. Try a body                      . . . type the lines of text you want here . . .
of text with several occurrences of the same string of                 .
characters, and scan through it using the same context
search.                                                          The lines you type between the c command and the .
                                                                 will take the place of the original lines between start
    Try using context searches as line numbers for the           line and end line. This is most useful in replacing a
substitute, print and delete commands. (They can                 line or several lines which have errors in them.
also be used with r, w, and a.)
                                                                     If only one line is speciﬁed in the c command,
    Try context searching using ?text? instead of                then just that line is replaced. (You can type in as
/text/. This scans lines in the buffer in reverse order          many replacement lines as you like.) Notice the use
rather than normal. This is sometimes useful if you              of . to end the input – this works just like the . in
go too far while looking for some string of characters           the append command and must appear by itself on a
– it’s an easy way to back up.                                   new line. If no line number is given, line dot is
       (If you get funny results with any of the charac-         replaced. The value of dot is set to the last line you
ters                                                             typed in.
         ˆ    .     $   [   ∗   \   &                                ‘‘Insert’’ is similar to append – for instance

read the section on ‘‘Special Characters’’.)                           /string/i
                                                                       /string/i
                                                                       . . . type the lines to be inserted here . . .
    Ed provides a shorthand for repeating a context
search for the same string. For example, the ed line
                                                                       .
number                                                           will insert the given text before the next line that con-
                                                                 tains ‘‘string’’. The text between i and . is inserted
         /string/
         /string/
                                                                 before the speciﬁed line. If no line number is
will ﬁnd the next occurrence of string. It often hap-            speciﬁed dot is used. Dot is set to the last line
pens that this is not the desired line, so the search            inserted.
must be repeated. This can be done by typing merely
                                                                 Exercise 7:
         //
         //
                                                                     ‘‘Change’’ is rather like a combination of delete
This shorthand stands for ‘‘the most recently used               followed by insert. Experiment to verify that
context search expression.’’ It can also be used as
the ﬁrst string of the substitute command, as in                       start, end d
                                                                       i
         /string1/s//string2/
         /string1/s//string2/                                          . . . text . . .
which will ﬁnd the next occurrence of string1 and                      .
replace it by string2. This can save a lot of typing.            is almost the same as
Similarly
                                                                       start, end c
         ??
         ??                                                            . . . text . . .
means ‘‘scan backwards for the same expression.’’                      .
                                                                 These are not precisely the same if line $ gets
Change and Insert – ‘‘c’’ and ‘‘i’’                              deleted. Check this out. What is dot?
       This section discusses the change command                     Experiment with a and i, to see that they are
         c                                                       similar, but not the same. You will observe that

which is used to change or replace a group of one or                   line-number a
more lines, and the insert command                                     . . . text . . .
                                                                       .
         i
                                                                 appends after the given line, while
which is used for inserting a group of one or more
lines.                                                                 line-number i
                                                                       . . . text . . .
       ‘‘Change’’, written as
                                                                       .
         c
                                                                 inserts before it. Observe that if no line number is
                                                           -8-


given, i inserts before line dot, while a appends after
                                                                       g/xxx/.– 1s/abc/def/n
                                                                       g/xxx/ 1s/abc/def/n
line dot.
                                                                       .+2s/ghi/jkl/n
                                                                        +2s/ghi/jkl/n
Moving text around: the ‘‘m’’ command
                                                                       .– 2,.p
                                                                          2,

    The move command m is used for cutting and                   makes changes in the lines before and after each line
pasting – it lets you move a group of lines from one             that contains xxx, then prints all three lines.
place to another in the buffer. Suppose you want to                 The v command is the same as g, except that the
put the ﬁrst three lines of the buffer at the end                commands are executed on every line that does not
instead. You could do it by saying:                              match the string following v:
      1,3w temp
      1,3w temp                                                        v/ /d
                                                                       v/ /d
      $r temp
      $r temp
                                                                 deletes every line that does not contain a blank.
      1,3d
      1,3d
(Do you see why?) but you can do it a lot easier                 Special Characters
with the m command:                                                  You may have noticed that things just don’t work
      1,3m$
      1,3m$                                                      right when you used some characters like ., ∗, $, and
                                                                 others in context searches and the substitute com-
The general case is                                              mand. The reason is rather complex, although the
      start line, end line m after this line                     cure is simple. Basically, ed treats these characters as
                                                                 special, with special meanings. For instance, in a
Notice that there is a third line to be speciﬁed – the           context search or the ﬁrst string of the substitute com-
place where the moved stuff gets put. Of course the              mand only, . means ‘‘any character,’’ not a period, so
lines to be moved can be speciﬁed by context
searches; if you had                                                   /x.y/
                                                                       /x y/

      First paragraph
      First paragraph                                            means ‘‘a line with an x, any character, and a y,’’
      ...                                                        not just ‘‘a line with an x, a period, and a y.’’ A
      end of ﬁrst paragraph.
      end of ﬁrst paragraph.                                     complete list of the special characters that can cause
      Second paragraph
      Second paragraph                                           trouble is the following:
      ...                                                              ˆ    .      $    [   ∗   \
      end of second paragraph.
      end of second paragraph.
                                                                 Warning: The backslash character \ is special to ed.
you could reverse the two paragraphs like this:                  For safety’s sake, avoid it where possible. If you
      /Second/,/end of second/m/First/– 1
      /Second/,/end of second/m/First/–                          have to use one of the special characters in a substi-
                                                                 tute command, you can turn off its magic meaning
Notice the – 1: the moved text goes after the line               temporarily by preceding it with the backslash. Thus
mentioned. Dot gets set to the last line moved.
                                                                       s/\\\.\∗/backslash dot star/
                                                                       s/\\\ \∗/backslash dot star/
The global commands ‘‘g’’ and ‘‘v’’                              will change \.∗ into ‘‘backslash dot star’’.
    The global command g is used to execute one or                   Here is a hurried synopsis of the other special
more ed commands on all those lines in the buffer                characters. First, the circumﬂex ˆ signiﬁes the begin-
that match some speciﬁed string. For example                     ning of a line. Thus
      g/peling/p
      g/peling/p                                                       /ˆstring/
                                                                       /ˆstring/
prints all lines that contain peling. More usefully,             ﬁnds string only if it is at the beginning of a line: it
      g/peling/s//pelling/gp
      g/peling/s//pelling/gp                                     will ﬁnd

makes the substitution everywhere on the line, then                    string
                                                                       string
prints each corrected line. Compare this to                      but not
      1,$s/peling/pelling/gp
      1,$s/peling/pelling/gp                                           the string. ..
                                                                       the string...
which only prints the last line substituted. Another             The dollar-sign $ is just the opposite of the
subtle difference is that the g command does not give            circumﬂex; it means the end of a line:
a ? if peling is not found where the s command will.
                                                                       /string$/
                                                                       /string$/
     There may be several commands (including a, c,
i, r, w, but not g); in that case, every line except the         will only ﬁnd an occurrence of string that is at the
last must end with a backslash \:                                end of some line. This implies, of course, that
                                                                       /ˆstring$/
                                                                       /ˆstring$/
                                                          -9-


will ﬁnd only a line that contains just string, and                You don’t have to match the whole line, of
                                                                course: if the buffer contains
      /ˆ.$/
      /ˆ $/
                                                                      the end of the world
                                                                      the end of the world
ﬁnds a line containing exactly one character.
    The character ., as we mentioned above, matches             you could type
anything;                                                             /world/s//& is at hand/
                                                                      /world/s//& is at hand/
      / x. y /
      /x y/                                                     to produce
matches any of                                                        the end of the world is at hand
                                                                      the end of the world is at hand
      x+y
      x+y                                                       Observe this expression carefully, for it illustrates
      x– y
      x–                                                        how to take advantage of ed to save typing. The
      xy                                                        string /world/ found the desired line; the shorthand //
      x. y                                                      found the same word in the line; and the & saves you
This is useful in conjunction with ∗, which is a                from typing it again.
repetition character; a∗ is a shorthand for ‘‘any                   The & is a special character only within the
number of a’s,’’ so .∗ matches any number of any-               replacement text of a substitute command, and has no
things. This is used like this:                                 special meaning elsewhere. You can turn off the spe-
                                                                cial meaning of & by preceding it with a \:
      s/.∗/stuff/
      s/ ∗/stuff/
                                                                      s/ampersand/\&/
                                                                      s/ampersand/\&/
which changes an entire line, or
                                                                will convert the word ‘‘ampersand’’ into the literal
      s/.∗,//
      s/ ∗,//
                                                                symbol & in the current line.
which deletes all characters in the line up to and
including the last comma. (Since .∗ ﬁnds the longest
possible match, this goes up to the last comma.)
   [ is used with ] to form ‘‘character classes’’; for          Summary of Commands and Line Numbers
example,                                                            The general form of ed commands is the com-
                                                                mand name, perhaps preceded by one or two line
      /[0123456789]/
      /[0123456789]/
                                                                numbers, and, in the case of e, r, and w, followed by
matches any single digit – any one of the characters            a ﬁle name. Only one command is allowed per line,
inside the braces will cause a match. This can be               but a p command may follow any other command
abbreviated to [0– 9].                                          (except for e, r, w and q).
    Finally, the & is another shorthand character – it          a: Append, that is, add lines to the buffer (at line
is used only on the right-hand part of a substitute             dot, unless a different line is speciﬁed). Appending
command where it means ‘‘whatever was matched on                continues until . is typed on a new line. Dot is set to
the left-hand side’’. It is used to save typing. Sup-           the last line appended.
pose the current line contained                                 c: Change the speciﬁed lines to the new text which
      Now is the time
      Now is the time                                           follows. The new lines are terminated by a ., as with
                                                                a. If no lines are speciﬁed, replace line dot. Dot is
and you wanted to put parentheses around it. You                set to last line changed.
could just retype the line, but this is tedious. Or you
could say                                                       d: Delete the lines speciﬁed. If none are speciﬁed,
                                                                delete line dot. Dot is set to the ﬁrst undeleted line,
      s/ˆ/(/
      s/ˆ/(/                                                    unless $ is deleted, in which case dot is set to $.
      s/$/)/
      s/$/)/
                                                                e: Edit new ﬁle. Any previous contents of the buffer
using your knowledge of ˆ and $. But the easiest                are thrown away, so issue a w beforehand.
way uses the &:                                                 f: Print remembered ﬁlename. If a name follows f
      s/.∗/(&)/
      s/ ∗/(&)/                                                 the remembered name will be set to it.

This says ‘‘match the whole line, and replace it by             g: The command
itself surrounded by parentheses.’’ The & can be                      g/---/commands
                                                                      g/---/commands
used several times in a line; consider using
                                                                will execute the commands on those lines that contain
      s/.∗/&? &!!/
      s/ ∗/&? &!!/                                              ---, which can be any context search expression.
to produce                                                      i: Insert lines before speciﬁed line (or dot) until a . is
                                                                typed on a new line. Dot is set to last line inserted.
      Now is the time? Now is the time!!
      Now is the time? Now is the time!!
                                                           - 10 -


m: Move lines speciﬁed to after the line named after
m. Dot is set to the last line moved.
p: Print speciﬁed lines. If none speciﬁed, print line
dot. A single line number is equivalent to line-
number p. A single return prints .+1, the next line.
q: Quit ed. Wipes out all text in buffer if you give
it twice in a row without ﬁrst giving a w command.
r: Read a ﬁle into buffer (at end unless speciﬁed
elsewhere.) Dot set to last line read.
s: The command
      s/string1/string2/
      s/string1/string2/
substitutes the characters string1 into string2 in the
speciﬁed lines. If no lines are speciﬁed, make the
substitution in line dot. Dot is set to last line in
which a substitution took place, which means that if
no substitution took place, dot is not changed. s
changes only the ﬁrst occurrence of string1 on a line;
to change all of them, type a g after the ﬁnal slash.
v: The command
      v/---/commands
      v/---/commands
executes commands on those lines that do not con-
tain ---.
w: Write out buffer onto a ﬁle. Dot is not changed.
.=: Print value of dot. (= by itself prints the value of
$.)
!: The line
      !command-line
      !command-line
causes command-line to be executed as a UNIX com-
mand.
/-----/: Context search. Search for next line which
contains this string of characters. Print it. Dot is set
to the line where string was found. Search starts at
.+1, wraps around from $ to 1, and continues to dot,
if necessary.
?-----?: Context search in reverse direction. Start
search at .– 1, scan to 1, wrap around to $.
                                         Advanced Editing on UNIX

                                                  Brian W. Kernighan
                                                   Bell Laboratories
                                             Murray Hill, New Jersey 07974



                                                      ABSTRACT

                This paper is meant to help secretaries, typists and programmers to make effec-
          tive use of the UNIX† facilities for preparing and editing text. It provides explanations
          and examples of
          •      special characters, line addressing and global commands in the editor ed;
          •      commands for ‘‘cut and paste’’ operations on ﬁles and parts of ﬁles, including
                 the mv, cp, cat and rm commands, and the r, w, m and t commands of the edi-
                 tor;
          •      editing scripts and editor-based programs like grep and sed.
               Although the treatment is aimed at non-programmers, new users with any back-
          ground should ﬁnd helpful hints on how to get their jobs done more easily.



August 4, 1978




_
______________
†UNIX is a Trademark of Bell Laboratories.
                                         Advanced Editing on UNIX

                                                  Brian W. Kernighan
                                                   Bell Laboratories
                                             Murray Hill, New Jersey 07974



1. INTRODUCTION                                               The List command ‘l’
       Although UNIX† provides remarkably effective                  ed provides two commands for printing the
tools for text editing, that by itself is no guarantee        contents of the lines you’re editing. Most people are
that everyone will automatically make the most effec-         familiar with p, in combinations like
tive use of them. In particular, people who are not
                                                                    1,$p
computer specialists — typists, secretaries, casual
users — often use the system less effectively than            to print all the lines you’re editing, or
they might.
                                                                    s/abc/def/p
       This document is intended as a sequel to A
Tutorial Introduction to the UNIX Text Editor [1],            to change ‘abc’ to ‘def’ on the current line. Less
providing explanations and examples of how to edit            familiar is the list command l (the letter ‘l ’), which
with less effort. (You should also be familiar with           gives slightly more information than p. In particular,
the material in UNIX For Beginners [2].) Further              l makes visible characters that are normally invisible,
information on all commands discussed here can be             such as tabs and backspaces. If you list a line that
found in The UNIX Programmer’s Manual [3].                    contains some of these, l will print each tab as − and
                                                                                                                >
                                                              each backspace as −. This makes it much easier to
                                                                                   <
       Examples are based on observations of users            correct the sort of typing mistake that inserts extra
and the difﬁculties they encounter. Topics covered            spaces adjacent to tabs, or inserts a backspace fol-
include special characters in searches and substitute         lowed by a space.
commands, line addressing, the global commands, and
line moving and copying. There are also brief discus-                 The l command also ‘folds’ long lines for
sions of effective use of related tools, like those for       printing — any line that exceeds 72 characters is
ﬁle manipulation, and those based on ed, like grep            printed on multiple lines; each printed line except the
and sed.                                                      last is terminated by a backslash \ so you can tell it
                                                                                                 \,
                                                              was folded. This is useful for printing long lines on
       A word of caution. There is only one way to            short terminals.
learn to use something, and that is to use it. Reading
a description is no substitute for trying something. A               Occasionally the l command will print in a line
paper like this one should give you ideas about what          a string of numbers preceded by a backslash, such as
to try, but until you actually try something, you will        \
                                                              \07 or \\16. These combinations are used to make
not learn it.                                                 visible characters that normally don’t print, like form
                                                              feed or vertical tab or bell. Each such combination is
2. SPECIAL CHARACTERS                                         a single character. When you see such characters, be
                                                              wary — they may have surprising meanings when
      The editor ed is the primary interface to the           printed on some terminals. Often their presence
system for many people, so it is worthwhile to know           means that your ﬁnger slipped while you were typing;
how to get the most out of ed for the least effort.           you almost never want them.
       The next few sections will discuss shortcuts
and labor-saving devices. Not all of these will be            The Substitute Command ‘s’
instantly useful to any one person, of course, but a                  Most of the next few sections will be taken up
few will be, and the others should give you ideas to          with a discussion of the substitute command s. Since
store away for future use. And as always, until you           this is the command for changing the contents of indi-
try these things, they will remain theoretical                vidual lines, it probably has the most complexity of
knowledge, not something you have conﬁdence in.               any ed command, and the most potential for effective
__________________                                            use.
†UNIX is a Trademark of Bell Laboratories.
                                                                    As the simplest place to begin, recall the
                                                              meaning of a trailing g after a substitute command.
                                                             -2-


With
                                                                         /x.y/
       s/this/that/
                                                                   ﬁnds any line where ‘x’ and ‘y’ occur separated by a
and                                                                single character, as in
       s/this/that/g                                                     x+y
                                                                         x– y
the ﬁrst one replaces the ﬁrst ‘this’ on the line with
                                                                         x y
‘that’. If there is more than one ‘this’ on the line, the
                                                                         x. y
second form with the trailing g changes all of them.
      Either form of the s command can be followed                 and so on. (We will use to stand for a space when-
by p or l to ‘print’ or ‘list’ (as described in the previ-         ever we need to make it visible.)
ous section) the contents of the line:                                   Since ‘.’ matches a single character, that gives
                                                                   you a way to deal with funny characters printed by l.
       s/this/that/p
                                                                   Suppose you have a line that, when printed with the l
       s/this/that/l
                                                                   command, appears as
       s/this/that/gp
       s/this/that/gl                                                     ....    th\
                                                                                    \07is   ....
are all legal, and mean slightly different things.                 and you want to get rid of the \ (which represents
                                                                                                    \07
Make sure you know what the differences are.                       the bell character, by the way).
        Of course, any s command can be preceded by                       The most obvious solution is to try
one or two ‘line numbers’ to specify that the substitu-
                                                                         s/\
                                                                           \07//
tion is to take place on a group of lines. Thus
                                                                   but this will fail. (Try it.) The brute force solution,
       1,$s/mispell/misspell/
                                                                   which most people would now take, is to re-type the
changes the ﬁrst occurrence of ‘mispell’ to ‘misspell’             entire line. This is guaranteed, and is actually quite a
on every line of the ﬁle. But                                      reasonable tactic if the line in question isn’t too big,
                                                                   but for a very long line, re-typing is a bore. This is
       1,$s/mispell/misspell/g
                                                                   where the metacharacter ‘.’ comes in handy. Since
changes every occurrence in every line (and this is                ‘\
                                                                    \07’ really represents a single character, if we say
more likely to be what you wanted in this particular
                                                                         s/th.is/this/
case).
       You should also notice that if you add a p or l             the job is done. The ‘.’ matches the mysterious char-
to the end of any of these substitute commands, only               acter between the ‘h’ and the ‘i’, whatever it is.
the last line that got changed will be printed, not all                   Bear in mind that since ‘.’ matches any single
the lines. We will talk later about how to print all               character, the command
the lines that were modiﬁed.
                                                                         s/./,/
The Undo Command ‘u’                                               converts the ﬁrst character on a line into a ‘,’, which
       Occasionally you will make a substitution in a              very often is not what you intended.
line, only to realize too late that it was a ghastly mis-                 As is true of many characters in ed, the ‘.’ has
take. The ‘undo’ command u lets you ‘undo’ the last                several meanings, depending on its context. This line
substitution: the last line that was substituted can be            shows all three:
restored to its previous state by typing the command
                                                                        .s/././
       u
                                                                   The ﬁrst ‘.’ is a line number, the number of the line
                                                                   we are editing, which is called ‘line dot’. (We will
The Metacharacter ‘.’                                              discuss line dot more in Section 3.) The second ‘.’ is
        As you have undoubtedly noticed when you                   a metacharacter that matches any single character on
use ed, certain characters have unexpected meanings                that line. The third ‘.’ is the only one that really is
when they occur in the left side of a substitute com-              an honest literal period. On the right side of a substi-
mand, or in a search for a particular line. In the next            tution, ‘.’ is not special. If you apply this command
several sections, we will talk about these special char-           to the line
acters, which are often called ‘metacharacters’.                         Now is the time.
       The ﬁrst one is the period ‘.’. On the left side            the result will be
of a substitute command, or in a search with ‘/.../’, ‘.’
stands for any single character. Thus the search                         .ow is the time.
                                                                   which is probably not what you intended.
                                                             -3-


The Backslash ‘\
               \’                                                         As an exercise, before reading further, ﬁnd two
      Since a period means ‘any character’, the ques-              substitute commands each of which will convert the
tion naturally arises of what to do when you really                line
want a period. For example, how do you convert the                          \ \.\
                                                                            \x\ \y
line
                                                                   into the line
       Now is the time.
                                                                            \ \y
                                                                            \x\
into
                                                                         Here are several solutions; verify that each
       Now is the time?
                                                                   works as advertised.
The backslash ‘\ does the job. A backslash turns off
                \’
                                                                            s/\ \\.//
                                                                              \\ \
any special meaning that the next character might
                                                                            s/x../x/
have; in particular, ‘\.’ converts the ‘.’ from a ‘match
                      \
                                                                            s/..y/y/
anything’ into a period, so you can use it to replace
the period in                                                             A couple of miscellaneous notes about
       Now is the time.                                            backslashes and special characters. First, you can use
                                                                   any character to delimit the pieces of an s command:
like this:                                                         there is nothing sacred about slashes. (But you must
       s/\./?/
         \                                                         use slashes for context searching.) For instance, in a
                                                                   line that contains a lot of slashes already, like
The pair of characters ‘\.’ is considered by ed to be a
                        \
single real period.                                                         //exec //sys.fort.go // etc...
       The backslash can also be used when searching               you could use a colon as the delimiter — to delete all
for lines that contain a special character. Suppose                the slashes, type
you are looking for a line that contains
                                                                            s:/::g
       .PP
                                                                           Second, if # and @ are your character erase
The search                                                         and line kill characters, you have to type \ and \
                                                                                                              \#     \@;
       /.PP/                                                       this is true whether you’re talking to ed or any other
                                                                   program.
isn’t adequate, for it will ﬁnd a line like
                                                                          When you are adding text with a or i or c,
       THE APPLICATION OF ...                                      backslash is not special, and you should only put in
because the ‘.’ matches the letter ‘A’. But if you say             one backslash for each one you really want.

       /\.PP/
        \                                                          The Dollar Sign ‘$’
you will ﬁnd only lines that contain ‘.PP’.                              The next metacharacter, the ‘$’, stands for ‘the
       The backslash can also be used to turn off spe-             end of the line’. As its most obvious use, suppose
cial meanings for characters other than ‘.’. For exam-             you have the line
ple, consider ﬁnding a line that contains a backslash.                      Now is the
The search
                                                                   and you wish to add the word ‘time’ to the end. Use
       /\
        \/                                                         the $ like this:
won’t work, because the ‘\ isn’t a literal ‘\ but
                           \’                \’,                            s/$/ time/
instead means that the second ‘/’ no longer delimits
the search. But by preceding a backslash with                      to get
another one, you can search for a literal backslash.                        Now is the time
Thus
                                                                   Notice that a space is needed before ‘time’ in the sub-
       /\ \/
        \\                                                         stitute command, or you will get
does work. Similarly, you can search for a forward                          Now is thetime
slash ‘/’ with
                                                                          As another example, replace the second comma
       /\
        \//
                                                                   in the following line with a period without altering
The backslash turns off the meaning of the immedi-                 the ﬁrst:
ately following ‘/’ so that it doesn’t terminate the /.../
                                                                            Now is the time, for all good men,
construction prematurely.
                                                                   The command needed is
                                                            -4-


                                                                  indeterminate number of spaces between the x and the
       s/,$/./
                                                                  y. Suppose the job is to replace all the spaces
The $ sign here provides context to make speciﬁc                  between x and y by a single space. The line is too
which comma we mean. Without it, of course, the s                 long to retype, and there are too many spaces to
command would operate on the ﬁrst comma to pro-                   count. What now?
duce                                                                     This is where the metacharacter ‘∗’ comes in
       Now is the time. for all good men,                         handy. A character followed by a star stands for as
                                                                  many consecutive occurrences of that character as
       As another example, to convert                             possible. To refer to all the spaces at once, say
       Now is the time.                                                  s/x ∗y/x y/
into                                                              The construction ‘ ∗’ means ‘as many spaces as pos-
                                                                  sible’. Thus ‘x ∗y’ means ‘an x, as many spaces as
       Now is the time?
                                                                  possible, then a y’.
as we did earlier, we can use                                            The star can be used with any character, not
       s/.$/?/                                                    just space. If the original example was instead
                                                                         text x– – – – – – – – y text
      Like ‘.’, the ‘$’ has multiple meanings depend-
ing on context. In the line                                       then all ‘– ’ signs can be replaced by a single space
                                                                  with the command
       $s/$/$/
                                                                         s/x– ∗y/x y/
the ﬁrst ‘$’ refers to the last line of the ﬁle, the
second refers to the end of that line, and the third is a                Finally, suppose that the line was
literal dollar sign, to be added to that line.
                                                                         text x.................. y text
The Circumﬂex ‘ˆ’                                                 Can you see what trap lies in wait for the unwary? If
       The circumﬂex (or hat or caret) ‘ˆ’ stands for             you blindly type
the beginning of the line. For example, suppose you
                                                                         s/x.∗y/x y/
are looking for a line that begins with ‘the’. If you
simply say                                                        what will happen? The answer, naturally, is that it
                                                                  depends. If there are no other x’s or y’s on the line,
       /the/
                                                                  then everything works, but it’s blind luck, not good
you will in all likelihood ﬁnd several lines that con-            management. Remember that ‘.’ matches any single
tain ‘the’ in the middle before arriving at the one you           character? Then ‘.∗’ matches as many single charac-
want. But with                                                    ters as possible, and unless you’re careful, it can eat
                                                                  up a lot more of the line than you expected. If the
       /ˆthe/
                                                                  line was, for example, like this:
you narrow the context, and thus arrive at the desired
                                                                         text x text     x................ y   text y text
one more easily.
       The other use of ‘ˆ’ is of course to enable you            then saying
to insert something at the beginning of a line:                          s/x.∗y/x y/
       s/ˆ/ /                                                     will take everything from the ﬁrst ‘x’ to the last ‘y’,
places a space at the beginning of the current line.              which, in this example, is undoubtedly more than you
                                                                  wanted.
        Metacharacters can be combined. To search for
a line that contains only the characters                                 The solution, of course, is to turn off the spe-
                                                                  cial meaning of ‘.’ with ‘\.’:
                                                                                            \
       .PP
                                                                         s/x\.∗y/x y/
                                                                            \
you can use the command
                                                                  Now everything works, for ‘\.∗’ means ‘as many
                                                                                             \
       /ˆ\.PP$/
         \                                                        periods as possible’.
                                                                        There are times when the pattern ‘.∗’ is exactly
The Star ‘∗’                                                      what you want. For example, to change
       Suppose you have a line that looks like this:                     Now is the time for all good men ....
       text x             y text                                  into
where text stands for lots of text, and there are some
                                                            -5-



      Now is the time.                                                  1,$s/ˆ1∗//
                                                                        1,$s/ˆ2∗//
use ‘.∗’ to eat up everything after the ‘for’:
                                                                        1,$s/ˆ3∗//
      s/ for.∗/./
                                                                  and so on, but this is clearly going to take forever if
       There are a couple of additional pitfalls associ-          the numbers are at all long. Unless you want to
ated with ‘∗’ that you should be aware of. Most not-              repeat the commands over and over until ﬁnally all
able is the fact that ‘as many as possible’ means zero            numbers are gone, you must get all the digits on one
or more. The fact that zero is a legitimate possibility           pass. This is the purpose of the brackets [ and ].
is sometimes rather surprising. For example, if our                      The construction
line contained
                                                                        [0123456789]
      text xy text x              y text
                                                                  matches any single digit — the whole thing is called
and we said                                                       a ‘character class’. With a character class, the job is
                                                                  easy. The pattern ‘[0123456789]∗’ matches zero or
      s/x ∗y/x y/
                                                                  more digits (an entire number), so
the ﬁrst ‘xy’ matches this pattern, for it consists of an
                                                                        1,$s/ˆ[0123456789]∗//
‘x’, zero spaces, and a ‘y’. The result is that the sub-
stitute acts on the ﬁrst ‘xy’, and does not touch the             deletes all digits from the beginning of all lines.
later one that actually contains some intervening                        Any characters can appear within a character
spaces.                                                           class, and just to confuse the issue there are essen-
       The way around this, if it matters, is to specify          tially no special characters inside the brackets; even
a pattern like                                                    the backslash doesn’t have a special meaning. To
                                                                  search for special characters, for example, you can
      /x   ∗y/
                                                                  say
which says ‘an x, a space, then as many more spaces
                                                                        /[.\
                                                                           \$ˆ[]/
as possible, then a y’, in other words, one or more
spaces.                                                           Within [...], the ‘[’ is not special. To get a ‘]’ into a
       The other startling behavior of ‘∗’ is again               character class, make it the ﬁrst character.
related to the fact that zero is a legitimate number of                  It’s a nuisance to have to spell out the digits,
occurrences of something followed by a star. The                  so you can abbreviate them as [0– 9]; similarly, [a– z]
command                                                           stands for the lower case letters, and [A– Z] for upper
                                                                  case.
      s/x∗/y/g
                                                                         As a ﬁnal frill on character classes, you can
when applied to the line                                          specify a class that means ‘none of the following
      abcdef                                                      characters’. This is done by beginning the class with
                                                                  a ‘ˆ’:
produces
                                                                        [ˆ0– 9]
      yaybycydyeyfy
                                                                  stands for ‘any character except a digit’. Thus you
which is almost certainly not what was intended. The              might ﬁnd the ﬁrst line that doesn’t begin with a tab
reason for this behavior is that zero is a legal number           or space by a search like
of matches, and there are no x’s at the beginning of
the line (so that gets converted into a ‘y’), nor                       /ˆ[ˆ(space)(tab)]/
between the ‘a’ and the ‘b’ (so that gets converted
into a ‘y’), nor ... and so on. Make sure you really                     Within a character class, the circumﬂex has a
want zero matches; if not, in this case write                     special meaning only if it occurs at the beginning.
                                                                  Just to convince yourself, verify that
      s/xx∗/y/g
                                                                        /ˆ[ˆˆ]/
‘xx∗’ is one or more x’s.
                                                                  ﬁnds a line that doesn’t begin with a circumﬂex.
The Brackets ‘[ ]’
                                                                  The Ampersand ‘&’
       Suppose that you want to delete any numbers
that appear at the beginning of all lines of a ﬁle. You                  The ampersand ‘&’ is used primarily to save
might ﬁrst think of trying a series of commands like              typing. Suppose you have the line
                                                                        Now is the time
                                                                  and you want to make it
                                                            -6-


                                                                  ‘\ at the end of a line would make the newline there
                                                                   \’
      Now is the best time
                                                                  no longer special.
Of course you can always say                                              You can in fact make a single line into several
      s/the/the best/                                             lines with this same mechanism. As a large example,
                                                                  consider underlining the word ‘very’ in a long line by
but it seems silly to have to repeat the ‘the’. The ‘&’           splitting ‘very’ onto a separate line, and preceding it
is used to eliminate the repetition. On the right side            by the roff or nroff formatting command ‘.ul’.
of a substitute, the ampersand means ‘whatever was
just matched’, so you can say                                           text a very big text

      s/the/& best/                                               The command

and the ‘&’ will stand for ‘the’. Of course this isn’t                  s/ very /\
                                                                                 \
much of a saving if the thing matched is just ‘the’,                    .ul\
                                                                           \
but if it is something truly long or awful, or if it is                 very\\
something like ‘.∗’ which matches a lot of text, you                    /
can save some tedious typing. There is also much                  converts the line into four shorter lines, preceding the
less chance of making a typing error in the replace-              word ‘very’ by the line ‘.ul’, and eliminating the
ment text. For example, to parenthesize a line,                   spaces around the ‘very’, all at the same time.
regardless of its length,
                                                                         When a newline is substituted in, dot is left
      s/.∗/(&)/                                                   pointing at the last line created.

       The ampersand can occur more than once on
the right side:                                                   Joining Lines
                                                                        Lines may also be joined together, but this is
      s/the/& best and & worst/
                                                                  done with the j command instead of s. Given the
makes                                                             lines
      Now is the best and the worst time                                Now is
                                                                         the time
and
                                                                  and supposing that dot is set to the ﬁrst of them, then
      s/.∗/&? &!!/
                                                                  the command
converts the original line into
                                                                        j
      Now is the time? Now is the time!!
                                                                  joins them together. No blanks are added, which is
       To get a literal ampersand, naturally the                  why we carefully showed a blank at the beginning of
backslash is used to turn off the special meaning:                the second line.
                                                                        All by itself, a j command joins line dot to line
      s/ampersand/\
                  \&/
                                                                  dot+1, but any contiguous set of lines can be joined.
converts the word into the symbol. Notice that ‘&’ is             Just specify the starting and ending line numbers.
not special on the left side of a substitute, only on the         For example,
right side.
                                                                        1,$jp
Substituting Newlines                                             joins all the lines into one big one and prints it.
       ed provides a facility for splitting a single line         (More on line numbers in Section 3.)
into two or more shorter lines by ‘substituting in a
newline’. As the simplest example, suppose a line                 Rearranging a Line with \ ... \
                                                                                          \( \)
has gotten unmanageably long because of editing (or                      (This section should be skipped on ﬁrst read-
merely because it was unwisely typed). If it looks                ing.) Recall that ‘&’ is a shorthand that stands for
like                                                              whatever was matched by the left side of an s com-
                                                                  mand. In much the same way you can capture
      text      xy   text
                                                                  separate pieces of what was matched; the only differ-
you can break it between the ‘x’ and the ‘y’ like this:           ence is that you have to specify on the left side just
                                                                  what pieces you’re interested in.
      s/xy/x\
            \
      y/                                                                  Suppose, for instance, that you have a ﬁle of
                                                                  lines that consist of names in the form
This is actually a single command, although it is
typed on two lines. Bearing in mind that ‘\ turns off
                                           \’                           Smith, A. B.
special meanings, it seems relatively intuitive that a                  Jones, C.
                                                              -7-


and so on, and you want the initials to precede the                 Address Arithmetic
name, as in                                                                 The next step is to combine the line numbers
      A. B. Smith                                                   like ‘.’, ‘$’, ‘/.../’ and ‘?...?’ with ‘+’ and ‘– ’. Thus
      C. Jones                                                             $– 1
It is possible to do this with a series of editing com-             is a command to print the next to last line of the
mands, but it is tedious and error-prone. (It is                    current ﬁle (that is, one line before line ‘$’). For
instructive to ﬁgure out how it is done, though.)                   example, to recall how far you got in a previous edit-
         The alternative is to ‘tag’ the pieces of the pat-         ing session,
tern (in this case, the last name, and the initials), and
                                                                           $– 5,$p
then rearrange the pieces. On the left side of a sub-
stitution, if part of the pattern is enclosed between \  \(         prints the last six lines. (Be sure you understand why
and \ whatever matched that part is remembered,
      \),                                                           it’s six, not ﬁve.) If there aren’t six, of course, you’ll
and available for use on the right side. On the right               get an error message.
side, the symbol ‘\ refers to whatever matched the
                      \1’                                                  As another example,
ﬁrst \ \) pair, ‘\ to the second \ \), and so on.
      \(...\       \2’                \(...\
       The command
                                                                           .– 3,.+3p
                                                                    prints from three lines before where you are now (at
            \([ˆ,]∗\ ∗\ .∗\ \2 \
      1,$s/ˆ\      \), \( \)/\ \1/
                                                                    line dot) to three lines after, thus giving you a bit of
although hard to read, does the job. The ﬁrst \ \)
                                                 \(...\             context. By the way, the ‘+’ can be omitted:
matches the last name, which is any string up to the
comma; this is referred to on the right side with ‘\
                                                   \1’.
                                                                           .– 3,.3p
The second \ \) is whatever follows the comma and
            \(...\                                                  is absolutely identical in meaning.
any spaces, and is referred to as ‘\
                                   \2’.                                     Another area in which you can save typing
       Of course, with any editing sequence this com-               effort in specifying lines is to use ‘– ’ and ‘+’ as line
plicated, it’s foolhardy to simply run it and hope.                 numbers by themselves.
The global commands g and v discussed in section 4
                                                                           –
provide a way for you to print exactly those lines
which were affected by the substitute command, and                  by itself is a command to move back up one line in
thus verify that it did what you wanted in all cases.               the ﬁle. In fact, you can string several minus signs
                                                                    together to move back up that many lines:
3. LINE ADDRESSING IN THE EDITOR
                                                                           –––
       The next general area we will discuss is that of
line addressing in ed, that is, how you specify what                moves up three lines, as does ‘– 3’. Thus
lines are to be affected by editing commands. We                           – 3,+3p
have already used constructions like
                                                                    is also identical to the examples above.
      1,$s/x/y/
                                                                           Since ‘– ’ is shorter than ‘.– 1’, constructions
to specify a change on all lines. And most users are                like
long since familiar with using a single newline (or
                                                                           – ,.s/bad/good/
return) to print the next line, and with
                                                                    are useful. This changes ‘bad’ to ‘good’ on the previ-
      /thing/
                                                                    ous line and on the current line.
to ﬁnd a line that contains ‘thing’. Less familiar,                        ‘+’ and ‘– ’ can be used in combination with
surprisingly enough, is the use of                                  searches using ‘/.../’ and ‘?...?’, and with ‘$’. The
      ?thing?                                                       search

to scan backwards for the previous occurrence of                           /thing/– –
‘thing’. This is especially handy when you realize                  ﬁnds the line containing ‘thing’, and positions you
that the thing you want to operate on is back up the                two lines before it.
page from where you are currently editing.
       The slash and question mark are the only char-               Repeated Searches
acters you can use to delimit a context search, though                     Suppose you ask for the search
you can use essentially any character in a substitute
command.                                                                   /horrible thing/
                                                                    and when the line is printed you discover that it isn’t
                                                                    the horrible thing that you wanted, so it is necessary
                                                              -8-


to repeat the search again. You don’t have to re-type                      The line-changing commands a, c and i by
the search, for the construction                                    default all affect the current line — if you give no
                                                                    line number with them, a appends text after the
      //
                                                                    current line, c changes the current line, and i inserts
is a shorthand for ‘the previous thing that was                     text before the current line.
searched for’, whatever it was. This can be repeated                       a, c, and i behave identically in one respect —
as many times as necessary. You can also go back-                   when you stop appending, changing or inserting, dot
wards:                                                              points at the last line entered. This is exactly what
      ??                                                            you want for typing and editing on the ﬂy. For
                                                                    example, you can say
searches for the same thing, but in the reverse direc-
tion.                                                                     a
                                                                           ... text ...
      Not only can you repeat the search, but you
                                                                           ... botch ...                 (minor error)
can use ‘//’ as the left side of a substitute command,
to mean ‘the most recent pattern’.
                                                                          .
                                                                          s/botch/correct/               (ﬁx botched line)
      /horrible thing/                                                    a
       .... ed prints line with ‘horrible thing’ ...                       ... more text ...
      s//good/p
                                                                    without specifying any line number for the substitute
To go backwards and change a line, say                              command or for the second append command. Or
                                                                    you can say
      ??s//good/
                                                                      a
Of course, you can still use the ‘&’ on the right hand
                                                                       ... text ...
side of a substitute to stand for whatever got matched:
                                                                       ... horrible botch ...         (major error)
      //s//& &/p                                                      .
                                                                      c                               (replace entire line)
ﬁnds the next occurrence of whatever you searched
                                                                       ... ﬁxed up line ...
for last, replaces it by two copies of itself, then prints
the line just to verify that it worked.                                    You should experiment to determine what hap-
                                                                    pens if you add no lines with a, c or i.
Default Line Numbers and the Value of Dot
                                                                            The r command will read a ﬁle into the text
        One of the most effective ways to speed up                  being edited, either at the end if you give no address,
your editing is always to know what lines will be                   or after the speciﬁed line if you do. In either case,
affected by a command if you don’t specify the lines                dot points at the last line read in. Remember that you
it is to act on, and on what line you will be posi-                 can even say 0r to read a ﬁle in at the beginning of
tioned (i.e., the value of dot) when a command                      the text. (You can also say 0a or 1i to start adding
ﬁnishes. If you can edit without specifying unneces-                text at the beginning.)
sary line numbers, you can save a lot of typing.
                                                                           The w command writes out the entire ﬁle. If
       As the most obvious example, if you issue a                  you precede the command by one line number, that
search command like                                                 line is written, while if you precede it by two line
      /thing/                                                       numbers, that range of lines is written. The w com-
                                                                    mand does not change dot: the current line remains
you are left pointing at the next line that contains                the same, regardless of what lines are written. This is
‘thing’. Then no address is required with commands                  true even if you say something like
like s to make a substitution on that line, or p to print
it, or l to list it, or d to delete it, or a to append text               /ˆ\.AB/,/ˆ\.AE/w abstract
                                                                            \       \
after it, or c to change it, or i to insert text before it.         which involves a context search.
       What happens if there was no ‘thing’? Then                          Since the w command is so easy to use, you
you are left right where you were — dot is                          should save what you are editing regularly as you go
unchanged. This is also true if you were sitting on                 along just in case the system crashes, or in case you
the only ‘thing’ when you issued the command. The                   do something foolish, like clobbering what you’re
same rules hold for searches that use ‘?...?’; the only             editing.
difference is the direction in which you search.
                                                                            The least intuitive behavior, in a sense, is that
       The delete command d leaves dot pointing at                  of the s command. The rule is simple — you are left
the line that followed the last deleted line. When line             sitting on the last line that got changed. If there were
‘$’ gets deleted, however, dot points at the new line               no changes, then dot is unchanged.
‘$’.
                                                             -9-


       To illustrate, suppose that there are three lines
                                                                         /a/;/b/p
in the buffer, and you are sitting on the middle one:
                                                                   prints the range of lines from ‘ab’ to ‘bc’, because
      x1
                                                                   after the ‘a’ is found, dot is set to that line, and then
      x2
                                                                   ‘b’ is searched for, starting beyond that line.
      x3
                                                                         This property is most often useful in a very
Then the command                                                   simple situation. Suppose you want to ﬁnd the
      – ,+s/x/y/p                                                  second occurrence of ‘thing’. You could say

prints the third line, which is the last one changed.                    /thing/
But if the three lines had been                                          //

      x1                                                           but this prints the ﬁrst occurrence as well as the
      y2                                                           second, and is a nuisance when you know very well
      y3                                                           that it is only the second one you’re interested in.
                                                                   The solution is to say
and the same command had been issued while dot
pointed at the second line, then the result would be to                  /thing/;//
change and print only the ﬁrst line, and that is where             This says to ﬁnd the ﬁrst occurrence of ‘thing’, set
dot would be set.                                                  dot to that line, then ﬁnd the second and print only
                                                                   that.
Semicolon ‘;’
                                                                          Closely related is searching for the second pre-
        Searches with ‘/.../’ and ‘?...?’ start at the             vious occurrence of something, as in
current line and move forward or backward respec-
tively until they either ﬁnd the pattern or get back to                  ?something?;??
the current line. Sometimes this is not what is                    Printing the third or fourth or ... in either direction is
wanted. Suppose, for example, that the buffer con-                 left as an exercise.
tains lines like this:
                                                                          Finally, bear in mind that if you want to ﬁnd
       .                                                           the ﬁrst occurrence of something in a ﬁle, starting at
       .                                                           an arbitrary place within the ﬁle, it is not sufﬁcient to
       .                                                           say
       ab
       .                                                                 1;/thing/
       .                                                           because this fails if ‘thing’ occurs on line 1. But it is
       .                                                           possible to say
       bc
       .                                                                 0;/thing/
       .                                                           (one of the few places where 0 is a legal line
Starting at line 1, one would expect that the command              number), for this starts the search at line 1.

      /a/,/b/p                                                     Interrupting the Editor
prints all the lines from the ‘ab’ to the ‘bc’ inclusive.                 As a ﬁnal note on what dot gets set to, you
Actually this is not what happens. Both searches (for              should be aware that if you hit the interrupt or delete
‘a’ and for ‘b’) start from the same point, and thus               or rubout or break key while ed is doing a command,
they both ﬁnd the line that contains ‘ab’. The result              things are put back together again and your state is
is to print a single line. Worse, if there had been a              restored as much as possible to what it was before the
line with a ‘b’ in it before the ‘ab’ line, then the print         command began. Naturally, some changes are irrevo-
command would be in error, since the second line                   cable — if you are reading or writing a ﬁle or making
number would be less than the ﬁrst, and it is illegal to           substitutions or deleting lines, these will be stopped in
try to print lines in reverse order.                               some clean but unpredictable state in the middle
       This is because the comma separator for line                (which is why it is not usually wise to stop them).
numbers doesn’t set dot as each address is processed;              Dot may or may not be changed.
each search starts from the same place. In ed, the                         Printing is more clear cut. Dot is not changed
semicolon ‘;’ can be used just like comma, with the                until the printing is done. Thus if you print until you
single difference that use of a semicolon forces dot to            see an interesting line, then hit delete, you are not sit-
be set at that point as the line numbers are being                 ting on that line or even near it. Dot is left where it
evaluated. In effect, the semicolon ‘moves’ dot.                   was when the p command was started.
Thus in our example above, the command
                                                          - 10 -


4. GLOBAL COMMANDS                                                 signal for a new paragraph in some formatting pack-
       The global commands g and v are used to per-                ages). Remember that ‘+’ means ‘one line past dot’.
form one or more editing commands on all lines that                And
either contain (g) or don’t contain (v) a speciﬁed pat-                  g/topic/?ˆ\.SH?1
                                                                                   \
tern.
                                                                   searches for each line that contains ‘topic’, scans
         As the simplest example, the command                      backwards until it ﬁnds a line that begins ‘.SH’ (a
         g/UNIX/p                                                  section heading) and prints the line that follows that,
                                                                   thus showing the section headings under which ‘topic’
prints all lines that contain the word ‘UNIX’. The                 is mentioned. Finally,
pattern that goes between the slashes can be anything
that could be used in a line search or in a substitute                   g/ˆ\.EQ/+,/ˆ\.EN/– p
                                                                            \        \
command; exactly the same rules and limitations                    prints all the lines that lie between lines beginning
apply.                                                             with ‘.EQ’ and ‘.EN’ formatting commands.
         As another example, then,                                        The g and v commands can also be preceded
         g/ˆ\./p
            \                                                      by line numbers, in which case the lines searched are
                                                                   only those in the range speciﬁed.
prints all the formatting commands in a ﬁle (lines that
begin with ‘.’).                                                   Multi-line Global Commands
       The v command is identical to g, except that it                    It is possible to do more than one command
operates on those line that do not contain an                      under the control of a global command, although the
occurrence of the pattern. (Don’t look too hard for                syntax for expressing the operation is not especially
mnemonic signiﬁcance to the letter ‘v’.) So                        natural or pleasant. As an example, suppose the task
         v/ˆ\./p
            \                                                      is to change ‘x’ to ‘y’ and ‘a’ to ‘b’ on all lines that
                                                                   contain ‘thing’. Then
prints all the lines that don’t begin with ‘.’ — the
actual text lines.                                                       g/thing/s/x/y/\
                                                                                       \
                                                                         s/a/b/
         The command that follows g or v can be any-
thing:                                                             is sufﬁcient. The ‘\ signals the g command that the
                                                                                      \’
                                                                   set of commands continues on the next line; it ter-
         g/ˆ\./d
            \
                                                                   minates on the ﬁrst line that does not end with ‘\\’.
deletes all lines that begin with ‘.’, and                         (As a minor blemish, you can’t use a substitute com-
                                                                   mand to insert a newline within a g command.)
         g/ˆ$/d
                                                                        You should watch out for this problem: the
deletes all empty lines.                                           command
        Probably the most useful command that can
                                                                         g/x/s//y/\
                                                                                  \
follow a global is the substitute command, for this
                                                                         s/a/b/
can be used to make a change and print each affected
line for veriﬁcation. For example, we could change                 does not work as you expect. The remembered pat-
the word ‘Unix’ to ‘UNIX’ everywhere, and verify                   tern is the last pattern that was actually executed, so
that it really worked, with                                        sometimes it will be ‘x’ (as expected), and sometimes
                                                                   it will be ‘a’ (not expected). You must spell it out,
         g/Unix/s//UNIX/gp
                                                                   like this:
Notice that we used ‘//’ in the substitute command to
                                                                         g/x/s/x/y/\
                                                                                   \
mean ‘the previous pattern’, in this case, ‘Unix’. The
                                                                         s/a/b/
p command is done on every line that matches the
pattern, not just those on which a substitution took                      It is also possible to execute a, c and i com-
place.                                                             mands under a global command; as with other multi-
        The global command operates by making two                  line constructions, all that is needed is to add a ‘\ at
                                                                                                                       \’
passes over the ﬁle. On the ﬁrst pass, all lines that              the end of each line except the last. Thus to add a
match the pattern are marked. On the second pass,                  ‘.nf’ and ‘.sp’ command before each ‘.EQ’ line, type
each marked line in turn is examined, dot is set to
                                                                         g/ˆ\.EQ/i\
                                                                            \     \
that line, and the command executed. This means
that it is possible for the command that follows a g or
                                                                         .nf\
                                                                            \
v to use addresses, set dot, and so on, quite freely.
                                                                         .sp
                                                                   There is no need for a ﬁnal line containing a ‘.’ to
         g/ˆ\.PP/+
            \
                                                                   terminate the i command, unless there are further
prints the line that follows each ‘.PP’ command (the               commands being done under the global. On the other
                                                          - 11 -


hand, it does no harm to put it in either.                                Now if you decide at some time that you want
                                                                   to get back to the original state of ‘good’, you can
5. CUT AND PASTE WITH UNIX COMMANDS                                say
       One editing area in which non-programmers                         mv savegood good
seem not very conﬁdent is in what might be called
‘cut and paste’ operations — changing the name of a                (if you’re not interested in ‘savegood’ any more), or
ﬁle, making a copy of a ﬁle somewhere else, moving                       cp savegood good
a few lines from one place to another in a ﬁle, insert-
ing one ﬁle in the middle of another, splitting a ﬁle              if you still want to retain a safe copy.
into pieces, and splicing two or more ﬁles together.                      In summary, mv just renames a ﬁle; cp makes
       Yet most of these operations are actually quite             a duplicate copy. Both of them clobber the ‘target’
easy, if you keep your wits about you and go cau-                  ﬁle if it already exists, so you had better be sure
tiously. The next several sections talk about cut and              that’s what you want to do before you do it.
paste. We will begin with the UNIX commands for
moving entire ﬁles around, then discuss ed commands                Removing a File
for operating on pieces of ﬁles.                                          If you decide you are really done with a ﬁle
                                                                   forever, you can remove it with the rm command:
Changing the Name of a File
                                                                         rm savegood
       You have a ﬁle named ‘memo’ and you want it
to be called ‘paper’ instead. How is it done?                      throws away (irrevocably) the ﬁle called ‘savegood’.

      The UNIX program that renames ﬁles is called                 Putting Two or More Files Together
mv (for ‘move’); it ‘moves’ the ﬁle from one name to
another, like this:                                                       The next step is the familiar one of collecting
                                                                   two or more ﬁles into one big one. This will be
       mv memo paper                                               needed, for example, when the author of a paper
That’s all there is to it: mv from the old name to the             decides that several sections need to be combined into
new name.                                                          one. There are several ways to do it, of which the
                                                                   cleanest, once you get used to it, is a program called
       mv oldname newname                                          cat. (Not all programs have two-letter names.) cat is
Warning: if there is already a ﬁle around with the                 short for ‘concatenate’, which is exactly what we
new name, its present contents will be silently clob-              want to do.
bered by the information from the other ﬁle. The one                     Suppose the job is to combine the ﬁles ‘ﬁle1’
exception is that you can’t move a ﬁle to itself —                 and ‘ﬁle2’ into a single ﬁle called ‘bigﬁle’. If you
                                                                   say
       mv x x
                                                                         cat ﬁle
is illegal.
                                                                   the contents of ‘ﬁle’ will get printed on your terminal.
Making a Copy of a File                                            If you say
       Sometimes what you want is a copy of a ﬁle                        cat ﬁle1 ﬁle2
— an entirely fresh version. This might be because
you want to work on a ﬁle, and yet save a copy in                  the contents of ‘ﬁle1’ and then the contents of ‘ﬁle2’
case something gets fouled up, or just because you’re              will both be printed on your terminal, in that order.
paranoid.                                                          So cat combines the ﬁles, all right, but it’s not much
                                                                   help to print them on the terminal — we want them
       In any case, the way to do it is with the cp                in ‘bigﬁle’.
command. (cp stands for ‘copy’; the system is big on
short command names, which are appreciated by                             Fortunately, there is a way. You can tell the
heavy users, but sometimes a strain for novices.)                  system that instead of printing on your terminal, you
Suppose you have a ﬁle called ‘good’ and you want                  want the same information put in a ﬁle. The way to
to save a copy before you make some dramatic edit-                 do it is to add to the command line the character >
ing changes. Choose a name — ‘savegood’ might be                   and the name of the ﬁle where you want the output to
acceptable — then type                                             go. Then you can say

       cp good savegood                                                  cat ﬁle1 ﬁle2 >bigﬁle

This copies ‘good’ onto ‘savegood’, and you now                    and the job is done. (As with cp and mv, you’re put-
have two identical copies of the ﬁle ‘good’. (If                   ting something into ‘bigﬁle’, and anything that was
‘savegood’ previously contained something, it gets                 already there is destroyed.)
overwritten.)                                                             This ability to ‘capture’ the output of a pro-
                                                           - 12 -


gram is one of the most useful aspects of the system.               Filenames
Fortunately it’s not limited to the cat program — you                     The ﬁrst step is to ensure that you know the ed
can use it with any program that prints on your termi-              commands for reading and writing ﬁles. Of course
nal. We’ll see some more uses for it in a moment.                   you can’t go very far without knowing r and w.
       Naturally, you can combine several ﬁles, not                 Equally useful, but less well known, is the ‘edit’ com-
just two:                                                           mand e. Within ed, the command
      cat ﬁle1 ﬁle2 ﬁle3 ... >bigﬁle                                      e newﬁle
collects a whole bunch.                                             says ‘I want to edit a new ﬁle called newﬁle, without
      Question: is there any difference between                     leaving the editor.’ The e command discards what-
                                                                    ever you’re currently working on and starts over on
      cp good savegood                                              newﬁle. It’s exactly the same as if you had quit with
and                                                                 the q command, then re-entered ed with a new ﬁle
                                                                    name, except that if you have a pattern remembered,
      cat good >savegood                                            then a command like // will still work.
Answer: for most purposes, no. You might reason-                          If you enter ed with the command
ably ask why there are two programs in that case,
                                                                          ed ﬁle
since cat is obviously all you need. The answer is
that cp will do some other things as well, which you                ed remembers the name of the ﬁle, and any subse-
can investigate for yourself by reading the manual.                 quent e, r or w commands that don’t contain a
For now we’ll stick to simple usages.                               ﬁlename will refer to this remembered ﬁle. Thus
                                                                      ed ﬁle1
Adding Something to the End of a File
                                                                       ... (editing) ...
       Sometimes you want to add one ﬁle to the end                   w           (writes back in ﬁle1)
of another. We have enough building blocks now                        e ﬁle2 (edit new ﬁle, without leaving editor)
that you can do it; in fact before reading further it                  ... (editing on ﬁle2) ...
would be valuable if you ﬁgured out how. To be                        w           (writes back on ﬁle2)
speciﬁc, how would you use cp, mv and/or cat to add
the ﬁle ‘good1’ to the end of the ﬁle ‘good’?                       (and so on) does a series of edits on various ﬁles
                                                                    without ever leaving ed and without typing the name
      You could try                                                 of any ﬁle more than once. (As an aside, if you
      cat good good1 >temp                                          examine the sequence of commands here, you can see
      mv temp good                                                  why many UNIX systems use e as a synonym for
                                                                    ed.)
which is probably most direct.       You should also
understand why                                                            You can ﬁnd out the remembered ﬁle name at
                                                                    any time with the f command; just type f without a
      cat good good1 >good                                          ﬁle name. You can also change the name of the
doesn’t work. (Don’t practice with a good ‘good’!)                  remembered ﬁle name with f; a useful sequence is

      The easy way is to use a variant of >, called                       ed precious
>>. In fact, >> is identical to > except that instead of                  f junk
clobbering the old ﬁle, it simply tacks stuff on at the                    ... (editing) ...
end. Thus you could say                                             which gets a copy of a precious ﬁle, then uses f to
      cat good1 >>good                                              guarantee that a careless w command won’t clobber
                                                                    the original.
and ‘good1’ is added to the end of ‘good’. (And if
‘good’ didn’t exist, this makes a copy of ‘good1’                   Inserting One File into Another
called ‘good’.)
                                                                           Suppose you have a ﬁle called ‘memo’, and
6. CUT AND PASTE WITH THE EDITOR                                    you want the ﬁle called ‘table’ to be inserted just
                                                                    after the reference to Table 1. That is, in ‘memo’
        Now we move on to manipulating pieces of                    somewhere is a line that says
ﬁles — individual lines or groups of lines. This is
another area where new users seem unsure of them-                         Table 1 shows that ...
selves.                                                             and the data contained in ‘table’ has to go there,
                                                                    probably so it will be formatted properly by nroff or
                                                                    troff. Now what?
                                                                          This one is easy. Edit ‘memo’, ﬁnd ‘Table 1’,
                                                                    and add the ﬁle ‘table’ right there:
                                                           - 13 -


                                                                    Moving Lines Around
      ed memo
      /Table 1/                                                             Suppose you want to move a paragraph from
      Table 1 shows that ... [response from ed]                     its present position in a paper to the end. How would
      .r table                                                      you do it? As a concrete example, suppose each
                                                                    paragraph in the paper begins with the formatting
The critical line is the last one. As we said earlier,              command ‘.PP’. Think about it and write down the
the r command reads a ﬁle; here you asked for it to                 details before reading on.
be read in right after line dot. An r command
without any address adds lines at the end, so it is the                    The brute force way (not necessarily bad) is to
same as $r.                                                         write the paragraph onto a temporary ﬁle, delete it
                                                                    from its current position, then read in the temporary
Writing out Part of a File                                          ﬁle at the end. Assuming that you are sitting on the
                                                                    ‘.PP’ command that begins the paragraph, this is the
       The other side of the coin is writing out part of            sequence of commands:
the document you’re editing. For example, maybe
you want to split out into a separate ﬁle that table                      .,/ˆ\.PP/– w temp
                                                                              \
from the previous example, so it can be formatted and                     .,//– d
tested separately. Suppose that in the ﬁle being                          $r temp
edited we have                                                      That is, from where you are now (‘.’) until one line
      .TS                                                           before the next ‘.PP’ (‘/ˆ\.PP/– ’) write onto ‘temp’.
                                                                                              \
       ...[lots of stuff]                                           Then delete the same lines. Finally, read ‘temp’ at
      .TE                                                           the end.

which is the way a table is set up for the tbl program.                    As we said, that’s the brute force way. The
To isolate the table in a separate ﬁle called ‘table’,              easier way (often) is to use the move command m
ﬁrst ﬁnd the start of the table (the ‘.TS’ line), then              that ed provides — it lets you do the whole set of
write out the interesting part:                                     operations at one crack, without any temporary ﬁle.
                                                                           The m command is like many other ed com-
      /ˆ\.TS/
        \
                                                                    mands in that it takes up to two line numbers in front
      .TS [ed prints the line it found]                             that tell what lines are to be affected. It is also fol-
      .,/ˆ\.TE/w table
          \
                                                                    lowed by a line number that tells where the lines are
and the job is done. If you are conﬁdent, you can do                to go. Thus
it all at once with
                                                                          line1, line2 m line3
      /ˆ\.TS/;/ˆ\.TE/w table
        \       \
                                                                    says to move all the lines between ‘line1’ and ‘line2’
        The point is that the w command can write out               after ‘line3’. Naturally, any of ‘line1’ etc., can be
a group of lines, instead of the whole ﬁle. In fact,                patterns between slashes, $ signs, or other ways to
you can write out a single line if you like; just give              specify lines.
one line number instead of two. For example, if you                        Suppose again that you’re sitting at the ﬁrst
have just typed a horribly complicated line and you                 line of the paragraph. Then you can say
know that it (or something like it) is going to be
                                                                          .,/ˆ\.PP/– m$
                                                                              \
needed later, then save it — don’t re-type it. In the
editor, say                                                         That’s all.
      a                                                                   As another example of a frequent operation,
      ...lots of stuff...                                           you can reverse the order of two adjacent lines by
      ...horrible line...                                           moving the ﬁrst one to after the second. Suppose that
      .                                                             you are positioned at the ﬁrst. Then
      .w temp                                                             m+
      a
      ...more stuff...                                              does it. It says to move line dot to after one line
      .                                                             after line dot. If you are positioned on the second
      .r temp                                                       line,
      a                                                                   m– –
      ...more stuff...
      .                                                             does the interchange.

This last example is worth studying, to be sure you                        As you can see, the m command is more suc-
appreciate what’s going on.                                         cinct and direct than writing, deleting and re-reading.
                                                                    When is brute force better anyway? This is a matter
                                                                    of personal taste — do what you have most
                                                          - 14 -


conﬁdence in. The main difﬁculty with the m com-
                                                                          a
mand is that if you use patterns to specify both the
                                                                          .......... x ......... (long line)
lines you are moving and the target, you have to take
care that you specify them properly, or you may well
                                                                          .
                                                                          t.                      (make a copy)
not move the lines you thought you did. The result
                                                                          s/x/y/                  (change it a bit)
of a botched m command can be a ghastly mess.
                                                                          t.                      (make third copy)
Doing the job a step at a time makes it easier for you
                                                                          s/y/z/                  (change it a bit)
to verify at each step that you accomplished what you
wanted to. It’s also a good idea to issue a w com-                 and so on.
mand before doing anything complicated; then if you
goof, it’s easy to back up to where you were.                      The Temporary Escape ‘!’
                                                                          Sometimes it is convenient to be able to tem-
Marks                                                              porarily escape from the editor to do some other UNIX
       ed provides a facility for marking a line with a            command, perhaps one of the ﬁle copy or move com-
particular name so you can later reference it by name              mands discussed in section 5, without leaving the edi-
regardless of its actual line number. This can be                  tor. The ‘escape’ command ! provides a way to do
handy for moving lines, and for keeping track of                   this.
them as they move. The mark command is k; the                             If you say
command
                                                                          !any UNIX command
      kx
                                                                   your current editing state is suspended, and the UNIX
marks the current line with the name ‘x’. If a line                command you asked for is executed. When the com-
number precedes the k, that line is marked. (The                   mand ﬁnishes, ed will signal you by printing another
mark name must be a single lower case letter.) Now                 !; at that point you can resume editing.
you can refer to the marked line with the address
                                                                          You can really do any UNIX command, includ-
      ′x                                                           ing another ed. (This is quite common, in fact.) In
                                                                   this case, you can even do another !.
       Marks are most useful for moving things
around. Find the ﬁrst line of the block to be moved,               7. SUPPORTING TOOLS
and mark it with ′a. Then ﬁnd the last line and mark
it with ′b. Now position yourself at the place where                       There are several tools and techniques that go
the stuff is to go and say                                         along with the editor, all of which are relatively easy
                                                                   once you know how ed works, because they are all
      ′a,′bm.                                                      based on the editor. In this section we will give
                                                                   some fairly cursory examples of these tools, more to
       Bear in mind that only one line can have a par-             indicate their existence than to provide a complete
ticular mark name associated with it at any given                  tutorial. More information on each can be found in
time.                                                              [3].

Copying Lines                                                      Grep
       We mentioned earlier the idea of saving a line                      Sometimes you want to ﬁnd all occurrences of
that was hard to type or used often, so as to cut down             some word or pattern in a set of ﬁles, to edit them or
on typing time. Of course this could be more than                  perhaps just to verify their presence or absence. It
one line; then the saving is presumably even greater.              may be possible to edit each ﬁle separately and look
       ed provides another command, called t (for                  for the pattern of interest, but if there are many ﬁles
‘transfer’) for making a copy of a group of one or                 this can get very tedious, and if the ﬁles are really
more lines at any point. This is often easier than                 big, it may be impossible because of limits in ed.
writing and reading.                                                      The program grep was invented to get around
       The t command is identical to the m com-                    these limitations. The search patterns that we have
mand, except that instead of moving lines it simply                described in the paper are often called ‘regular
duplicates them at the place you named. Thus                       expressions’, and ‘grep’ stands for
      1,$t$                                                               g/re/p
duplicates the entire contents that you are editing. A             That describes exactly what grep does — it prints
more common use for t is for creating a series of                  every line in a set of ﬁles that contains a particular
lines that differ only slightly. For example, you can              pattern. Thus
say
                                                                          grep ′thing′ ﬁle1 ﬁle2 ﬁle3 ...
                                                            - 15 -


ﬁnds ‘thing’ wherever it occurs in any of the ﬁles                   Sed
‘ﬁle1’, ‘ﬁle2’, etc. grep also indicates the ﬁle in                         sed (‘stream editor’) is a version of the editor
which the line was found, so you can later edit it if                with restricted capabilities but which is capable of
you like.                                                            processing unlimited amounts of input. Basically sed
       The pattern represented by ‘thing’ can be any                 copies its input to its output, applying one or more
pattern you can use in the editor, since grep and ed                 editing commands to each line of input.
use exactly the same mechanism for pattern search-                          As an example, suppose that we want to do the
ing. It is wisest always to enclose the pattern in the               ‘Unix’ to ‘UNIX’ part of the example given above,
single quotes ′...′ if it contains any non-alphabetic                but without rewriting the ﬁles. Then the command
characters, since many such characters also mean
something special to the UNIX command interpreter                          sed ′s/Unix/UNIX/g′ ﬁle1 ﬁle2 ...
(the ‘shell’). If you don’t quote them, the command                  applies the command ‘s/Unix/UNIX/g’ to all lines
interpreter will try to interpret them before grep gets              from ‘ﬁle1’, ‘ﬁle2’, etc., and copies all lines to the
a chance.                                                            output. The advantage of using sed in such a case is
       There is also a way to ﬁnd lines that don’t                   that it can be used with input too large for ed to han-
contain a pattern:                                                   dle. All the output can be collected in one place,
                                                                     either in a ﬁle or perhaps piped into another program.
      grep – v ′thing′ ﬁle1 ﬁle2 ...
                                                                            If the editing transformation is so complicated
ﬁnds all lines that don’t contains ‘thing’. The – v                  that more than one editing command is needed, com-
must occur in the position shown. Given grep and                     mands can be supplied from a ﬁle, or on the com-
grep – v, it is possible to do things like selecting all             mand line, with a slightly more complex syntax. To
lines that contain some combination of patterns. For                 take commands from a ﬁle, for example,
example, to get all lines that contain ‘x’ but not ‘y’:
                                                                           sed – f cmdﬁle input– ﬁles...
      grep x ﬁle...  grep – v y
(The notation  is a ‘pipe’, which causes the output                        sed has further capabilities, including condi-
of the ﬁrst command to be used as input to the                       tional testing and branching, which we cannot go into
second command; see [2].)                                            here.

Editing Scripts                                                      Acknowledgement

        If a fairly complicated set of editing operations                   I am grateful to Ted Dolotta for his careful
is to be done on a whole set of ﬁles, the easiest thing              reading and valuable suggestions.
to do is to make up a ‘script’, i.e., a ﬁle that contains
the operations you want to perform, then apply this                  References
script to each ﬁle in turn.                                          [1]   Brian W. Kernighan, A Tutorial Introduction to
        For example, suppose you want to change                            the UNIX Text Editor, Bell Laboratories inter-
every ‘Unix’ to ‘UNIX’ and every ‘Gcos’ to ‘GCOS’                          nal memorandum.
in a large number of ﬁles. Then put into the ﬁle                     [2]   Brian W. Kernighan, UNIX For Beginners,
‘script’ the lines                                                         Bell Laboratories internal memorandum.
      g/Unix/s//UNIX/g                                               [3]   Ken L. Thompson and Dennis M. Ritchie, The
      g/Gcos/s//GCOS/g                                                     UNIX Programmer’s Manual. Bell Labora-
      w                                                                    tories.
      q
Now you can say
      ed ﬁle1 <script
      ed ﬁle2 <script
      ...
This causes ed to take its commands from the
prepared script. Notice that the whole job has to be
planned in advance.
       And of course by using the UNIX command
interpreter, you can cycle through a set of ﬁles
automatically, with varying degrees of ease.
                                    An Introduction to the UNIX Shell

                                                     S. R. Bourne
                                                   Bell Laboratories
                                             Murray Hill, New Jersey 07974



                                                      ABSTRACT

          The shell is a command programming language that provides an interface to the UNIX†
          operating system. Its features include control-ﬂow primitives, parameter passing, vari-
          ables and string substitution. Constructs such as while, if then else, case and for are
          available. Two-way communication is possible between the shell and commands.
          String-valued parameters, typically ﬁle names or ﬂags, may be passed to a command.
          A return code is set by commands that may be used to determine control-ﬂow, and the
          standard output from a command may be used as shell input.
          The shell can modify the environment in which commands run. Input and output can
          be redirected to ﬁles, and processes that communicate through ‘pipes’ can be invoked.
          Commands are found by searching directories in the ﬁle system in a sequence that can
          be deﬁned by the user. Commands can be read either from the terminal or from a ﬁle,
          which allows command procedures to be stored for later use.



November 12, 1978




_
______________
†UNIX is a Trademark of Bell Laboratories.
                                 An Introduction to the UNIX Shell

                                                 S. R. Bourne
                                             Bell Laboratories
                                       Murray Hill, New Jersey 07974


1.0 Introduction
The shell is both a command language and a programming language that provides an interface to the
UNIX operating system. This memorandum describes, with examples, the UNIX shell. The ﬁrst section
covers most of the everyday requirements of terminal users. Some familiarity with UNIX is an advan-
tage when reading this section; see, for example, "UNIX for beginners".1 Section 2 describes those
features of the shell primarily intended for use within shell procedures. These include the control-ﬂow
primitives and string-valued variables provided by the shell. A knowledge of a programming language
would be a help when reading this section. The last section describes the more advanced features of the
shell. References of the form "see pipe (2)" are to a section of the UNIX manual.2

1.1 Simple commands
Simple commands consist of one or more words separated by blanks. The ﬁrst word is the name of the
command to be executed; any remaining words are passed as arguments to the command. For example,
                   who
is a command that prints the names of users logged in. The command
                   ls −l
prints a list of ﬁles in the current directory. The argument −l tells ls to print status information, size and
the creation date for each ﬁle.

1.2 Background commands
To execute a command the shell normally creates a new process and waits for it to ﬁnish. A command
may be run without waiting for it to ﬁnish. For example,
                   cc pgm.c &
calls the C compiler to compile the ﬁle pgm.c . The trailing & is an operator that instructs the shell not
to wait for the command to ﬁnish. To help keep track of such a process the shell reports its process
number following its creation. A list of currently active processes may be obtained using the ps com-
mand.

1.3 Input output redirection
Most commands produce output on the standard output that is initially connected to the terminal. This
output may be sent to a ﬁle by writing, for example,
                   ls −l >ﬁle
The notation >ﬁle is interpreted by the shell and is not passed as an argument to ls. If ﬁle does not exist
then the shell creates it; otherwise the original contents of ﬁle are replaced with the output from ls. Out-
put may be appended to a ﬁle using the notation
                   ls −l >>ﬁle
In this case ﬁle is also created if it does not already exist.
                                                     -2-


The standard input of a command may be taken from a ﬁle instead of the terminal by writing, for exam-
ple,
                  wc <ﬁle
The command wc reads its standard input (in this case redirected from ﬁle) and prints the number of
characters, words and lines found. If only the number of lines is required then
                  wc −l <ﬁle
could be used.

1.4 Pipelines and ﬁlters
The standard output of one command may be connected to the standard input of another by writing the
‘pipe’ operator, indicated by | , as in,
                  ls −l | wc
Two commands connected in this way constitute a pipeline and the overall effect is the same as
                  ls −l >ﬁle; wc <ﬁle
except that no ﬁle is used. Instead the two processes are connected by a pipe (see pipe (2)) and are run
in parallel. Pipes are unidirectional and synchronization is achieved by halting wc when there is nothing
to read and halting ls when the pipe is full.
A ﬁlter is a command that reads its standard input, transforms it in some way, and prints the result as
output. One such ﬁlter, grep, selects from its input those lines that contain some speciﬁed string. For
example,
                  ls | grep old
prints those lines, if any, of the output from ls that contain the string old. Another useful ﬁlter is sort.
For example,
                  who | sort
will print an alphabetically sorted list of logged in users.
A pipeline may consist of more than two commands, for example,
                  ls | grep old | wc −l
prints the number of ﬁle names in the current directory containing the string old.

1.5 File name generation
Many commands accept arguments which are ﬁle names. For example,
                  ls −l main.c
prints information relating to the ﬁle main.c .
The shell provides a mechanism for generating a list of ﬁle names that match a pattern. For example,
                  ls −l *.c
generates, as arguments to ls, all ﬁle names in the current directory that end in .c . The character * is a
pattern that will match any string including the null string. In general patterns are speciﬁed as follows.
      *          Matches any string of characters including the null string.
      ?          Matches any single character.
      [. . .]    Matches any one of the characters enclosed. A pair of characters separated by a minus
                 will match any character lexically between the pair.
For example,
                                                    -3-


                  [a−z]*
matches all names in the current directory beginning with one of the letters a through z.
                  /usr/fred/test/?
matches all names in the directory /usr/fred/test that consist of a single character. If no ﬁle name is
found that matches the pattern then the pattern is passed, unchanged, as an argument.
This mechanism is useful both to save typing and to select names according to some pattern. It may
also be used to ﬁnd ﬁles. For example,
                  echo /usr/fred/*/core
ﬁnds and prints the names of all core ﬁles in sub-directories of /usr/fred . (echo is a standard UNIX
command that prints its arguments, separated by blanks.) This last feature can be expensive, requiring a
scan of all sub-directories of /usr/fred .
There is one exception to the general rules given for patterns. The character ‘.’ at the start of a ﬁle
name must be explicitly matched.
                  echo *
will therefore echo all ﬁle names in the current directory not beginning with ‘.’ .
                  echo .*
will echo all those ﬁle names that begin with ‘.’ . This avoids inadvertent matching of the names ‘.’ and
‘..’ which mean ‘the current directory’ and ‘the parent directory’ respectively. (Notice that ls
suppresses information for the ﬁles ‘.’ and ‘..’ .)

1.6 Quoting
Characters that have a special meaning to the shell, such as < > * ? | & , are called metacharacters. A
complete list of metacharacters is given in appendix B. Any character preceded by a \ is quoted and
loses its special meaning, if any. The \ is elided so that
                  echo \?
will echo a single ? , and
                  echo \\
will echo a single \ . To allow long strings to be continued over more than one line the sequence \new-
line is ignored.
\ is convenient for quoting single characters. When more than one character needs quoting the above
mechanism is clumsy and error prone. A string of characters may be quoted by enclosing the string
between single quotes. For example,
                  echo xx´****´xx
will echo
                  xx****xx
The quoted string may not contain a single quote but may contain newlines, which are preserved. This
quoting mechanism is the most simple and is recommended for casual use.
A third quoting mechanism using double quotes is also available that prevents interpretation of some but
not all metacharacters. Discussion of the details is deferred to section 3.4 .
                                                   -4-


1.7 Prompting
When the shell is used from a terminal it will issue a prompt before reading a command. By default
this prompt is ‘$ ’ . It may be changed by saying, for example,
                 PS1=yesdear

that sets the prompt to be the string yesdear . If a newline is typed and further input is needed then the
shell will issue the prompt ‘> ’ . Sometimes this can be caused by mistyping a quote mark. If it is
unexpected then an interrupt (DEL) will return the shell to read another command. This prompt may be
changed by saying, for example,
                 PS2=more


1.8 The shell and login
Following login (1) the shell is called to read and execute commands typed at the terminal. If the user’s
login directory contains the ﬁle .proﬁle then it is assumed to contain commands and is read by the shell
before reading any commands from the terminal.

1.9 Summary

      •     ls
            Print the names of ﬁles in the current directory.
      •     ls >ﬁle
            Put the output from ls into ﬁle.
      •     ls | wc −l
            Print the number of ﬁles in the current directory.
      •     ls | grep old
            Print those ﬁle names containing the string old.
      •     ls | grep old | wc −l
            Print the number of ﬁles whose name contains the string old.
      •     cc pgm.c &
            Run cc in the background.
                                                        -5-


2.0 Shell procedures
The shell may be used to read and execute commands contained in a ﬁle. For example,
                     sh ﬁle [ args . . . ]
calls the shell to read commands from ﬁle. Such a ﬁle is called a command procedure or shell pro-
cedure. Arguments may be supplied with the call and are referred to in ﬁle using the positional parame-
ters $1, $2, . . . . For example, if the ﬁle wg contains
                     who | grep $1
then
                     sh wg fred
is equivalent to
                     who | grep fred

UNIX ﬁles have three independent attributes, read, write and execute. The UNIX command chmod (1)
may be used to make a ﬁle executable. For example,
                     chmod +x wg
will ensure that the ﬁle wg has execute status. Following this, the command
                     wg fred
is equivalent to
                     sh wg fred
This allows shell procedures and programs to be used interchangeably. In either case a new process is
created to run the command.
As well as providing names for the positional parameters, the number of positional parameters in the call
is available as $# . The name of the ﬁle being executed is available as $0 .
A special shell parameter $* is used to substitute for all positional parameters except $0 . A typical use
of this is to provide some default arguments, as in,
                     nroff −T450 −ms $*
which simply prepends some arguments to those already given.

2.1 Control ﬂow - for
A frequent use of shell procedures is to loop through the arguments ($1, $2, . . .) executing commands
once for each argument. An example of such a procedure is tel that searches the ﬁle /usr/lib/telnos that
contains lines of the form
                     ...
                     fred mh0123
                     bert mh0789
                     ...
The text of tel is
                     for i
                     do grep $i /usr/lib/telnos; done
The command
                     tel fred
prints those lines in /usr/lib/telnos that contain the string fred .
                                                     -6-


                  tel fred bert
prints those lines containing fred followed by those for bert.
The for loop notation is recognized by the shell and has the general form
                  for name in w1 w2 . . .
                  do command-list
                  done
A command-list is a sequence of one or more simple commands separated or terminated by a newline or
semicolon. Furthermore, reserved words like do and done are only recognized following a newline or
semicolon. name is a shell variable that is set to the words w1 w2 . . . in turn each time the command-
list following do is executed. If in w1 w2 . . . is omitted then the loop is executed once for each posi-
tional parameter; that is, in $* is assumed.
Another example of the use of the for loop is the create command whose text is
                  for i do >$i; done
The command
                  create alpha beta
ensures that two empty ﬁles alpha and beta exist and are empty. The notation >ﬁle may be used on its
own to create or clear the contents of a ﬁle. Notice also that a semicolon (or newline) is required before
done.

2.2 Control ﬂow - case
A multiple way branch is provided for by the case notation. For example,
                  case $#   in
                       1)    cat >>$1 ;;
                       2)    cat >>$2 <$1 ;;
                       *)    echo ´usage: append [ from ] to´ ;;
                  esac
is an append command. When called with one argument as
                  append ﬁle
$# is the string 1 and the standard input is copied onto the end of ﬁle using the cat command.
                  append ﬁle1 ﬁle2
appends the contents of ﬁle1 onto ﬁle2. If the number of arguments supplied to append is other than 1
or 2 then a message is printed indicating proper usage.
The general form of the case command is
                  case word in
                       pattern ) command-list ;;
                       ...
                  esac
The shell attempts to match word with each pattern, in the order in which the patterns appear. If a
match is found the associated command-list is executed and execution of the case is complete. Since *
is the pattern that matches any string it can be used for the default case.
A word of caution: no check is made to ensure that only one pattern matches the case argument. The
ﬁrst match found deﬁnes the set of commands to be executed. In the example below the commands fol-
lowing the second * will never be executed.
                                                  -7-


                   case $# in
                        *) . . . ;;
                        *) . . . ;;
                   esac

Another example of the use of the case construction is to distinguish between different forms of an argu-
ment. The following example is a fragment of a cc command.
                   for i
                   do case $i in
                       −[ocs])        . . . ;;
                       −*) echo ´unknown ﬂag $i´ ;;
                       *.c) /lib/c0 $i . . . ;;
                       *) echo ´unexpected argument $i´ ;;
                       esac
                   done

To allow the same commands to be associated with more than one pattern the case command provides
for alternative patterns separated by a | . For example,
                   case $i in
                        −x | −y)      ...
                   esac
is equivalent to
                   case $i in
                        −[xy])        ...
                   esac

The usual quoting conventions apply so that
                   case $i in
                        \?) . . .
will match the character ? .

2.3 Here documents
The shell procedure tel in section 2.1 uses the ﬁle /usr/lib/telnos to supply the data for grep. An alter-
native is to include this data within the shell procedure as a here document, as in,
                   for i
                   do grep $i <<!
                       ...
                       fred mh0123
                       bert mh0789
                       ...
                   !
                   done
In this example the shell takes the lines between < and ! as the standard input for grep. The string !
                                                    <!
is arbitrary, the document being terminated by a line that consists of the string following < .
                                                                                             <
Parameters are substituted in the document before it is made available to grep as illustrated by the fol-
lowing procedure called edg .
                                                   -8-


                  ed $3 < <%
                  g/$1/s//$2/g
                  w
                  %
The call
                  edg string1 string2 ﬁle
is then equivalent to the command
                  ed ﬁle <<%
                  g/string1/s//string2/g
                  w
                  %
and changes all occurrences of string1 in ﬁle to string2 . Substitution can be prevented using \ to quote
the special character $ as in
                  ed $3 < <+
                  1,\$s/$1/$2/g
                  w
                  +
(This version of edg is equivalent to the ﬁrst except that ed will print a ? if there are no occurrences of
the string $1 .) Substitution within a here document may be prevented entirely by quoting the terminat-
ing string, for example,
                  grep $i <<\#
                  ...
                  #
The document is presented without modiﬁcation to grep. If parameter substitution is not required in a
here document this latter form is more efﬁcient.

2.4 Shell variables
The shell provides string-valued variables. Variable names begin with a letter and consist of letters,
digits and underscores. Variables may be given values by writing, for example,
                  user=fred box=m000 acct=mh0000
which assigns values to the variables user, box and acct. A variable may be set to the null string by
saying, for example,
                  null=
The value of a variable is substituted by preceding its name with $ ; for example,
                  echo $user
will echo fred.
Variables may be used interactively to provide abbreviations for frequently used strings. For example,
                  b=/usr/fred/bin
                  mv pgm $b
will move the ﬁle pgm from the current directory to the directory /usr/fred/bin . A more general nota-
tion is available for parameter (or variable) substitution, as in,
                  echo ${user}
which is equivalent to
                                                     -9-


                 echo $user
and is used when the parameter name is followed by a letter or digit. For example,
                 tmp=/tmp/ps
                 ps a >${tmp}a
will direct the output of ps to the ﬁle /tmp/psa, whereas,
                 ps a >$tmpa
would cause the value of the variable tmpa to be substituted.
Except for $? the following are set initially by the shell. $? is set after executing each command.
      $?        The exit status (return code) of the last command executed as a decimal string. Most
                commands return a zero exit status if they complete successfully, otherwise a non-zero
                exit status is returned. Testing the value of return codes is dealt with later under if and
                while commands.
      $#        The number of positional parameters (in decimal). Used, for example, in the append
                command to check the number of parameters.
      $$        The process number of this shell (in decimal). Since process numbers are unique among
                all existing processes, this string is frequently used to generate unique temporary ﬁle
                names. For example,
                                  ps a >/tmp/ps$$
                                  ...
                                  rm /tmp/ps$$

      $!        The process number of the last process run in the background (in decimal).
      $−        The current shell ﬂags, such as −x and −v .
Some variables have a special meaning to the shell and should be avoided for general use.
      $MAIL     When used interactively the shell looks at the ﬁle speciﬁed by this variable before it
                issues a prompt. If the speciﬁed ﬁle has been modiﬁed since it was last looked at the
                shell prints the message you have mail before prompting for the next command. This
                variable is typically set in the ﬁle .proﬁle, in the user’s login directory. For example,
                                  MAIL=/usr/mail/fred

      $HOME The default argument for the cd command. The current directory is used to resolve ﬁle
            name references that do not begin with a / , and is changed using the cd command. For
            example,
                                  cd /usr/fred/bin
                makes the current directory /usr/fred/bin .
                                  cat wn
                will print on the terminal the ﬁle wn in this directory. The command cd with no argu-
                ment is equivalent to
                                  cd $HOME
                This variable is also typically set in the the user’s login proﬁle.
      $PATH A list of directories that contain commands (the search path ). Each time a command is
                                                            - 10 -


                   executed by the shell a list of directories is searched for an executable ﬁle. If $PATH is
                   not set then the current directory, /bin, and /usr/bin are searched by default. Otherwise
                   $PATH consists of directory names separated by : . For example,
                                     PATH=:/usr/fred/bin:/bin:/usr/bin

                   speciﬁes that the current directory (the null string before the ﬁrst : ), /usr/fred/bin, /bin
                   and /usr/bin are to be searched in that order. In this way individual users can have their
                   own ‘private’ commands that are accessible independently of the current directory. If
                   the command name contains a / then this directory search is not used; a single attempt is
                   made to execute the command.
      $PS1         The primary shell prompt string, by default, ‘$ ’.
      $PS2         The shell prompt when further input is needed, by default, ‘> ’.
      $IFS         The set of characters used by blank interpretation (see section 3.4).

2.5 The test command
The test command, although not part of the shell, is intended for use by shell programs. For example,
                    test −f ﬁle
returns zero exit status if ﬁle exists and non-zero exit status otherwise. In general test evaluates a predi-
cate and returns the result as its exit status. Some of the more frequently used test arguments are given
here, see test (1) for a complete speciﬁcation.
                    test   s          true   if   the   argument s is not the null string
                    test   −f ﬁle     true   if   ﬁle   exists
                    test   −r ﬁle     true   if   ﬁle   is readable
                    test   −w ﬁle     true   if   ﬁle   is writable
                    test   −d ﬁle     true   if   ﬁle   is a directory


2.6 Control ﬂow - while
The actions of the for loop and the case branch are determined by data available to the shell. A while
or until loop and an if then else branch are also provided whose actions are determined by the exit
status returned by commands. A while loop has the general form
                    while command-list1
                    do command-list2
                    done

The value tested by the while command is the exit status of the last simple command following while.
Each time round the loop command-list1 is executed; if a zero exit status is returned then command-list2
is executed; otherwise, the loop terminates. For example,
                    while test $1
                    do . . .
                       shift
                    done
is equivalent to
                    for i
                    do . . .
                    done
shift is a shell command that renames the positional parameters $2, $3, . . . as $1, $2, . . . and loses $1 .
Another kind of use for the while/until loop is to wait until some external event occurs and then run
some commands. In an until loop the termination condition is reversed. For example,
                                                  - 11 -


                 until test −f ﬁle
                 do sleep 300; done
                 commands
will loop until ﬁle exists. Each time round the loop it waits for 5 minutes before trying again. (Presum-
ably another process will eventually create the ﬁle.)

2.7 Control ﬂow - if
Also available is a general conditional branch of the form,
                 if command-list
                 then    command-list
                 else    command-list
                 ﬁ
that tests the value returned by the last simple command following if.
The if command may be used in conjunction with the test command to test for the existence of a ﬁle as
in
                 if test −f ﬁle
                 then      process ﬁle
                 else      do something else
                 ﬁ

An example of the use of if, case and for constructions is given in section 2.10 .
A multiple test if command of the form
                 if . . .
                 then       ...
                 else       if . . .
                            then       ...
                            else       if . . .
                                       ...
                                       ﬁ
                            ﬁ
                 ﬁ
may be written using an extension of the if notation as,
                 if . . .
                 then       ...
                 elif       ...
                 then       ...
                 elif       ...
                 ...
                 ﬁ

The following example is the touch command which changes the ‘last modiﬁed’ time for a list of ﬁles.
The command may be used in conjunction with make (1) to force recompilation of a list of ﬁles.
                                                   - 12 -


                 ﬂag=
                 for i
                 do case $i in
                     −c) ﬂag=N ;;
                     *) if test −f $i
                           then      ln $i junk$$; rm junk$$
                           elif test $ﬂag
                           then      echo ﬁle \´$i\´ does not exist
                           else      >$i
                           ﬁ
                      esac
                 done
The −c ﬂag is used in this command to force subsequent ﬁles to be created if they do not already exist.
Otherwise, if the ﬁle does not exist, an error message is printed. The shell variable ﬂag is set to some
non-null string if the −c argument is encountered. The commands
                 ln . . .; rm . . .
make a link to the ﬁle and then remove it thus causing the last modiﬁed date to be updated.
The sequence
                 if command1
                 then   command2
                 ﬁ
may be written
                 command1 && command2
Conversely,
                 command1 | | command2
executes command2 only if command1 fails. In each case the value returned is that of the last simple
command executed.

2.8 Command grouping
Commands may be grouped in two ways,
                 { command-list ; }
and
                 ( command-list )

In the ﬁrst command-list is simply executed. The second form executes command-list as a separate pro-
cess. For example,
                 (cd x; rm junk )
executes rm junk in the directory x without changing the current directory of the invoking shell.
The commands
                 cd x; rm junk
have the same effect but leave the invoking shell in the directory x.
                                                    - 13 -


2.9 Debugging shell procedures
The shell provides two tracing mechanisms to help when debugging shell procedures. The ﬁrst is
invoked within the procedure as
                  set −v
(v for verbose) and causes lines of the procedure to be printed as they are read. It is useful to help iso-
late syntax errors. It may be invoked without modifying the procedure by saying
                  sh −v proc . . .
where proc is the name of the shell procedure. This ﬂag may be used in conjunction with the −n ﬂag
which prevents execution of subsequent commands. (Note that saying set −n at a terminal will render
the terminal useless until an end-of-ﬁle is typed.)
The command
                  set −x
will produce an execution trace. Following parameter substitution each command is printed as it is exe-
cuted. (Try these at the terminal to see what effect they have.) Both ﬂags may be turned off by saying
                  set −
and the current setting of the shell ﬂags is available as $− .

2.10 The man command
The following is the man command which is used to print sections of the UNIX manual. It is called,
for example, as
                           man sh
                           man −t ed
                           man 2 fork
In the ﬁrst the manual section for sh is printed. Since no section is speciﬁed, section 1 is used. The
second example will typeset (−t option) the manual section for ed. The last prints the fork manual page
from section 2.
                                  - 14 -


cd /usr/man

: ´colon is the comment command´
: ´default is nroff ($N), section 1 ($s)´
N=n s=1

for i
do case $i in
   [1−9]*)         s=$i ;;
   −t)    N=t ;;
   −n) N=n ;;
   −*) echo unknown ﬂag \´$i\´ ;;

   *)     if test −f man$s/$i.$s
          then      ${N}roff man0/${N}aa man$s/$i.$s
          else      : ´look through all manual sections´
                    found=no
                    for j in 1 2 3 4 5 6 7 8 9
                    do if test −f man$j/$i.$j
                        then man $j $i
                             found=yes
                        ﬁ
                    done
                    case $found in
                          no) echo ´$i: manual page not found´
                    esac
          ﬁ
   esac
done
                Figure 1. A version of the man command
                                                      - 15 -


3.0 Keyword parameters
Shell variables may be given values by assignment or when a shell procedure is invoked. An argument
to a shell procedure of the form name=value that precedes the command name causes value to be
assigned to name before execution of the procedure begins. The value of name in the invoking shell is
not affected. For example,
                  user=fred command
will execute command with user set to fred. The −k ﬂag causes arguments of the form name=value to
be interpreted in this way anywhere in the argument list. Such names are sometimes called keyword
parameters. If any arguments remain they are available as positional parameters $1, $2, . . . .
The set command may also be used to set positional parameters from within a procedure. For example,
                  set − *
will set $1 to the ﬁrst ﬁle name in the current directory, $2 to the next, and so on. Note that the ﬁrst
argument, −, ensures correct treatment when the ﬁrst ﬁle name begins with a − .

3.1 Parameter transmission
When a shell procedure is invoked both positional and keyword parameters may be supplied with the
call. Keyword parameters are also made available implicitly to a shell procedure by specifying in
advance that such parameters are to be exported. For example,
                  export user box
marks the variables user and box for export. When a shell procedure is invoked copies are made of all
exportable variables for use within the invoked procedure. Modiﬁcation of such variables within the
procedure does not affect the values in the invoking shell. It is generally true of a shell procedure that it
may not modify the state of its caller without explicit request on the part of the caller. (Shared ﬁle
descriptors are an exception to this rule.)
Names whose value is intended to remain constant may be declared readonly . The form of this com-
mand is the same as that of the export command,
                  readonly name . . .
Subsequent attempts to set readonly variables are illegal.

3.2 Parameter substitution
If a shell parameter is not set then the null string is substituted for it. For example, if the variable d is
not set
                  echo $d
or
                  echo ${d}
will echo nothing. A default string may be given as in
                  echo ${d−.}
which will echo the value of the variable d if it is set and ‘.’ otherwise. The default string is evaluated
using the usual quoting conventions so that
                  echo ${d−´*´}
will echo * if the variable d is not set. Similarly
                  echo ${d−$1}
will echo the value of d if it is set and the value (if any) of $1 otherwise. A variable may be assigned a
default value using the notation
                                                    - 16 -


                   echo ${d=.}
which substitutes the same string as
                   echo ${d−.}
and if d were not previously set then it will be set to the string ‘.’ . (The notation ${. . .=. . .} is not
available for positional parameters.)
If there is no sensible default then the notation
                   echo ${d?message}
will echo the value of the variable d if it has one, otherwise message is printed by the shell and execu-
tion of the shell procedure is abandoned. If message is absent then a standard message is printed. A
shell procedure that requires some parameters to be set might start as follows.
                   : ${user?} ${acct?} ${bin?}
                   ...
Colon (:) is a command that is built in to the shell and does nothing once its arguments have been
evaluated. If any of the variables user, acct or bin are not set then the shell will abandon execution of
the procedure.

3.3 Command substitution
The standard output from a command can be substituted in a similar way to parameters. The command
pwd prints on its standard output the name of the current directory. For example, if the current directory
is /usr/fred/bin then the command
                   d=`pwd`
is equivalent to
                   d=/usr/fred/bin

The entire string between grave accents (`. . .`) is taken as the command to be executed and is replaced
with the output from the command. The command is written using the usual quoting conventions except
that a ` must be escaped using a \ . For example,
                   ls `echo "$1"`
is equivalent to
                   ls $1
Command substitution occurs in all contexts where parameter substitution occurs (including here docu-
ments) and the treatment of the resulting text is the same in both cases. This mechanism allows string
processing commands to be used within shell procedures. An example of such a command is basename
which removes a speciﬁed sufﬁx from a string. For example,
                   basename main.c .c
will print the string main . Its use is illustrated by the following fragment from a cc command.
                   case $A in
                        ...
                        *.c)         B=`basename $A .c`
                        ...
                   esac
that sets B to the part of $A with the sufﬁx .c stripped.
Here are some composite examples.
                                                     - 17 -


      •     for i in `ls −t`; do . . .
            The variable i is set to the names of ﬁles in time order, most recent ﬁrst.
      •     set `date`; echo $6 $2 $3, $4
            will print, e.g., 1977 Nov 1, 23:59:59

3.4 Evaluation and quoting
The shell is a macro processor that provides parameter substitution, command substitution and ﬁle name
generation for the arguments to commands. This section discusses the order in which these evaluations
occur and the effects of the various quoting mechanisms.
Commands are parsed initially according to the grammar given in appendix A. Before a command is
executed the following substitutions occur.
      •     parameter substitution, e.g. $user
      •     command substitution, e.g. `pwd`
            Only one evaluation occurs so that if, for example, the value of the variable X is the string
            $y then
                                echo $X
            will echo $y .
      •     blank interpretation
            Following the above substitutions the resulting characters are broken into non-blank words
            (blank interpretation). For this purpose ‘blanks’ are the characters of the string $IFS. By
            default, this string consists of blank, tab and newline. The null string is not regarded as a
            word unless it is quoted. For example,
                                echo ´´
            will pass on the null string as the ﬁrst argument to echo, whereas
                                echo $null
            will call echo with no arguments if the variable null is not set or set to the null string.
      •     ﬁle name generation
            Each word is then scanned for the ﬁle pattern characters *, ? and [. . .] and an alphabetical
            list of ﬁle names is generated to replace the word. Each such ﬁle name is a separate argu-
            ment.
The evaluations just described also occur in the list of words associated with a for loop. Only substitu-
tion occurs in the word used for a case branch.
As well as the quoting mechanisms described earlier using \ and ´. . .´ a third quoting mechanism is pro-
vided using double quotes. Within double quotes parameter and command substitution occurs but ﬁle
name generation and the interpretation of blanks does not. The following characters have a special
meaning within double quotes and may be quoted using \ .
                 $           parameter substitution
                 `           command substitution
                 "           ends the quoted string
                 \           quotes the special characters $ ` " \
For example,
                 echo "$x"
will pass the value of the variable x as a single argument to echo. Similarly,
                 echo "$*"
will pass the positional parameters as a single argument and is equivalent to
                                                    - 18 -


                   echo "$1 $2 . . ."
The notation $@ is the same as $* except when it is quoted.
                echo "$@"
will pass the positional parameters, unevaluated, to echo and is equivalent to
                   echo "$1" "$2" . . .

The following table gives, for each quoting mechanism, the shell metacharacters that are evaluated.
                                                    metacharacter
                                        \     $       *       `        "         ´
                             ´          n     n       n       n        n         t
                             `          y     n       n       t        n         n
                             "          y     y       n       y        t         n

                                        t     terminator
                                        y     interpreted
                                        n     not interpreted

                                            Figure 2. Quoting mechanisms

In cases where more than one evaluation of a string is required the built-in command eval may be used.
For example, if the variable X has the value $y, and if y has the value pqr then
                   eval echo $X
will echo the string pqr .
In general the eval command evaluates its arguments (as do all commands) and treats the result as input
to the shell. The input is read and the resulting command(s) executed. For example,
                   wg=´eval who | grep´
                   $wg fred
is equivalent to
                   who | grep fred
In this example, eval is required since there is no interpretation of metacharacters, such as | , following
substitution.

3.5 Error handling
The treatment of errors detected by the shell depends on the type of error and on whether the shell is
being used interactively. An interactive shell is one whose input and output are connected to a terminal
(as determined by gtty (2)). A shell invoked with the −i ﬂag is also interactive.
Execution of a command (see also 3.7) may fail for any of the following reasons.
•     Input output redirection may fail. For example, if a ﬁle does not exist or cannot be created.
•     The command itself does not exist or cannot be executed.
•     The command terminates abnormally, for example, with a "bus error" or "memory fault". See
      Figure 2 below for a complete list of UNIX signals.
•     The command terminates normally but returns a non-zero exit status.
In all of these cases the shell will go on to execute the next command. Except for the last case an error
message will be printed by the shell. All remaining errors cause the shell to exit from a command pro-
cedure. An interactive shell will return to read another command from the terminal. Such errors include
the following.
                                                      - 19 -


•     Syntax errors. e.g., if . . . then . . . done
•     A signal such as interrupt. The shell waits for the current command, if any, to ﬁnish execution
      and then either exits or returns to the terminal.
•     Failure of any of the built-in commands such as cd.
The shell ﬂag −e causes the shell to terminate if any error is detected.
         1         hangup
         2         interrupt
         3*        quit
         4*        illegal instruction
         5*        trace trap
         6*        IOT instruction
         7*        EMT instruction
         8*        ﬂoating point exception
         9         kill (cannot be caught or ignored)
         10*       bus error
         11*       segmentation violation
         12*       bad argument to system call
         13        write on a pipe with no one to read it
         14        alarm clock
         15        software termination (from kill (1))


                                             Figure 3. UNIX signals

Those signals marked with an asterisk produce a core dump if not caught. However, the shell itself
ignores quit which is the only external signal that can cause a dump. The signals in this list of potential
interest to shell programs are 1, 2, 3, 14 and 15.

3.6 Fault handling
Shell procedures normally terminate when an interrupt is received from the terminal. The trap com-
mand is used if some cleaning up is required, such as removing temporary ﬁles. For example,
                   trap ´rm /tmp/ps$$; exit´ 2
sets a trap for signal 2 (terminal interrupt), and if this signal is received will execute the commands
                   rm /tmp/ps$$; exit
exit is another built-in command that terminates execution of a shell procedure. The exit is required;
otherwise, after the trap has been taken, the shell will resume executing the procedure at the place where
it was interrupted.
UNIX signals can be handled in one of three ways. They can be ignored, in which case the signal is
never sent to the process. They can be caught, in which case the process must decide what action to
take when the signal is received. Lastly, they can be left to cause termination of the process without it
having to take any further action. If a signal is being ignored on entry to the shell procedure, for exam-
ple, by invoking it in the background (see 3.7) then trap commands (and the signal) are ignored.
The use of trap is illustrated by this modiﬁed version of the touch command (Figure 4). The cleanup
action is to remove the ﬁle junk$$ .
                                                   - 20 -


                 ﬂag=
                 trap ´rm −f junk$$; exit´ 1 2 3 15
                 for i
                 do case $i in
                     −c) ﬂag=N ;;
                     *) if test −f $i
                          then      ln $i junk$$; rm junk$$
                          elif test $ﬂag
                          then      echo ﬁle \´$i\´ does not exist
                          else      >$i
                          ﬁ
                     esac
                 done


                                     Figure 4. The touch command

The trap command appears before the creation of the temporary ﬁle; otherwise it would be possible for
the process to die without removing the ﬁle.
Since there is no signal 0 in UNIX it is used by the shell to indicate the commands to be executed on
exit from the shell procedure.
A procedure may, itself, elect to ignore signals by specifying the null string as the argument to trap.
The following fragment is taken from the nohup command.
                 trap ´´ 1 2 3 15
which causes hangup, interrupt, quit and kill to be ignored both by the procedure and by invoked com-
mands.
Traps may be reset by saying
                 trap 2 3
which resets the traps for signals 2 and 3 to their default values. A list of the current values of traps
may be obtained by writing
                 trap

The procedure scan (Figure 5) is an example of the use of trap where there is no exit in the trap com-
mand. scan takes each directory in the current directory, prompts with its name, and then executes com-
mands typed at the terminal until an end of ﬁle or an interrupt is received. Interrupts are ignored while
executing the requested commands but cause termination when scan is waiting for input.
                 d=`pwd`
                 for i in *
                 do if test −d $d/$i
                    then cd $d/$i
                          while echo "$i:"
                                trap exit 2
                                read x
                          do trap : 2; eval $x; done
                    ﬁ
                 done


                                     Figure 5. The scan command

read x is a built-in command that reads one line from the standard input and places the result in the
                                                    - 21 -


variable x . It returns a non-zero exit status if either an end-of-ﬁle is read or an interrupt is received.

3.7 Command execution
To run a command (other than a built-in) the shell ﬁrst creates a new process using the system call fork.
The execution environment for the command includes input, output and the states of signals, and is esta-
blished in the child process before the command is executed. The built-in command exec is used in the
rare cases when no fork is required and simply replaces the shell with a new command. For example, a
simple version of the nohup command looks like
                  trap ´´ 1 2 3 15
                  exec $*
The trap turns off the signals speciﬁed so that they are ignored by subsequently created commands and
exec replaces the shell by the command speciﬁed.
Most forms of input output redirection have already been described. In the following word is only sub-
ject to parameter and command substitution. No ﬁle name generation or blank interpretation takes place
so that, for example,
                            echo . . . >*.c
will write its output into a ﬁle whose name is *.c . Input output speciﬁcations are evaluated left to right
as they appear in the command.
> word         The standard output (ﬁle descriptor 1) is sent to the ﬁle word which is created if it does
               not already exist.
> word
 >             The standard output is sent to ﬁle word. If the ﬁle exists then output is appended (by
               seeking to the end); otherwise the ﬁle is created.
< word         The standard input (ﬁle descriptor 0) is taken from the ﬁle word.
< word
 <             The standard input is taken from the lines of shell input that follow up to but not includ-
               ing a line consisting only of word. If word is quoted then no interpretation of the docu-
               ment occurs. If word is not quoted then parameter and command substitution occur and \
               is used to quote the characters \ $ ` and the ﬁrst character of word. In the latter case
               \newline is ignored (c.f. quoted strings).
>& digit       The ﬁle descriptor digit is duplicated using the system call dup (2) and the result is used
               as the standard output.
<& digit       The standard input is duplicated from ﬁle descriptor digit.
<&−            The standard input is closed.
>&−            The standard output is closed.
Any of the above may be preceded by a digit in which case the ﬁle descriptor created is that speciﬁed
by the digit instead of the default 0 or 1. For example,
                  . . . 2>ﬁle
runs a command with message output (ﬁle descriptor 2) directed to ﬁle.
                  . . . 2>&1
runs a command with its standard output and message output merged. (Strictly speaking ﬁle descriptor
2 is created by duplicating ﬁle descriptor 1 but the effect is usually to merge the two streams.)
The environment for a command run in the background such as
                  list *.c | lpr &
is modiﬁed in two ways. Firstly, the default standard input for such a command is the empty ﬁle
/dev/null . This prevents two processes (the shell and the command), which are running in parallel,
from trying to read the same input. Chaos would ensue if this were not the case. For example,
                                                    - 22 -


                  ed ﬁle &
would allow both the editor and the shell to read from the same input at the same time.
The other modiﬁcation to the environment of a background command is to turn off the QUIT and
INTERRUPT signals so that they are ignored by the command. This allows these signals to be used at
the terminal without causing background commands to terminate. For this reason the UNIX convention
for a signal is that if it is set to 1 (ignored) then it is never changed even for a short time. Note that the
shell command trap has no effect for an ignored signal.

3.8 Invoking the shell
The following ﬂags are interpreted by the shell when it is invoked. If the ﬁrst character of argument
zero is a minus, then commands are read from the ﬁle .proﬁle .
−c string
      If the −c ﬂag is present then commands are read from string .
−s    If the −s ﬂag is present or if no arguments remain then commands are read from the standard
      input. Shell output is written to ﬁle descriptor 2.
−i    If the −i ﬂag is present or if the shell input and output are attached to a terminal (as told by gtty)
      then this shell is interactive. In this case TERMINATE is ignored (so that kill 0 does not kill an
      interactive shell) and INTERRUPT is caught and ignored (so that wait is interruptable). In all
      cases QUIT is ignored by the shell.

Acknowledgements
The design of the shell is based in part on the original UNIX shell3 and the PWB/UNIX shell,4 some
features having been taken from both. Similarities also exist with the command interpreters of the Cam-
bridge Multiple Access System5 and of CTSS.6
I would like to thank Dennis Ritchie and John Mashey for many discussions during the design of the
shell. I am also grateful to the members of the Computing Science Research Center and to Joe Maran-
zano for their comments on drafts of this document.


References
1.    B. W. Kernighan, UNIX for Beginners, 1978.
2.    K. Thompson and D. M. Ritchie, UNIX Programmer’s Manual, Bell Laboratories (1978). Seventh
      Edition.
3.    K. Thompson, ‘‘The UNIX Command Language,’’ pp. 375-384 in Structured Programming—
      Infotech State of the Art Report, Infotech International Ltd., Nicholson House, Maidenhead,
      Berkshire, England (March 1975).
4.    J. R. Mashey, PWB/UNIX Shell Tutorial, September 30, 1977.
5.    D. F. Hartley (Ed.), The Cambridge Multiple Access System – Users Reference Manual, Univer-
      sity Mathematical Laboratory, Cambridge, England (1968).
6.    P. A. Crisman (Ed.), The Compatible Time-Sharing System, M.I.T. Press, Cambridge, Mass.
      (1965).
                                                - 23 -


Appendix A - Grammar

      item:            word
                       input-output
                       name = value

      simple-command: item
                     simple-command item

      command:         simple-command
                       ( command-list )
                       { command-list }
                       for name do command-list done
                       for name in word . . . do command-list done
                       while command-list do command-list done
                       until command-list do command-list done
                       case word in case-part . . . esac
                       if command-list then command-list else-part ﬁ

      pipeline:        command
                       pipeline | command

      andor:           pipeline
                       andor && pipeline
                       andor | | pipeline

      command-list:    andor
                       command-list   ;
                       command-list   &
                       command-list   ; andor
                       command-list   & andor

      input-output:    > ﬁle
                       < ﬁle
                       > word
                        >
                       < word
                        <

      ﬁle:             word
                       & digit
                       &−

      case-part:       pattern ) command-list ;;

      pattern:         word
                       pattern | word

      else-part:       elif command-list then command-list else-part
                       else command-list
                       empty

      empty:

      word:            a sequence of non-blank characters

      name:            a sequence of letters, digits or underscores starting with a letter

      digit:           0123456789
                                                    - 24 -


Appendix B - Meta-characters and Reserved Words
a) syntactic
      |        pipe symbol
      &&       ‘andf’ symbol
      ||       ‘orf’ symbol
      ;        command separator
      ;;       case delimiter
      &        background commands
      ()       command grouping
      <        input redirection
      <<       input from a here document
      >        output creation
      >>       output append


b) patterns
      *        match any character(s) including none
      ?        match any single character
      [...]    match any of the enclosed characters


c) substitution
      ${...} substitute shell variable
      `...`    substitute command output


d) quoting
      \        quote the next character
      ´...´    quote the enclosed characters except for ´
      "..."    quote the enclosed characters except for $ ` \ "


e) reserved words
           if then else elif ﬁ
           case in esac
           for while until do done
           { }
                        LEARN — Computer-Aided Instruction on UNIX
                                   (Second Edition)

                                                  Brian W. Kernighan
                                                    Michael E. Lesk
                                                   Bell Laboratories
                                             Murray Hill, New Jersey 07974


                                                      ABSTRACT
                 This paper describes the second version of the learn program for interpreting
          CAI scripts on the UNIX† operating system, and a set of scripts that provide a compu-
          terized introduction to the system.
                 Six current scripts cover basic commands and ﬁle handling, the editor, additional
          ﬁle handling commands, the eqn program for mathematical typing, the ‘‘– ms’’ package
          of formatting macros, and an introduction to the C programming language. These
          scripts now include a total of about 530 lessons.
                Many users from a wide variety of backgrounds have used learn to acquire basic
          UNIX skills. Most usage involves the ﬁrst two scripts, an introduction to UNIX ﬁles
          and commands, and the UNIX editor.
                 The second version of learn is about four times faster than the previous one in
          CPU utilization, and much faster in perceived time because of better overlap of com-
          puting and printing. It also requires less ﬁle space than the ﬁrst version. Many of the
          lessons have been revised; new material has been added to reﬂect changes and
          enhancements in UNIX itself. Script-writing is also easier because of revisions to the
          script language.



January 30, 1979




_
______________
†UNIX is a Trademark of Bell Laboratories.
                     LEARN — Computer-Aided Instruction on UNIX
                                (Second Edition)

                                           Brian W. Kernighan
                                             Michael E. Lesk
                                           Bell Laboratories
                                     Murray Hill, New Jersey 07974


1. Educational Assumptions and Design.
      First, the way to teach people how to do something is to have them do it. Scripts should not con-
tain long pieces of explanation; they should instead frequently ask the student to do some task. So
teaching is always by example: the typical script fragment shows a small example of some technique
and then asks the user to either repeat that example or produce a variation on it. All are intended to be
easy enough that most students will get most questions right, reinforcing the desired behavior.
       Most lessons fall into one of three types. The simplest presents a lesson and asks for a yes or no
answer to a question. The student is given a chance to experiment before replying. The script checks
for the correct reply. Problems of this form are sparingly used.
      The second type asks for a word or number as an answer. For example a lesson on ﬁles might
say
      How many ﬁles are there in the current directory? Type ‘‘answer N’’, where N is the number of
      ﬁles.
The student is expected to respond (perhaps after experimenting) with
      answer 17
or whatever. Surprisingly often, however, the idea of a substitutable argument (i.e., replacing N by 17)
is difﬁcult for non-programmer students, so the ﬁrst few such lessons need real care.
      The third type of lesson is open-ended — a task is set for the student, appropriate parts of the
input or output are monitored, and the student types ready when the task is done. Figure 1 shows a
sample dialog that illustrates the last of these, using two lessons about the cat (concatenate, i.e., print)
command taken from early in the script that teaches ﬁle handling. Most learn lessons are of this form.
      After each correct response the computer congratulates the student and indicates the lesson number
that has just been completed, permitting the student to restart the script after that lesson. If the answer
is wrong, the student is offered a chance to repeat the lesson. The ‘‘speed’’ rating of the student
(explained in section 5) is given after the lesson number when the lesson is completed successfully; it is
printed only for the aid of script authors checking out possible errors in the lessons.
       It is assumed that there is no foolproof way to determine if the student truly ‘‘understands’’ what
he or she is doing; accordingly, the current learn scripts only measure performance, not comprehension.
If the student can perform a given task, that is deemed to be ‘‘learning.’’1
       The main point of using the computer is that what the student does is checked for correctness
immediately. Unlike many CAI scripts, however, these scripts provide few facilities for dealing with
wrong answers. In practice, if most of the answers are not right the script is a failure; the universal
solution to student error is to provide a new, easier script. Anticipating possible wrong answers is an
endless job, and it is really easier as well as better to provide a simpler script.
      Along with this goes the assumption that anything can be taught to anybody if it can be broken
into sufﬁciently small pieces. Anything not absorbed in a single chunk is just subdivided.
                                                  -2-

                        _
                        ______________________________________________
                         Figure 1: Sample dialog from basic ﬁles script         
                                                                                
                         (Student responses in italics; ‘$’ is the prompt)      
                                                                                
                                                                                
                         A ﬁle can be printed on your terminal                  
                         by using the "cat" command. Just say                   
                         "cat ﬁle" where "ﬁle" is the ﬁle name.                 
                         For example, there is a ﬁle named                      
                                                                                
                         "food" in this directory. List it                      
                         by saying "cat food"; then type "ready".               
                         $ cat food                                             
                         this is the ﬁle                                        
                         named food.                                            
                                                                                
                         $ ready                                                
                                                                                
                         Good. Lesson 3.3a (1)                                  
                                                                                
                         Of course, you can print any ﬁle with "cat".           
                                                                                
                         In particular, it is common to ﬁrst use                
                         "ls" to ﬁnd the name of a ﬁle and then "cat"           
                         to print it. Note the difference between               
                         "ls", which tells you the name of the ﬁle,             
                         and "cat", which tells you the contents.               
                                                                                
                         One ﬁle in the current directory is named for          
                         a President. Print the ﬁle, then type "ready".         
                         $ cat President                                        
                         cat: can’t open President                              
                         $ ready                                                
                                                                                
                                                                                
                         Sorry, that’s not right. Do you want to try again? yes 
                         Try the problem again.                                 
                         $ ls                                                   
                         .ocopy                                                 
                                                                                
                         X1                                                     
                         roosevelt                                              
                         $ cat roosevelt                                        
                         this ﬁle is named roosevelt                            
                         and contains three lines of                            
                                                                                
                         text.                                                  
                         $ ready                                                
                                                                                
                         Good. Lesson 3.3b (0)                                  
                                                                                
                                                                                
                         The "cat" command can also print several ﬁles          
                         at once. In fact, it is named "cat" as an abbreviation 
                        
                        ______________________________________________
                        _
                         for "concatenate"....                                  

      To avoid boring the faster students, however, an effort is made in the ﬁles and editor scripts to
provide three tracks of different difﬁculty. The fastest sequence of lessons is aimed at roughly the bulk
and speed of a typical tutorial manual and should be adequate for review and for well-prepared students.
The next track is intended for most users and is roughly twice as long. Typically, for example, the fast
track might present an idea and ask for a variation on the example shown; the normal track will ﬁrst ask
the student to repeat the example that was shown before attempting a variation. The third and slowest
                                                    -3-


track, which is often three or four times the length of the fast track, is intended to be adequate for any-
one. (The lessons of Figure 1 are from the third track.) The multiple tracks also mean that a student
repeating a course is unlikely to hit the same series of lessons; this makes it proﬁtable for a shaky user
to back up and try again, and many students have done so.
       The tracks are not completely distinct, however. Depending on the number of correct answers the
student has given for the last few lessons, the program may switch tracks. The driver is actually capable
of following an arbitrary directed graph of lesson sequences, as discussed in section 5. Some more
structured arrangement, however, is used in all current scripts to aid the script writer in organizing the
material into lessons. It is sufﬁciently difﬁcult to write lessons that the three-track theory is not fol-
lowed very closely except in the ﬁles and editor scripts. Accordingly, in some cases, the fast track is
produced merely by skipping lessons from the slower track. In others, there is essentially only one
track.
     The main reason for using the learn program rather than simply writing the same material as a
workbook is not the selection of tracks, but actual hands-on experience. Learning by doing is much
more effective than pencil and paper exercises.
       Learn also provides a mechanical check on performance. The ﬁrst version in fact would not let
the student proceed unless it received correct answers to the questions it set and it would not tell a stu-
dent the right answer. This somewhat Draconian approach has been moderated in version 2. Lessons
are sometimes badly worded or even just plain wrong; in such cases, the student has no recourse. But if
a student is simply unable to complete one lesson, that should not prevent access to the rest. Accord-
ingly, the current version of learn allows the student to skip a lesson that he cannot pass; a ‘‘no’’
answer to the ‘‘Do you want to try again?’’ question in Figure 1 will pass to the next lesson. It is still
true that learn will not tell the student the right answer.
       Of course, there are valid objections to the assumptions above. In particular, some students may
object to not understanding what they are doing; and the procedure of smashing everything into small
pieces may provoke the retort ‘‘you can’t cross a ditch in two jumps.’’ Since writing CAI scripts is
considerably more tedious than ordinary manuals, however, it is safe to assume that there will always be
alternatives to the scripts as a way of learning. In fact, for a reference manual of 3 or 4 pages it would
not be surprising to have a tutorial manual of 20 pages and a (multi-track) script of 100 pages. Thus the
reference manual will exist long before the scripts.

2. Scripts.
      As mentioned above, the present scripts try at most to follow a three-track theory. Thus little of
the potential complexity of the possible directed graph is employed, since care must be taken in lesson
construction to see that every necessary fact is presented in every possible path through the units. In
addition, it is desirable that every unit have alternate successors to deal with student errors.
      In most existing courses, the ﬁrst few lessons are devoted to checking prerequisites. For example,
before the student is allowed to proceed through the editor script the script veriﬁes that the student
understands ﬁles and is able to type. It is felt that the sooner lack of student preparation is detected, the
easier it will be on the student. Anyone proceeding through the scripts should be getting mostly correct
answers; otherwise, the system will be unsatisfactory both because the wrong habits are being learned
and because the scripts make little effort to deal with wrong answers. Unprepared students should not
be encouraged to continue with scripts.
       There are some preliminary items which the student must know before any scripts can be tried. In
particular, the student must know how to connect to a UNIX† system, set the terminal properly, log in,
and execute simple commands (e.g., learn itself). In addition, the character erase and line kill conven-
tions (# and @) should be known. It is hard to see how this much could be taught by computer-aided
instruction, since a student who does not know these basic skills will not be able to run the learning pro-
gram. A brief description on paper is provided (see Appendix A), although assistance will be needed for
the ﬁrst few minutes. This assistance, however, need not be highly skilled.
__________________
†UNIX is a Trademark of Bell Laboratories.
                                                   -4-


      The ﬁrst script in the current set deals with ﬁles. It assumes the basic knowledge above and
teaches the student about the ls , cat , mv , rm , cp and diff commands. It also deals with the abbrevia-
tion characters *, ?, and [ ] in ﬁle names. It does not cover pipes or I/O redirection, nor does it present
the many options on the ls command.
      This script contains 31 lessons in the fast track; two are intended as prerequisite checks, seven are
review exercises. There are a total of 75 lessons in all three tracks, and the instructional passages typed
at the student to begin each lesson total 4,476 words. The average lesson thus begins with a 60-word
message. In general, the fast track lessons have somewhat longer introductions, and the slow tracks
somewhat shorter ones. The longest message is 144 words and the shortest 14.
       The second script trains students in the use of the UNIX context editor ed , a sophisticated editor
using regular expressions for searching.2 All editor features except encryption, mark names and ‘;’ in
addressing are covered. The fast track contains 2 prerequisite checks, 93 lessons, and a review lesson.
It is supplemented by 146 additional lessons in other tracks.
      A comparison of sizes may be of interest.      The ed description in the reference manual is 2,572
words long. The ed tutorial3 is 6,138 words long.    The fast track through the ed script is 7,407 words of
explanatory messages, and the total ed script, 242   lessons, has 15,615 words. The average ed lesson is
thus also about 60 words; the largest is 171 words   and the smallest 10. The original ed script represents
about three man-weeks of effort.
       The advanced ﬁle handling script deals with ls options, I/O diversion, pipes, and supporting pro-
grams like pr , wc , tail , spell and grep . (The basic ﬁle handling script is a prerequisite.) It is not as
reﬁned as the ﬁrst two scripts; this is reﬂected at least partly in the fact that it provides much less of a
full three-track sequence than they do. On the other hand, since it is perceived as ‘‘advanced,’’ it is
hoped that the student will have somewhat more sophistication and be better able to cope with it at a
reasonably high level of performance.
      A fourth script covers the eqn language for typing mathematics. This script must be run on a ter-
minal capable of printing mathematics, for instance the DASI 300 and similar Diablo-based terminals, or
the nearly extinct Model 37 teletype. Again, this script is relatively short of tracks: of 76 lessons, only
17 are in the second track and 2 in the third track. Most of these provide additional practice for stu-
dents who are having trouble in the ﬁrst track.
      The – ms script for formatting macros is a short one-track only script. The macro package it
describes is no longer the standard, so this script will undoubtedly be superseded in the future. Further-
more, the linear style of a single learn script is somewhat inappropriate for the macros, since the macro
package is composed of many independent features, and few users need all of them. It would be better
to have a selection of short lesson sequences dealing with the features independently.
      The script on C is in a state of transition. It was originally designed to follow a tutorial on C, but
that document has since become obsolete. The current script has been partially converted to follow the
order of presentation in The C Programming Language,4 but this job is not complete. The C script was
never intended to teach C; rather it is supposed to be a series of exercises for which the computer pro-
vides checking and (upon success) a suggested solution.
      This combination of scripts covers much of the material which any UNIX user will need to know to
make effective use of the system. With enlargement of the advanced ﬁles course to include more on the
command interpreter, there will be a relatively complete introduction to UNIX available via learn.
Although we make no pretense that learn will replace other instructional materials, it should provide a
useful supplement to existing tutorials and reference manuals.

3. Experience with Students.
       Learn has been installed on many different UNIX systems. Most of the usage is on the ﬁrst two
scripts, so these are more thoroughly debugged and polished. As a (random) sample of user experience,
the learn program has been used at Bell Labs at Indian Hill for 10,500 lessons in a four month period.
About 3600 of these are in the ﬁles script, 4100 in the editor, and 1400 in advanced ﬁles. The passing
rate is about 80%, that is, about 4 lessons are passed for every one failed. There have been 86 distinct
users of the ﬁles script, and 58 of the editor. On our system at Murray Hill, there have been nearly
                                                     -5-


2000 lessons over two weeks that include Christmas and New Year. Users have ranged in age from six
up.
       It is difﬁcult to characterize typical sessions with the scripts; many instances exist of someone
doing one or two lessons and then logging out, as do instances of someone pausing in a script for
twenty minutes or more. In the earlier version of learn , the average session in the ﬁles course took 32
minutes and covered 23 lessons. The distribution is quite broad and skewed, however; the longest ses-
sion was 130 minutes and there were ﬁve sessions shorter than ﬁve minutes. The average lesson took
about 80 seconds. These numbers are roughly typical for non-programmers; a UNIX expert can do the
scripts at approximately 30 seconds per lesson, most of which is the system printing.
      At present working through a section of the middle of the ﬁles script took about 1.4 seconds of
processor time per lesson, and a system expert typing quickly took 15 seconds of real time per lesson.
A novice would probably take at least a minute. Thus a UNIX system could support ten students work-
ing simultaneously with some spare capacity.

4. The Script Interpreter.
       The learn program itself merely interprets scripts. It provides facilities for the script writer to cap-
ture student responses and their effects, and simpliﬁes the job of passing control to and recovering con-
trol from the student. This section describes the operation and usage of the driver program, and indi-
cates what is required to produce a new script. Readers only interested in the existing scripts may skip
this section.
      The ﬁle structure used by learn is shown in Figure 2. There is one parent directory (named lib)
containing the script data. Within this directory are subdirectories, one for each subject in which a
course is available, one for logging (named log ), and one in which user sub-directories are created
(named play ). The subject directory contains master copies of all lessons, plus any supporting material
for that subject. In a given subdirectory, each lesson is a single text ﬁle. Lessons are usually named
systematically; the ﬁle that contains lesson n is called Ln .

                      ___________________________________________________
                               Figure 2: Directory structure for learn           
                                                                                 
                       lib                                                       
                                                                                 
                           play                                                  
                                            student1                             
                                                                                 
                                                         ﬁles for student1...    
                                            student2                             
                                                         ﬁles for student2...    
                                                                                 
                           ﬁles                                                  
                                            L0.1a        lessons for ﬁles course 
                                            L0.1b                                
                                            ...                                  
                                                                                 
                           editor                                                
                                            ...                                  
                                                                                 
                           (other courses)                                       
                                                                                 
                      __________________________________________________
                      _
                           log                                                   


      When learn is executed, it makes a private directory for the user to work in, within the learn por-
tion of the ﬁle system. A fresh copy of all the ﬁles used in each lesson (mostly data for the student to
operate upon) is made each time a student starts a lesson, so the script writer may assume that every-
thing is reinitialized each time a lesson is entered. The student directory is deleted after each session;
any permanent records must be kept elsewhere.
                                                      -6-


      The script writer must provide certain basic items in each lesson:
(1)   the text of the lesson;
(2)   the set-up commands to be executed before the user gets control;
(3)   the data, if any, which the user is supposed to edit, transform, or otherwise process;
(4)   the evaluating commands to be executed after the user has ﬁnished the lesson, to decide whether
      the answer is right; and
(5)   a list of possible successor lessons.
Learn tries to minimize the work of bookkeeping and installation, so that most of the effort involved in
script production is in planning lessons, writing tutorial paragraphs, and coding tests of student perfor-
mance.
       The basic sequence of events is as follows. First, learn creates the working directory. Then, for
each lesson, learn reads the script for the lesson and processes it a line at a time. The lines in the script
are: (1) commands to the script interpreter to print something, to create a ﬁles, to test something, etc.;
(2) text to be printed or put in a ﬁle; (3) other lines, which are sent to the shell to be executed. One line
in each lesson turns control over to the user; the user can run any UNIX commands. The user mode ter-
minates when the user types yes , no , ready , or answer . At this point, the user’s work is tested; if the
lesson is passed, a new lesson is selected, and if not the old one is repeated.
      Let us illustrate this with the script for the second lesson of Figure 1; this is shown in Figure 3.

                                _______________________________________
                                 Figure 3: Sample Lesson                        
                                                                                
                                 #print                                         
                                                                                
                                 Of course, you can print any ﬁle with "cat". 
                                 In particular, it is common to ﬁrst use        
                                 "ls" to ﬁnd the name of a ﬁle and then "cat" 
                                 to print it. Note the difference between       
                                 "ls", which tells you the name of the ﬁles,    
                                                                                
                                 and "cat", which tells you the contents.       
                                 One ﬁle in the current directory is named for 
                                 a President. Print the ﬁle, then type "ready". 
                                 #create roosevelt                              
                                 this ﬁle is named roosevelt                    
                                                                                
                                 and contains three lines of                    
                                 text.                                          
                                 #copyout                                       
                                 #user                                          
                                 #uncopyout                                     
                                                                                
                                 tail – 3 .ocopy >X1                            
                                 #cmp X1 roosevelt                              
                                 #log                                           
                                 #next                                          
                                 3.2b 2                                         
                                _______________________________________
                                


Lines which begin with # are commands to the learn script interpreter. For example,
      #print
causes printing of any text that follows, up to the next line that begins with a sharp.
      #print ﬁle
prints the contents of ﬁle ; it is the same as cat ﬁle but has less overhead. Both forms of #print have the
added property that if a lesson is failed, the #print will not be executed the second time through; this
                                                    -7-


avoids annoying the student by repeating the preamble to a lesson.
      #create ﬁlename
creates a ﬁle of the speciﬁed name, and copies any subsequent text up to a # to the ﬁle. This is used for
creating and initializing working ﬁles and reference data for the lessons.
      #user
gives control to the student; each line he or she types is passed to the shell for execution. The #user
mode is terminated when the student types one of yes , no , ready or answer . At that time, the driver
resumes interpretation of the script.
      #copyin
      #uncopyin
Anything the student types between these commands is copied onto a ﬁle called .copy. This lets the
script writer interrogate the student’s responses upon regaining control.
      #copyout
      #uncopyout
Between these commands, any material typed at the student by any program is copied to the ﬁle .ocopy.
This lets the script writer interrogate the effect of what the student typed, which true believers in the
performance theory of learning usually prefer to the student’s actual input.
      #pipe
      #unpipe
Normally the student input and the script commands are fed to the UNIX command interpreter (the
‘‘shell’’) one line at a time. This won’t do if, for example, a sequence of editor commands is provided,
since the input to the editor must be handed to the editor, not to the shell. Accordingly, the material
between #pipe and #unpipe commands is fed continuously through a pipe so that such sequences work.
If copyout is also desired the copyout brackets must include the pipe brackets.
      There are several commands for setting status after the student has attempted the lesson.
      #cmp ﬁle1 ﬁle2
is an in-line implementation of cmp , which compares two ﬁles for identity.
      #match stuff
The last line of the student’s input is compared to stuff , and the success or fail status is set according to
it. Extraneous things like the word answer are stripped before the comparison is made. There may be
several #match lines; this provides a convenient mechanism for handling multiple ‘‘right’’ answers.
Any text up to a # on subsequent lines after a successful #match is printed; this is illustrated in Figure
4, another sample lesson.
      #bad stuff
This is similar to #match , except that it corresponds to speciﬁc failure answers; this can be used to pro-
duce hints for particular wrong answers that have been anticipated by the script writer.
      #succeed
      #fail
print a message upon success or failure (as determined by some previous mechanism).
       When the student types one of the ‘‘commands’’ yes , no , ready , or answer , the driver terminates
the #user command, and evaluation of the student’s work can begin. This can be done either by the
built-in commands above, such as #match and #cmp , or by status returned by normal UNIX commands,
typically grep and test . The last command should return status true (0) if the task was done success-
fully and false (non-zero) otherwise; this status return tells the driver whether or not the student has suc-
cessfully passed the lesson.
      Performance can be logged:
      #log ﬁle
                                                   -8-



                     _
                     ____________________________________________________
                      Figure 4: Another Sample Lesson                   
                                                                        
                      #print                                            
                                                                        
                      What command will move the current line           
                      to the end of the ﬁle? Type                       
                      "answer COMMAND", where COMMAND is the command. 
                      #copyin                                           
                      #user                                             
                                                                        
                      #uncopyin                                         
                      #match m$                                         
                      #match .m$                                        
                      "m$" is easier.                                   
                      #log                                              
                                                                        
                      #next                                             
                     _63.1d 10
                     ____________________________________________________
                     

writes the date, lesson, user name and speed rating, and a success/failure indication on ﬁle. The com-
mand
      #log
by itself writes the logging information in the logging directory within the learn hierarchy, and is the
normal form.
      #next
is followed by a few lines, each with a successor lesson name and an optional speed rating on it. A typ-
ical set might read
      25.1a 10
      25.2a 5
      25.3a 2
indicating that unit 25.1a is a suitable follow-on lesson for students with a speed rating of 10 units,
25.2a for student with speed near 5, and 25.3a for speed near 2. Speed ratings are maintained for each
session with a student; the rating is increased by one each tiee the student gets a lesson right and
decreased by four each time the student gets a lesson wrong. Thus the driver tries to maintain a devel
such that the users get 80% right answers. The maximum rating is limited to 10 afd the minimum to 0.
The initial rating is zero unless the studeft speciﬁes a differeft rating when starting a session.
       If the student passes a lesson, a new lesson is sedected and the process repeats. If the student
fails, a false status is returned and the program reverts to the previous lesson and tries another alterna-
tive. If it can not ﬁnd another alternative, it skips forward a lesson. bye , bye, which causes a graceful
exit from the learn system. Hanging up is the usual novice’s way out.
       The lessons may form an arbitrary directed graph, although the present program imposes a limita-
tion on cycles in that it will not present a lesson twice in the same session. If the student is unable to
answer one of the exercises correctly, the driver searches for a previous lesson with a set of alternatives
as successors (following the #next line). From the previous lesson with alternatives one route was taken
earlier; the program simply tries a different one.
      It is perfectly possible to write sophisticated scripts that evaluate the student’s speed of response,
or try to estimate the elegance of the answer, or provide detailed analysis of wrong answers. Lesson
writing is so tedious already, however, that most of these abilities are likely to go unused.
       The driver program depends heavily on features of UNIX that are not available on many other
operating systems. These include the ease of manipulating ﬁles and directories, ﬁle redirection, the abil-
ity to use the command interpreter as just another program (even in a pipeline), command status testing
and branching, the ability to catch signals like interrupts, and of course the pipeline mechanism itself.
                                                          -9-


Although some parts of learn might be transferable to other systems, some generality will probably be
lost.
       A bit of history: The ﬁrst version of learn had fewer built-in words in the driver program, and
made more use of the facilities of UNIX. For example, ﬁle comparison was done by creating a cmp pro-
cess, rather than comparing the two ﬁles within learn . Lessons were not stored as text ﬁles, but as
archives. There was no concept of the in-line document; even #print had to be followed by a ﬁle name.
Thus the initialization for each lesson was to extract the archive into the working directory (typically 4-8
ﬁles), then #print the lesson text.
      The combination of such things made learn slower. The new version is about 4 or 5 times faster.
Furthermore, it appears even faster to the user because in a typical lesson, the printing of the message
comes ﬁrst, and ﬁle setup with #create can be overlapped with the printng, so that when the program
ﬁnishes printing, it is really ready for the user to type at it.
       It is also a great advantage to the script maintainer that lessons are now just ordinary text ﬁles.
They can be edited without any difﬁculty, and UNIX text manipulation tools can be applied to them. The
result has been that there is much less resistance to going in and ﬁxing substandard lessons.

5. Conclusions
     The following observations can be made about secretaries, typists, and other non-programmers
who have used learn :
(a)    A novice must have assistance with the mechanics of communicating with the computer to get
       through to the ﬁrst lesson or two; once the ﬁrst few lessons are passed people can proceed on their
       own.
(b)    The terminology used in the ﬁrst few lessons is obscure to those inexperienced with computers. It
       would help if there were a low level reference card for UNIX to supplement the existing program-
       mer oriented bulky manual and bulky reference card.
(c)    The concept of ‘‘substitutable argument’’ is hard to grasp, and requires help.
(d)    They enjoy the system for the most part. Motivation matters a great deal, however.
It takes an hour or two for a novice to get through the script on ﬁle handling. The total time for a rea-
sonably intelligent and motivated novice to proceed from ignorance to a reasonable ability to create new
ﬁles and manipulate old ones seems to be a few days, with perhaps half of each day spent on the
machine.
       The normal way of proceeding has been to have students in the same room with someone who
knows UNIX and the scripts. Thus the student is not brought to a halt by difﬁcult questions. The burden
on the counselor, however, is much lower than that on a teacher of a course. Ideally, the students
should be encouraged to proceed with instruction immediately prior to their actual use of the computer.
They should exercise the scripts on the same computer and the same kind of terminal that they will later
use for their real work, and their ﬁrst few jobs for the computer should be relatively easy ones. Also,
both training and initial work should take place on days when the UNIX hardware and software are work-
ing reliably. Rarely is all of this possible, but the closer one comes the better the result. For example,
if it is known that the hardware is shaky one day, it is better to attempt to reschedule training for
another one. Students are very frustrated by machine downtime; when nothing is happening, it takes
some sophistication and experience to distinguish an inﬁnite loop, a slow but functioning program, a
program waiting for the user, and a broken machine.*
      One disadvantage of training with learn is that students come to depend completely on the CAI
system, and do not try to read manuals or use other learning aids. This is unfortunate, not only because
of the increased demands for completeness and accuracy of the scripts, but because the scripts do not
cover all of the UNIX system. New users should have manuals (appropriate for their level) and read
them; the scripts ought to be altered to recommend suitable documents and urge students to read them.
__________________
* We have even known an expert programmer to decide the computer was broken when he had simply left his terminal
in local mode. Novices have great difﬁculties with such problems.
                                                    - 10 -


      There are several other difﬁculties which are clearly evident. From the student’s viewpoint, the
most serious is that lessons still crop up which simply can’t be passed. Sometimes this is due to poor
explanations, but just as often it is some error in the lesson itself — a botched setup, a missing ﬁle, an
invalid test for correctness, or some system facility that doesn’t work on the local system in the same
way it did on the development system. It takes knowledge and a certain healthy arrogance on the part
of the user to recognize that the fault is not his or hers, but the script writer’s. Permitting the student to
get on with the next lesson regardless does alleviate this somewhat, and the logging facilities make it
easy to watch for lessons that no one can pass, but it is still a problem.
       The biggest problem with the previous learn was speed (or lack thereof) — it was often excruciat-
ingly slow and made a signiﬁcant drain on the system. The current version so far does not seem to have
that difﬁculty, although some scripts, notably eqn , are intrinsically slow. eqn , for example, must do a
lot of work even to print its introductions, let alone check the student responses, but delay is perceptible
in all scripts from time to time.
      Another potential problem is that it is possible to break learn inadvertently, by pushing interrupt at
the wrong time, or by removing critical ﬁles, or any number of similar slips. The defenses against such
problems have steadily been improved, to the point where most students should not notice difﬁculties.
Of course, it will always be possible to break learn maliciously, but this is not likely to be a problem.
      One area is more fundamental — some UNIX commands are sufﬁciently global in their effect that
learn currently does not allow them to be executed at all. The most obvious is cd , which changes to
another directory. The prospect of a student who is learning about directories inadvertently moving to
some random directory and removing ﬁles has deterred us from even writing lessons on cd , but ulti-
mately lessons on such topics probably should be added.

6. Acknowledgments
      We are grateful to all those who have tried learn, for we have beneﬁted greatly from their sugges-
tions and criticisms. In particular, M. E. Bittrich, J. L. Blue, S. I. Feldman, P. A. Fox, and M. J. McAl-
pin have provided substantial feedback. Conversations with E. Z. Rothkopf also provided many of the
ideas in the system. We are also indebted to Don Jackowski for serving as a guinea pig for the second
version, and to Tom Plum for his efforts to improve the C script.

References
1.    B. F. Skinner, ‘‘Why We Need Teaching Machines,’’ Harvard Educational Review 31, pp.377-398
      (1961).
2.    K. Thompson and D. M. Ritchie, UNIX Programmer’s Manual, Bell Laboratories (May 1975). See
      section ed (I).
3.    B. W. Kernighan, A Tutorial Introduction to the Unix Editor ed, 1974.
4.    B. W. Kernighan and D. M. Ritchie, The C Programming Language, Prentice Hall (1978).
                       Typing Documents on the UNIX System:
                      Using the – ms Macros with Troff and Nroff

                                             M. E. Lesk
                                        Bell Laboratories
                                  Murray Hill, New Jersey 07974



                                            ABSTRACT

            This document describes a set of easy-to-use macros for preparing documents on
       the UNIX system. Documents may be produced on either the phototypesetter or a on a
       computer terminal, without changing the input.
             The macros provide facilities for paragraphs, sections (optionally with automatic
       numbering), page titles, footnotes, equations, tables, two-column format, and cover
       pages for papers.
            This memo includes, as an appendix, the text of the ‘‘Guide to Preparing Docu-
       ments with – ms’’ which contains additional examples of features of – ms.
             This manual is a revision of, and replaces, ‘‘Typing Documents on UNIX,’’
       dated November 22, 1974.



November 13, 1978
                           Typing Documents on the UNIX System:
                          Using the – ms Macros with Troff and Nroff

                                                  M . E . L es k
                                                  M. E. Le sk
                                             Bell Laboratories
                                       Murray Hill, New Jersey 07974

       Introduction. This memorandum describes a package of commands to produce papers using the
troff and nroff formatting programs on the UNIX system. As with other roff -derived programs, text is
prepared interspersed with formatting commands. However, this package, which itself is written in troff
commands, provides higher-level commands than those provided with the basic troff program. The
commands available in this package are listed in Appendix A.
      T ex t. Type normally, except that instead of indenting for paragraphs, place a line reading ‘‘.PP’’
      Te xt .
before each paragraph. This will produce indenting and extra space.
Alternatively, the command .LP that was used here will produce a left-aligned (block) paragraph. The
paragraph spacing can be changed: see below under ‘‘Registers.’’
      B eg in ni ng . For a document with a paper-type cover sheet, the input should start as follows:
      Be gi nn in g.
         [optional overall format .RP – see below]
         .TL
         Title of document (one or more lines)
         .AU
         Author(s) (may also be several lines)
         .AI
         Author’s institution(s)
         .AB
         Abstract; to be placed on the cover sheet of a paper.
         Line length is 5/6 of normal; use .ll here to change.
         .AE (abstract end)
         text ... (begins with .PP, which see)
To omit some of the standard headings (e.g. no abstract, or no author’s institution) just omit the
corresponding ﬁelds and command lines. The word ABSTRACT can be suppressed by writing ‘‘.AB no’’
for ‘‘.AB’’. Several interspersed .AU and .AI lines can be used for multiple authors. The headings are
not compulsory: beginning with a .PP command is perfectly OK and will just start printing an ordinary
paragraph. W ar ni ng : You can’t just begin a document with a line of text. Some – ms command must
              Wa rn in g:
precede any text input. When in doubt, use .LP to get proper initialization, although any of the com-
mands .PP, .LP, .TL, .SH, .NH is good enough. Figure 1 shows the legal arrangement of commands at
the start of a document.
      C ov er S he et s a nd F ir st P ag es . The ﬁrst line of a document signals the general format of the ﬁrst
      Co ve r Sh ee ts an d Fi rs t Pa ge s.
page. In particular, if it is ".RP" a cover sheet with title and abstract is prepared. The default format is
useful for scanning drafts.
      In general – ms is arranged so that only one form of a document need be stored, containing all
information; the ﬁrst command gives the format, and unnecessary items for that format are ignored.
       Warning: don’t put extraneous material between the .TL and .AE commands. Processing of the
titling items is special, and other data placed in them may not behave as you expect. Don’t forget that
some – ms command must precede any input text.
       P ag e h ea di ng s. The – ms macros, by default, will print a page heading containing a page number
       Pa ge he ad in gs .
(if greater than 1). A default page footer is provided only in n ro ff , where the date is used. The user
                                                                     nr of f
                                                          -2-


can make minor adjustments to the page headings/footings by redeﬁning the strings LH, CH, and RH
which are the left, center and right portions of the page headings, respectively; and the strings LF, CF,
and RF, which are the left, center and right portions of the page footer. For more complex formats, the
user can redeﬁne the macros PT and BT, which are invoked respectively at the top and bottom of each
page. The margins (taken from registers HM and FM for the top and bottom margin respectively) are
normally 1 inch; the page header/footer are in the middle of that space. The user who redeﬁnes these
macros should be careful not to change parameters such as point size or font without resetting them to
default values.
       M ul ti -c ol um n f or ma ts . If you place the
       Mu lt i- co lu mn fo rm at s.                                  The .NH command also supports more
command ‘‘.2C’’ in your document, the docu-                     complex numbering schemes. If a numerical
ment will be printed in double column format                    argument is given, it is taken to be a ‘‘level’’
beginning at that point. This feature is not too                number and an appropriate sub-section number
useful in computer terminal output, but is often                is generated. Larger level numbers indicate
desirable on the typesetter. The command                        deeper sub-sections, as in this example:
‘‘.1C’’ will go back to one-column format and
                                                                         .NH
also skip to a new page. The ‘‘.2C’’ command
                                                                         Erie-Lackawanna
is actually a special case of the command
                                                                         .NH 2
         .MC [column width [gutter width]]                               Morris and Essex Division
                                                                         .NH 3
which makes multiple columns with the
                                                                         Gladstone Branch
speciﬁed column and gutter width; as many
                                                                         .NH 3
columns as will ﬁt across the page are used.
                                                                         Montclair Branch
Thus triple, quadruple, ... column pages can be
                                                                         .NH 2
printed. Whenever the number of columns is
                                                                         Boonton Line
changed (except going from full width to some
larger number of columns) a new page is started.                generates:
      H ea di ng s. To produce a special heading,
      He ad in gs .
there are two commands. If you type                             2. Erie-Lackawanna

         .NH                                                    2.1. Morris and Essex Division
         type section heading here
         may be several lines                                   2.1.1. Gladstone Branch
you will get automatically numbered section
headings (1, 2, 3, ...), in boldface. For example,              2.1.2. Montclair Branch

   .NH                                                          2.2. Boonton Line
   Care and Feeding of Department Heads
                                                                     An explicit ‘‘.NH 0’’ will reset the
produces                                                        numbering of level 1 to one, as here:
                                                                         .NH 0
1. Care and Feeding of Department Heads
                                                                         Penn Central
      Alternatively,
         .SH                                                    1. Penn Central
         Care and Feeding of Directors
                                                                      I nd en te d p ar ag ra ph s. (Paragraphs with
                                                                      In de nt ed pa ra gr ap hs .
will print the heading with no number added:                    hanging numbers, e.g. references.)              The
                                                                sequence
Care and Feeding of Directors
                                                                         .IP [1]
      Every section heading, of either type,                             Text for ﬁrst paragraph, typed
should be followed by a paragraph beginning                              normally for as long as you would
with .PP or .LP, indicating the end of the head-                         like on as many lines as needed.
ing. Headings may contain more than one line                             .IP [2]
of text.                                                                 Text for second paragraph, ...
                                                                produces
                                                      -3-


[1]     Text for ﬁrst paragraph, typed normally
                                                                     .IP 1.
        for as long as you would like on as many
                                                                     Bell Laboratories
        lines as needed.
                                                                     .RS
[2]     Text for second paragraph, ...                               .IP 1.1
A series of indented paragraphs may be followed                      Murray Hill
by an ordinary paragraph beginning with .PP or                       .IP 1.2
.LP, depending on whether you wish indenting                         Holmdel
or not. The command .LP was used here.                               .IP 1.3
      More sophisticated uses of .IP are also                        Whippany
possible. If the label is omitted, for example, a                    .RS
plain block indent is produced.                                      .IP 1.3.1
                                                                     Madison
          .IP                                                        .RE
          This material will                                         .IP 1.4
          just be turned into a                                      Chester
          block indent suitable for quotations or                    .RE
          such matter.                                               .LP
          .LP
                                                            will result in
will produce                                                1.    Bell Laboratories
        This material will just be turned into a                  1.1    Murray Hill
        block indent suitable for quotations or
        such matter.                                              1.2    Holmdel
If a non-standard amount of indenting is                          1.3    Whippany
required, it may be speciﬁed after the label (in                         1.3.1 Madison
character positions) and will remain in effect                    1.4    Chester
until the next .PP or .LP. Thus, the general
form of the .IP command contains two addi-                  All of these variations on .LP leave the right
tional ﬁelds: the label and the indenting length.           margin untouched. Sometimes, for purposes
For example,                                                such as setting off a quotation, a paragraph
                                                            indented on both right and left is required.
          .IP ﬁrst: 9                                             A single paragraph like this is
          Notice the longer label, requiring larger               obtained by preceding it with .QP.
          indenting for these paragraphs.                         More complicated material (several
          .IP second:                                             paragraphs) should be bracketed
          And so forth.                                           with .QS and .QE.
          .LP
                                                            E mp ha si s. To get italics (on the typesetter) or
                                                            Em ph as is .
produces this:                                              underlining (on the terminal) say
ﬁrst:       Notice the longer label, requiring                       .I
            larger indenting for these paragraphs.                   as much text as you want
second:     And so forth.                                            can be typed here
It is also possible to produce multiple nested                       .R
indents; the command .RS indicates that the next            as was done for these three words. The .R com-
.IP starts from the current indentation level.              mand restores the normal (usually Roman) font.
Each .RE will eat up one level of indenting so              If only one word is to be italicized, it may be
you should balance .RS and .RE commands.                    just given on the line with the .I command,
The .RS command should be thought of as
‘‘move right’’ and the .RE command as ‘‘move                                  .I word
left’’. As an example                                       and in this case no .R is needed to restore the
                                                            previous font. Boldface can be produced by
                                                       -4-


          .B                                                 these lines were preceded
          Text to be set in boldface                         by .DS L and followed by
          goes here                                          a .DE command.
          .R
                                                             Note that .DS C centers each line; there is a
and also will be underlined on the terminal or               variant .DS B that makes the display into a left-
line printer. As with .I, a single word can be               adjusted block of text, and then centers that
placed in boldface by placing it on the same line            entire block. Normally a display is kept
as the .B command.                                           together, on one page. If you wish to have a
      A few size changes can be speciﬁed simi-               long display which may be split across page
larly with the commands .LG (make larger), .SM               boundaries, use .CD, .LD, or .ID in place of the
(make smaller), and .NL (return to normal size).             commands .DS C, .DS L, or .DS I respectively.
The size change is two points; the commands                  An extra argument to the .DS I or .DS command
may be repeated for increased effect (here one .NL           is taken as an amount to indent. Note: it is
canceled two .SM commands).                                  tempting to assume that .DS R will right adjust
                                                             lines, but it doesn’t work.
       If actual _
                 _________
                 underlining as opposed to italiciz-
ing is required on the typesetter, the command                     B ox in g w or ds o r l in es . To draw rec-
                                                                   Bo xi ng wo rd s or li ne s.
                                                             tangular boxes around words the command
                  .UL word
                                                                       .BX word
will underline a word. There is no way to
underline multiple words on the typesetter.                  will print   as shown. The boxes will not
                                                                         _____
                                                                         
                                                                         
                                                                         word
                                                             be neat on a terminal, and this should not be
      F oo tn ot es . Material placed between lines
      Fo ot no te s.                                         _
                                                             __________________________________________
                                                             used as a substitute for italics.
with the commands .FS (footnote) and .FE (foot-               Longer pieces of text may be boxed by enclos- 
                                                             
note end) will be collected, remembered, and
                                                              ing them with .B1 and .B2:                    
ﬁnally placed at the bottom of the current page*.                                                           
By default, footnotes are 11/12th the length of                        .B1                                  
normal text, but this can be changed using the                         text...                              
                                                                       .B2                                  
FL register (see below).                                                                                     
                                                             
       D is pl ay s a nd T ab le s.
       Di sp la ys an d Ta bl es .  To prepare               __________________________________________
                                                             _as has been done here.
                                                                                                            
displays of lines, such as tables, in which the
                                                                    K ee pi ng b lo ck s t og et he r. If you wish to
                                                                    Ke ep in g bl oc ks to ge th er .
lines should not be re-arranged, enclose them in
                                                             keep a table or other block of lines together on a
the commands .DS and .DE
                                                             page, there are ‘‘keep - release’’ commands. If
          .DS                                                a block of lines preceded by .KS and followed
          table lines, like the                              by .KE does not ﬁt on the remainder of the
          examples here, are placed                          current page, it will begin on a new page. Lines
          between .DS and .DE                                bracketed by .DS and .DE commands are
          .DE                                                automatically kept together this way. There is
                                                             also a ‘‘keep ﬂoating’’ command: if the block to
By default, lines between .DS and .DE are
                                                             be kept together is preceded by .KF instead of
indented and left-adjusted. You can also center
                                                             .KS and does not ﬁt on the current page, it will
lines, or retain the left margin. Lines bracketed
                                                             be moved down through the text until the top of
by .DS C and .DE commands are centered (and
                                                             the next page. Thus, no large blank space will
not re-arranged); lines bracketed by .DS L and
                                                             be introduced in the document.
.DE are left-adjusted, not indented, and not re-
arranged. A plain .DS is equivalent to .DS I,                      N ro ff /T ro ff c om ma nd s. Among the useful
                                                                   Nr of f/ Tr of f co mm an ds .
which indents and left-adjusts. Thus,                        commands from the basic formatting programs
                                                             are the following. They all work with both
            these lines were preceded                        typesetter and computer terminal output:
            by .DS C and followed by
                 a .DE command;
whereas
__________________
* Like this.
                                                      -5-


                                                            permit changing its output style. For more com-
           .bp - begin new page.
                                                            plicated headers and footers the macros PT and
           .br - ‘‘break’’, stop running text
                                                            BT can be redeﬁned, as explained earlier.
                    from line to line.
           .sp n - insert n blank lines.                           A cc en ts . To simplify typing certain
                                                                   Ac ce nt s.
           .na - don’t adjust right margins.                foreign words, strings representing common
                                                            accent marks are deﬁned. They precede the
      D at e. By default, documents produced on
      Da te .                                               letter over which the mark is to appear. Here
computer terminals have the date at the bottom              are the strings:
of each page; documents produced on the
                                                                  Input     Output           Input     Output
typesetter don’t. To force the date, say ‘‘.DA’’.
                                                                   \*′e       e´              \*˜a       a
                                                                                                         ˜
To force no date, say ‘‘.ND’’. To lie about the                                                           v
                                                                   \*`e       e`             \*Ce        e
date, say ‘‘.DA July 4, 1776’’ which puts the                                 ..
                                                                   \*:u       u               \*,c       c
                                                                                                         ,
speciﬁed date at the bottom of each page. The
                                                                   \*ˆe       e
                                                                              ˆ
command
           .ND May 8, 1945                                        U se . After your document is prepared and
                                                                  Us e.
                                                            stored on a ﬁle, you can print it on a terminal
in ".RP" format places the speciﬁed date on the             with the command*
cover sheet and nowhere else. Place this line
before the title.                                             nroff – ms ﬁle
      S ig na tu re l in e. You can obtain a signa-
      Si gn at ur e li ne .                                 and you can print it on the typesetter with the
ture line by placing the command .SG in the                 command
document. The authors’ names will be output in
                                                              troff – ms ﬁle
place of the .SG line. An argument to .SG is
used as a typing identiﬁcation line, and placed             (many options are possible). In each case, if
after the signatures. The .SG command is                    your document is stored in several ﬁles, just list
ignored in released paper format.                           all the ﬁlenames where we have used ‘‘ﬁle’’. If
      R eg is te rs . Certain of the registers used
      Re gi st er s.                                        equations or tables are used, eqn and/or tbl must
by – ms can be altered to change default set-               be invoked as preprocessors.
tings. They should be changed with .nr com-                       R ef er en ce s a nd f ur th er s tu dy . If you
                                                                  Re fe re nc es an d fu rt he r st ud y.
mands, as with                                              have to do Greek or mathematics, see e qn [1]   eq n
                                                            for equation setting. To aid e qn users, – m s
                                                                                                 eq n            ms
                    .nr PS 9
                                                            provides deﬁnitions of .EQ and .EN which nor-
to make the default point size 9 point. If the              mally center the equation and set it off slightly.
effect is needed immediately, the normal troff              An argument on .EQ is taken to be an equation
command should be used in addition to chang-                number and placed in the right margin near the
ing the number register.                                    equation. In addition, there are three special
Register     Deﬁnes           Takes       Default           arguments to EQ: the letters C, I, and L indi-
                              effect                        cate centered (default), indented, and left
 PS     point size          next para.   10                 adjusted equations, respectively. If there is both
 VS     line spacing        next para.   12 pts             a format argument and an equation number, give
 LL     line length         next para.   6′′
 LT     title length        next para.   6′′
                                                            the format argument ﬁrst, as in
 PD     para. spacing       next para.   0.3 VS                                 .EQ L (1.3a)
 PI     para. indent        next para.   5 ens
 FL     footnote length     next FS      11/12 LL           for a left-adjusted equation numbered (1.3a).
 CW     column width        next 2C      7/15 LL
 GW     intercolumn gap     next 2C      1/15 LL                   Similarly, the macros .TS and .TE are
 PO     page offset         next page    26/27′′            deﬁned to separate tables (see [2]) from text
 HM     top margin          next page    1′′                with a little space. A very long table with a
 FM     bottom margin       next page    1′′                heading may be broken across pages by begin-
You may also alter the strings LH, CH, and RH               ning it with .TS H instead of .TS, and placing
which are the left, center, and right headings              the line .TH in the table data after the heading.
                                                            __________________
respectively; and similarly LF, CF, and RF
                                                            * If .2C was used, pipe the nroff output through col;
which are strings in the page footer. The page              make the ﬁrst line of the input ‘‘.pi /usr/bin/col.’’
number on output is taken from register PN, to
                                                     -6-


If the table has no heading repeated from page
to page, just use the ordinary .TS and .TE mac-
ros.
       To learn more about troff see [3] for a
general introduction, and [4] for the full details
(experts only). Information on related UNIX
commands is in [5]. For jobs that do not seem
well-adapted to – ms, consider other macro pack-
ages. It is often far easier to write a speciﬁc
macro packages for such tasks as imitating par-
ticular journals than to try to adapt – ms.
       A ck no wl ed gm en t. Many thanks are due
       Ac kn ow le dg me nt .
to Brian Kernighan for his help in the design
and implementation of this package, and for his
assistance in preparing this manual.

                   References
[1]   B. W. Kernighan and L. L. Cherry,
      Typesetting Mathematics — Users Guide
      (2nd edition), Bell Laboratories Comput-
      ing Science Report no. 17.
[2]   M. E. Lesk, Tbl — A Program to Format
      Tables, Bell Laboratories Computing Sci-
      ence Report no. 45.
[3]   B. W. Kernighan, A Troff Tutorial, Bell
      Laboratories, 1976.
[4]   J. F. Ossanna, Nroff /Troff Reference
      Manual, Bell Laboratories Computing Sci-
      ence Report no. 51.
[5]   K. Thompson and D. M. Ritchie, UNIX
      Programmer’s Manual, Bell Laboratories,
      1978.
                                                 -7-


                                              Appendix A
                                           List of Commands
1C      Return to single column format.                LG         Increase type size.
2C      Start double column format.                    LP         Left aligned block paragraph.
AB      Begin abstract.
AE      End abstract.
AI      Specify author’s institution.
AU      Specify author.                                ND         Change or cancel date.
B       Begin boldface.                                NH         Specify numbered heading.
DA      Provide the date on each page.                 NL         Return to normal type size.
DE      End display.                                   PP         Begin paragraph.
DS      Start display (also CD, LD, ID).
EN      End equation.                                  R          Return to regular font (usually Roman).
EQ      Begin equation.                                RE         End one level of relative indenting.
FE      End footnote.                                  RP         Use released paper format.
FS      Begin footnote.                                RS         Relative indent increased one level.
                                                       SG         Insert signature line.
I       Begin italics.                                 SH         Specify section heading.
                                                       SM         Change to smaller type size.
IP      Begin indented paragraph.                      TL         Specify title.
KE      Release keep.
KF      Begin ﬂoating keep.                            UL         Underline one word.
KS      Start keep.


                                            Register Names
      The following register names are used by – ms internally. Independent use of these names in
one’s own macros may produce incorrect output. Note that no lower case letters are used in any – ms
internal name.
                                    Number registers used in – ms
:        DW         GW        HM       IQ        LL         NA          OJ        PO        T.       TV
#T       EF         H1        HT       IR        LT         NC          PD        PQ        TB       VS
1T       FL         H3        IK       KI        MM         NF          PF        PX        TD       YE
AV       FM         H4        IM       L1        MN         NS          PI        RO        TN       YY
CW       FP         H5        IP       LE        MO         OI          PN        ST        TQ       ZN


                                    String registers used   in – ms
′       A5        CB        DW        EZ         I           KF       MR         R1       RT        TL
`       AB        CC        DY        FA         I1          KQ       ND         R2       S0        TM
ˆ       AE        CD        E1        FE         I2          KS       NH         R3       S1        TQ
˜       AI        CF        E2        FJ         I3          LB       NL         R4       S2        TS
:       AU        CH        E3        FK         I4          LD       NP         R5       SG        TT
,       B         CM        E4        FN         I5          LG       OD         RC       SH        UL
1C      BG        CS        E5        FO         ID          LP       OK         RE       SM        WB
2C      BT        CT        EE        FQ         IE          ME       PP         RF       SN        WH
A1      C         D         EL        FS         IM          MF       PT         RH       SY        WT
A2      C1        DA        EM        FV         IP          MH       PY         RP       TA        XD
A3      C2        DE        EN        FY         IZ          MN       QF         RQ       TE        XF
A4      CA        DS        EQ        HO         KE          MO       R          RS       TH        XK
                         -8-




     RP




TL


AU


AI




     AB


     AE




          NH, SH




                   PP, LP


                   text ...




              Figure 1
                                                                                                   2

                                                                                  C om ma nd s f or a T M
                                                                                  Co mm an ds fo r TM
                                                                .TM 1978-5b3 99999 99999-11
                                                                .ND April 1, 1976
                                                                .TL
           A Guide to Preparing                                 The Role of the Allen Wrench in Modern
                                                                Electronics
           Documents with – ms                                  .AU "MH 2G-111" 2345
                                                                J. Q. Pencilpusher
                                                                .AU "MH 1K-222" 5432
                                                                X. Y. Hardwired
                    M. E. Lesk                                  .AI
                                                                .MH
Bell Laboratories                         August 1978           .OK
                                                                Tools
_
___________________________________________                     Design
                                                                .AB
This guide gives some simple examples of                        This abstract should be short enough to
document preparation on Bell Labs computers,                    ﬁt on a single page cover sheet.
                                                                It must attract the reader into sending for
emphasizing the use of the – ms macro package. It
                             ms
                                                                the complete memorandum.
enormously abbreviates information in                           .AE
1. Typing Documents on UNIX and GCOS, by
    Typing Documents on UNIX and GCOS,                          .CS 10 2 12 5 6 7
    M. E. Lesk;                                                 .NH
2. Typesetting Mathematics – User’s Guide, by
    Typesetting Mathematics      User’s Guide,                  Introduction.
    B. W. Kernighan and L. L. Cherry; and                       .PP
3. Tbl – A Program to Format Tables, by M. E.
    Tbl      Program to Format Tables,                          Now the ﬁrst paragraph of actual text ...
    Lesk.                                                       ...
These memos are all included in the UNIX    UNIX                Last line of text.
Programmer’s Manual, Volume 2. The new user
Programmer’s Manual, Volume 2.                                  .SG MH-1234-JQP/XYH-unix
                                                                .NH
should also have A Tutorial Introduction to the
                     Tutorial Introduction to the
                                                                References ...
UNIX Text Editor, by B. W. Kernighan.
UNIX Text Editor,
For more detailed information, read Advanced
                                          Advanced              Commands not needed in a particular format are ignored.
                                                              ____________________________________________________________________________
Editing on UNIX and A Troff Tutorial, by B. W.
Editing on UNIX          Troff Tutorial,                                                                                                  
Kernighan, and (for experts) Nroff /Troff Reference
                             Nroff /Troff Reference                                                                                       
                                                                                                                                          
Manual by J. F. Ossanna. Information on related
Manual                                                                      Bell Laboratories      Cover Sheet for TM                     
                                                                                                                                          
commands is found (for UNIX users) in UNIX for
                                          UNIX for                                                                                        
                                                               ________________________________________________________________________ 
Beginners by B. W. Kernighan and the UNIX
Beginners                                     UNIX             This information is for employees of Bell Laboratories. (GEI 13.9-3) 
                                                               ________________________________________________________________________ 
Programmer’s Manual by K. Thompson and D. M.
Programmer’s Manual                                                                                                                       
Ritchie.                                                                                                                                  
                                                               Title- The Role of the Allen Wrenc h
                                                                        The Role of the Allen Wrench              Date- April 1, 1976 
                                                                                                                        April 1, 1976
                                                                                                                                          
                                                                       in Modern Electronics
                                                                        in Modern Electronics                                              
                                                                                                                 TM- 1978-5b3
                                                                                                                        1978-5b3           
                     Contents                                                                                                             
                                                               Other Keywords- T ools
                                                                                   Tools                                                   
                                                                                  Design
                                                                                   Design                                                  
   A TM . . . . . . . . . . . . . . . .   .   .   .   .   2                                                                               
                                                                                                                                          
   A released paper . . . . . . . . . .   .   .   .   .   3                                                                               
                                                                                                                                          
   An internal memo, and headings .       .   .   .   .   4                                                                               
                                                               Author                     Location      Ext. Charging Case- 99999         
   Lists, displays, and footnotes . . .   .   .   .   .   5    J . Q . Pencilp usher
                                                                J. Q. Pencilpusher         MH 2G-111 2345 Filing Case- 99999a
                                                                                           MH 2G-111 2345                                  
                                                                                                                                          
   Indents, keeps, and double column      .   .   .   .   6     X. Y. Hardwired
                                                               X . Y . Har dwired         MH 1K-222 5432
                                                                                           MH 1K-222 5432                                  
                                                                                                                                          
   Equations and registers . . . . . .    .   .   .   .   7                                                                               
                                                                                                                                          
                                                                                              ABSTRACT                                    
   Tables and usage . . . . . . . . . .   .   .   .   .   8                                                                               
                                                                                                                                          
                                                                            This abstract should be short enough to ﬁt                    
Throughout the examples, input is shown in                             on a single page cover sheet. It must attract the                  
                                                                                                                                          
                                                                       reader into sending for the complete memoran-                      
  this Helvetica sans serif font                                       dum.                                                               
while the resulting output is shown in                                                                                                    
                                                                                                                                          
  this Times Roman font.                                                                                                                  
                                                                                                                                          
                                                                                                                                          
                                                                                                                                          
                                                               ______________________________________________________ 
                                                                                                                                         
            UNIX Document no. 1111                             Pages Text 10          Other 2             Total 12                       
                                                                                                                                         
                                                                                                                                          
                                                               No. Figures 5          No. Tables 6        No. Refs. 7                    
                                                               ______________________________________________________          
                                                              
                                                               E-1932-U (6-73)                SEE REVERSE SIDE FOR DISTRIBUTION LIST     
                                                                                                                                          
                                                              
                                                              ____________________________________________________________________________
                                                              
                                3                                                                        4


      A R el ea se d P ap er w it h M at he ma ti cs
        Re le as ed Pa pe r wi th Ma th em at ic s                                    An I nt er na l M em or an du m
                                                                                      An In te rn al Me mo ra nd um
  .EQ                                                                    .IM
  delim $$                                                               .ND January 24, 1956
  .EN                                                                    .TL
  .RP                                                                    The 1956 Consent Decree
                                                                         .AU
  ... (as for a TM)                                                      Able, Baker &
                                                                         Charley, Attys.
  .CS 10 2 12 5 6 7                                                      .PP
  .NH                                                                    Plaintiff, United States of America, having ﬁled
  Introduction                                                           its complaint herein on January 14, 1949; the
  .PP                                                                    defendants having appeared and ﬁled their
  The solution to the torque handle equation                             answer to such complaint denying the
  .EQ (1)                                                                substantive allegations thereof; and the parties,
  sum from 0 to inf F ( x sub i ) = G ( x )                              by their attorneys, ...
  .EN                                                                  __________________________________________________________
  is found with the transformation $ x = rho over                                                                                            
  theta $ where $ rho = G prime (x) $ and $theta$                                                                                            
                                                                                                                                             
  is derived ...                                                                                                                             
                                                                                                                       B el l Labor ator ies
                                                                                                                        Be ll Labora to ries  
__________________________________________________________                                                                                   
                                                                      Subject: The 1956 Consent Decree
                                                                                  The 1956 Consent Decree         date: January 24, 1956
                                                                                                                        January 24, 1956      
                                                                                                                                           
                                                                                                               from: Able, Baker &
                                                                                                                        Able, Baker           
                                                                                                                     Charley, Attys.
                                                                                                                        Charley, Attys.       
                 The Role of the Allen Wrench
                  The Role of the Allen Wrench                                                                                              
                                                                                                                                           
                       in Modern Electronics
                       in Modern Electronics                          
                                                                           Plaintiff, United States of America, having ﬁled its complaint 
                                                                      herein on January 14, 1949; the defendants having appeared and 

                           J. Q. Pencilpusher                          ﬁled their answer to such complaint denying the substantive alle- 
                                                                      gations thereof; and the parties, by their attorneys, having 

                            X. Y. Hardwired                            severally consented to the entry of this Final Judgment without 
                                                                      trial or adjudication of any issues of fact or law herein and 
                            Bell Laboratories                          without this Final Judgment constituting any evidence or admis- 


                    Murray Hill, New Jersey 07974                      sion by any party in respect of any such issues;                     
                                                                      

                                                                          Now, therefore before any testimony has been taken herein, 
                                                                                                                                             
                              ABSTRACT                                and without trial or adjudication of any issue of fact or law 
                                                                       herein, and upon the consent of all parties hereto, it is hereby
                                                                                                                                             
         This abstract should be short enough to ﬁt on a sin-            Ordered, adjudged and decreed as follows:                         
       gle page cover sheet. It must attract the reader into          I. [ Sherman Act]
                                                                         I. [Sherman Act]                                                     
       sending for the complete memorandum.                                                                                                
                                                                         This Court has jurisdiction of the subject matter herein and of 
                                                                      all the parties hereto. The complaint states a claim upon which 
                                                                      relief may be granted against each of the defendants under Sec- 
                                                                      tions 1, 2 and 3 of the Act of Congress of July 2, 1890, entitled 
                                                                      ‘‘An act to protect trade and commerce against unlawful restraints 
                                                                      and monopolies,’’ commonly known as the Sherman Act, as 
 April 1, 1976                                                        amended.                                                             
                                                                      II. [De ﬁnitions]
                                                                         II. [Deﬁnitions]                                                     
__________________________________________________________
                                                                                                                                            
__________________________________________________________             
                                                                            For the purposes of this Final Judgment:
                                                                                                                                              
                                                                         (a) ‘‘Western’’ shall mean the defendant Western Electric 
                                                                      Company, Incorporated.                                               
                                                                                                                                           
                 The Role of the Allen Wrench
                  The Role of the Allen Wrench                         __________________________________________________________
                                                                      
                      in Modern Electronics
                       in Modern Electronics                       
                                                                  
                          J. Q. Pencilpusher                           Other formats possible (specify before .TL) are: .MR
                                                                  
                                                                  
                                                                         (‘‘memo for record’’), .MF (‘‘memo for ﬁle’’), .EG
                           X. Y. Hardwired                              (‘‘engineer’s notes’’) and .TR (Computing Science Tech.
                                                                   
                                                                       Report).
                           Bell Laboratories                      
                   Murray Hill, New Jersey 07974                  
                                                                  
                                                                                                 Hea di ng s
                                                                                                   He ad in gs
                                                                  
                                                                  
                                                                       .NH                                         .SH
 1. Introduction
  1. Introduction
                                                                        Introduction.                               Appendix I
    The solution to the torque handle equation                    
                             ∞                                          .PP                                         .PP
                                                                   


                          Σ     F (xi )=G (x )                 (1)      text text text                              text text text
                              0                                    
                                           ρ
 is found with the transformation x = __ where ρ=G ′(x ) and θ is      1. Introduction
                                                                         1. Introduction                             Appendix I
                                                                                                                     Appendix
                                          θ                       
 derived from well-known principles.                                     text text text                              text text text
__________________________________________________________

                                5                                                          6

                    A S im pl e L is t
                      Si mp le Li st                                          M ul ti pl e I nd en ts
                                                                              Mu lt ip le In de nt s
.IP 1.                                                      This is ordinary text to point out
J. Pencilpusher and X. Hardwired,                           the margins of the page.
.I                                                          .IP 1.
A New Kind of Set Screw,                                    First level item
.R                                                          .RS
Proc. IEEE                                                  .IP a)
.B 75                                                       Second level.
(1976), 23-255.                                             .IP b)
.IP 2.                                                      Continued here with another second
H. Nails and R. Irons,                                      level item, but somewhat longer.
.I                                                          .RE
Fasteners for Printed Circuit Boards,                       .IP 2.
.R                                                          Return to previous value of the
Proc. ASME                                                  indenting at this point.
.B 23                                                       .IP 3.
(1974), 23-24.                                              Another
.LP (terminates list)                                       line.

1.   J. Pencilpusher and X. Hardwired, A New Kind of        This is ordinary text to point out the margins of the page.
     Set Screw, Proc. IEEE 75 (1976), 23-255.               1. First level item
2.   H. Nails and R. Irons, Fasteners for Printed Circuit        a) Second level.
     Boards, Proc. ASME 23 (1974), 23-24.                        b) Continued here with another second level item,
                                                                      but somewhat longer.
                                                            2. Return to previous value of the indenting at this
                        D is pl ay s
                        Di sp la ys                              point.
                                                            3. Another line.
text text text text text text
.DS
and now                                                                              Kee ps
                                                                                     Ke ep s
for something
completely different                                        Lines bracketed by the following commands are kept
.DE                                                         together, and will appear entirely on one page:
text text text text text text                                  .KS        not moved             .KF      may ﬂoat
                                                               .KE        through text          .KE      in text
hoboken harrison newark roseville avenue grove street
east orange brick church orange highland avenue moun-
tain station south orange maplewood millburn short hills                      Dou bl e C ol um n
                                                                              Do ub le Co lu mn
summit new providence
                                                            .TL
        and now
                                                            The Declaration of Independence
        for something
                                                            .2C
        completely different
                                                            .PP
murray hill berkeley heights gillette stirling millington   When in the course of human events, it becomes
lyons basking ridge bernardsville far hills peapack glad-   necessary for one people to dissolve the political
stone                                                       bonds which have connected them with another, and
                                                            to assume among the powers of the earth the
Options: .DS L: left-adjust; .DS C: line-by-line center;
                                                            separate and equal station to which the laws of
.DS B: make block, then center.
                                                            Nature and of Nature’s God entitle them, a decent
                                                            respect to the opinions of
                       F oo tn ot es
                       Fo ot no te s
                                                                        The Declaration of Independence
Among the most important occupants
                                                               When in the course of              We hold these truths to
of the workbench are the long-nosed pliers.
                                                            human events, it becomes           be self-evident, that all
Without these basic tools*
                                                            necessary for one people to        men are created equal, that
.FS
                                                            dissolve the political bonds       they are endowed by their
* As ﬁrst shown by Tiger & Leopard
                                                            which have connected               creator      with    certain
(1975).
                                                            them with another, and to          unalienable rights, that
.FE
                                                            assume among the powers            among these are life, liber-
few assemblies could be completed. They may
                                                            of the earth the separate          ty, and the pursuit of hap-
lack the popular appeal of the sledgehammer
                                                            and equal station to which         piness. That to secure
                                                            the laws of Nature and of          these rights, governments
Among the most important occupants of the workbench         Nature’s God entitle them,         are instituted among men,
are the long-nosed pliers. Without these basic tools* few   a decent respect to the
assemblies could be completed. They may lack the popu-      opinions of mankind re-
lar appeal of the sledgehammer                              quires that they should de-
________________                                            clare the causes which im-
* As ﬁrst shown by Tiger & Leopard (1975).                  pel them to the separation.
                             7                                                               8

                      E qu at io ns
                      Eq ua ti on s                                                      Tab le s
                                                                                         Ta bl es
A displayed equation is marked                                  .TS           ( T indicates a tab)
with an equation number at the right margin                     allbox;                            _____________________
by adding an argument to the EQ line:                           css                                ____________________
                                                                                                   _AT&T Common Stock
.EQ (1.3)                                                       ccc                                ____________________
                                                                                                   _ Year  Price Dividend
x sup 2 over a sup 2 ˜=˜ sqrt {p z sup 2 +qz+r}                 n n n.                              1971 41-54  $2.60 
                                                                                                   _____________________
                                                                                                   
.EN                                                             AT&T Common Stock                       2 41-54  2.70
                                                                                                   ____________________
                                                                                                   _
                                                                Year T Price T Dividend                          
A displayed equation is marked with an equation number          1971 T 41-54 T $2.60               ____________________
                                                                                                   _    3 46-55  2.87 
                                                                                                   ____________________
                                                                                                   _    4 40-53  3.24
at the right margin by adding an argument to the EQ line:       2 T 41-54 T 2.70                   ____________________
                                                                3 T 46-55 T 2.87                   _    5 45-52  3.40
                     x2                                                                                                    
                     _ = 
                     __ √ pz 2+qz +r                (1.3)       4 T 40-53 T 3.24                   _____________________
                                                                                                       6 51-59  .95*
                                                                                                                 
                     a2
                                                                5 T 45-52 T 3.40                   * (ﬁrst quarter only)
.EQ I (2.2a)                                                    6 T 51-59 T .95*
bold V bar sub nu˜=˜left [ pile {a above b above                .TE
c } right ] + left [ matrix { col { A(11) above .               * (ﬁrst quarter only)
above . } col { . above . above .} col {. above .               The meanings of the key-letters describing the alignment
above A(33) }} right ] cdot left [ pile { alpha                 of each entry are:
above beta above gamma } right ]                                         c     center           n numerical
.EN                                                                       r    right-adjust     a subcolumn
                                                                          l    left-adjust      s    spanned
            a   A (11) .    .  α 
    V ν =  b   .                                            The global table options are center, expand, box,
    V          +         .    .  β 
                                    .                  (2.2a)
           c   .       . A (33)   γ                       doublebox, allbox, tab (x ) and linesize (n ).
                                                                                           x              n

.EQ L                                                           .TS            (with delim $$ on, see panel 3)
F hat ( chi ) ˜ mark = ˜  del V  sup 2                        doublebox, center;
.EN                                                             cc
.EQ L                                                           l l.
lineup =˜ {left ( {partial V} over {partial x} right ) }        Name T Deﬁnition
sup 2 + { left ( {partial V} over {partial y} right ) }         .sp
sup 2 ˜˜˜˜˜˜ lambda -> inf                                      Gamma T $GAMMA (z) = int sub 0 sup inf \
.EN                                                                  t sup {z-1} e sup -t dt$
                                                                Sine T $sin (x) = 1 over 2i ( e sup ix - e sup -ix )$
F (χ) =  ∇V  2
ˆ                                                               Error T $ roman erf (z) = 2 over sqrt pi \
                                                                   int sub 0 sup z e sup {-t sup 2} dt$
        ∂V 2  ∂V 2                                          Bessel T $ J sub 0 (z) = 1 over pi \
     =  ___  +  ___          λ→∞                               int sub 0 sup pi cos ( z sin theta ) d theta $
        ∂x   ∂y                                             Zeta T $ zeta (s) = \
                                                                   sum from k=1 to inf k sup -s ˜˜( Re˜s > 1)$
$ a dot $, $ b dotdot$, $ xi tilde times y vec$:                .TE
. .. ˜ →                                                                   ________________________________
                                                                            ________________________________
                                                                            _
a , b , ξ×y .     (with delim $$ on, see panel 3).
                                                                            Name                Deﬁnition           
See also the equations in the second table, panel 8.                                                                
                                                                                                 ∞                  
                                                                           Gamma      Γ(z )=∫ t z −1e −t dt         
      S om e R eg is te rs Y ou C an C ha ng e
      So me Re gi st er s Yo u Ca n Ch an ge                                                   0
                                                                                                    1 ix −ix          
                                                                           Sine       sin(x )= _ (e −e )
                                                                                                   __
                                                                                                                      
                                                                                                 2i
                                                                                                            z         
                                                                           Error      erf(z )= ___ ∫ e −t dt
Line length                      Paragraph spacing
                                                                                                                      
                                                                                                    2          2

    .nr LL 7i                        .nr PD 0                                                   √
                                                                                                  π     0
                                                                                                                      
                                                                                                        π
Title length                     Page offset                                                   __ ∫ cos(z sinθ)d θ 
                                                                                                  1
     .nr LT 7i                       .nr PO 0.5i                           Bessel     J 0(z )=
                                                                                                  π 0                 
                                                                                              ∞
                                                                                                                      
Point size                       Page heading                              Zeta       ζ(s )= Σ k   −s
                                                                                                            (Re s >1) 
     .nr PS 9                        .ds CH Appendix                       ________________________________
                                                                           
                                                                           _________________________________
                                                                                               k =1

Vertical spacing                         (center)
     .nr VS 11                       .ds RH 7-25-76                                      Usa ge
                                                                                         Us ag e
                                         (right)
Column width                         .ds LH Private                   Documents with just text:
    .nr CW 3i                            (left)                 troff -ms ﬁles
Intercolumn spacing              Page footer                          With equations only:
     .nr GW .5i                      .ds CF Draft               eqn ﬁles  troff -ms
                                     .ds LF                           With tables only:
Margins – head and foot                                         tbl ﬁles  troff -ms
    .nr HM .75i                      .ds RF similar
                                                                      With both tables and equations:
    .nr FM .75i                  Page numbers                   tbl ﬁles  eqn  troff -ms
                                                                ______________________________
Paragraph indent                     .nr % 3
    .nr PI 2n                                                   The above generates STARE output on      GCOS:   replace – st
                                                                with – ph for typesetter output.
                                A System for Typesetting Mathematics

                                    Brian W. Kernighan and Lorinda L. Cherry
                                                 Bell Laboratories
                                           Murray Hill, New Jersey 07974


                                                        ABSTRACT

                 This paper describes the design and implementation of a system for typesetting mathemat-
          ics. The language has been designed to be easy to learn and to use by people (for example,
          secretaries and mathematical typists) who know neither mathematics nor typesetting. Experience
          indicates that the language can be learned in an hour or so, for it has few rules and fewer excep-
          tions. For typical expressions, the size and font changes, positioning, line drawing, and the like
          necessary to print according to mathematical conventions are all done automatically. For exam-
          ple, the input
                                       sum from i=0 to inﬁnity x sub i = pi over 2
          produces
                                                    ∞
                                                            π
                                                   Σxi = __
                                                   i =0  2

                  The syntax of the language is speciﬁed by a small context-free grammar; a compiler-
          compiler is used to make a compiler that translates this language into typesetting commands.
          Output may be produced on either a phototypesetter or on a terminal with forward and reverse
          half-line motions. The system interfaces directly with text formatting programs, so mixtures of
          text and mathematics may be handled simply.

                 This paper is a revision of a paper originally published in CACM, March, 1975.




1. Introduction                                                 limits in the preceding example showed in its simplest
       ‘‘Mathematics is known in the trade as                   form. This is carried further by
difﬁcult, or penalty, copy because it is slower, more                                          b1
difﬁcult, and more expensive to set in type than any                            a 0+ ________________
                                                                                                 b2
other kind of copy normally occurring in books and                                   a 1+ ____________
                                                                                                   b3
journals.’’ [1]                                                                           a 2+ ________
                                                                                               a 3+ . . .
       One difﬁculty with mathematical text is the
multiplicity of characters, sizes, and fonts. An
expression such as                                              and still further by
                                                                                                      _a e −√ b
                                                                                                        mx 
                                                                                                       √        
                  lim (tan x )sin 2x = 1                                                     1
                                                                                        _______ log
                                                                                                        _________
                  x →π⁄2
                                                                                            √
                                                                                         2m  ab
                                                                                                     √        
                                                                                                                
                                                                                                        a emx +√ b
                                                                                                        
requires an intimate mixture of roman, italic and                                       1
greek letters, in three sizes, and a special character or
                                                                                                         
                                                                                                         √
                                                                     ∫ _ mx dx −mx =  ______ tanh−1( _a emx )
                                                                       __________
                                                                       ae −be
                                                                                                         ___
two. (‘‘Requires’’ is perhaps the wrong word, but                                         √
                                                                                         m  ab
                                                                                                       b
                                                                                                         √
                                                                                       
mathematics has its own typographical conventions                                          −1            
                                                                                                         √
                                                                                        ______ coth−1( _ a emx )
                                                                                                         ___
which are quite different from those of ordinary text.)                                 m  ab
                                                                                           √           b
                                                                                                         √
Typesetting such an expression by traditional methods
                                                                These examples also show line-drawing, built-up
is still an essentially manual operation.
                                                                characters like braces and radicals, and a spectrum of
       A second difﬁculty is the two dimensional                positioning problems. (Section 6 shows what a user
character of mathematics, which the superscript and             has to type to produce these on our system.)
                                                             -2-


2. Photocomposition                                                bars have to be made the right length and positioned
       Photocomposition techniques can be used to                  at the right height. And so on. Indeed a mechanism
solve some of the problems of typesetting mathemat-                for overriding default actions has to exist, but its
ics. A phototypesetter is a device which exposes a                 application is the exception, not the rule.
piece of photographic paper or ﬁlm, placing charac-                       We assume that the typist has a reasonable pic-
ters wherever they are wanted. The Graphic Systems                 ture (a two-dimensional representation) of the desired
phototypesetter[2] on the UNIX operating system[3]                 ﬁnal form, as might be handwritten by the author of a
works by shining light through a character stencil.                paper. We also assume that the input is typed on a
The character is made the right size by lenses, and                computer terminal much like an ordinary typewriter.
the light beam directed by ﬁber optics to the desired              This implies an input alphabet of perhaps 100 charac-
place on a piece of photographic paper. The exposed                ters, none of them special.
paper is developed and typically used in some form                        A secondary, but still important, goal in our
of photo-offset reproduction.                                      design was that the system should be easy to imple-
       On UNIX, the phototypesetter is driven by a                 ment, since neither of the authors had any desire to
formatting program called TROFF [4]. TROFF was                     make a long-term project of it. Since our design was
designed for setting running text. It also provides all            not ﬁrm, it was also necessary that the program be
of the facilities that one needs for doing mathematics,            easy to change at any time.
such as arbitrary horizontal and vertical motions,                        To make the program easy to build and to
line-drawing, size changing, but the syntax for                    change, and to guarantee regularity (‘‘it should work
describing these special operations is difﬁcult to learn,          everywhere’’), the language is deﬁned by a context-
and difﬁcult even for experienced users to type                    free grammar, described in Section 5. The compiler
correctly.                                                         for the language was built using a compiler-compiler.
       For this reason we decided to use TROFF as an                      A priori, the grammar/compiler-compiler
‘‘assembly language,’’ by designing a language for                 approach seemed the right thing to do. Our subse-
describing mathematical expressions, and compiling it              quent experience leads us to believe that any other
into TROFF.                                                        course would have been folly. The original language
                                                                   was designed in a few days. Construction of a work-
3. Language Design                                                 ing system sufﬁcient to try signiﬁcant examples
      The fundamental principle upon which we                      required perhaps a person-month. Since then, we
based our language design is that the language should              have spent a modest amount of additional time over
be easy to use by people (for example, secretaries)                several years tuning, adding facilities, and occasion-
who know neither mathematics nor typesetting.                      ally changing the language as users make criticisms
        This principle implies several things. First,              and suggestions.
‘‘normal’’ mathematical conventions about operator                       We also decided quite early that we would let
precedence, parentheses, and the like cannot be used,              TROFF do our work for us whenever possible.
for to give special meaning to such characters means               TROFF is quite a powerful program, with a macro
that the user has to understand what he or she is typ-             facility, text and arithmetic variables, numerical com-
ing. Thus the language should not assume, for                      putation and testing, and conditional branching. Thus
instance, that parentheses are always balanced, for                we have been able to avoid writing a lot of mundane
they are not in the half-open interval (a ,b ]. Nor                but tricky software. For example, we store no text
should it assume that that  can be replaced by
                                √ a +b                             strings, but simply pass them on to TROFF. Thus we
                                                    1              avoid having to write a storage management package.
(a +b ) ⁄ , or that 1⁄(1−x ) is better written as ____ (or
      1
          2


                                                  1−x              Furthermore, we have been able to isolate ourselves
vice versa).                                                       from most details of the particular device and charac-
       Second, there should be relatively few rules,               ter set currently in use. For example, we let TROFF
keywords, special symbols and operators, and the                   compute the widths of all strings of characters; we
like. This keeps the language easy to learn and                    need know nothing about them.
remember. Furthermore, there should be few excep-                         A third design goal is special to our environ-
tions to the rules that do exist: if something works in            ment. Since our program is only useful for typeset-
one situation, it should work everywhere. If a vari-               ting mathematics, it is necessary that it interface
able can have a subscript, then a subscript can have a             cleanly with the underlying typesetting language for
subscript, and so on without limit.                                the beneﬁt of users who want to set intermingled
      Third, ‘‘standard’’ things should happen                     mathematics and text (the usual case). The standard
automatically. Someone who types ‘‘x=y+z+1’’                       mode of operation is that when a document is typed,
should get ‘‘x =y +z +1’’. Subscripts and superscripts             mathematical expressions are input as part of the text,
should automatically be printed in an appropriately                but marked by user settable delimiters. The program
smaller size, with no special intervention. Fraction               reads this input and treats as comments those things
                                                            -3-


which are not mathematics, simply passing them
                                                                       a+b over c+d+e = 1
through untouched. At the same time it converts the
mathematical input into the necessary TROFF com-                  produces
mands. The resulting ioutput is passed directly to
                                                                                        _ a +b =1
                                                                                        ______
TROFF where the comments and the mathematical
                                                                                        c +d +e
parts both become text and/or TROFF commands.
                                                                        Similarly, subscripts and superscripts are intro-
4. The Language                                                   duced by the keywords sub and sup:
       We will not try to describe the language pre-                                     x 2+y 2=z 2
cisely here; interested readers may refer to the appen-
dix for more details. Throughout this section, we will            is produced by
write expressions exactly as they are handed to the                    x sup 2 + y sup 2 = z sup 2
typesetting program (hereinafter called ‘‘EQN’’),
except that we won’t show the delimiters that the user            The spaces after the 2’s are necessary to mark the end
types to mark the beginning and end of the expres-                of the superscripts; similarly the keyword sup has to
sion. The interface between EQN and TROFF is                      be marked off by spaces or some equivalent delimiter.
described at the end of this section.                             The return to the proper baseline is automatic. Multi-
                                                                  ple levels of subscripts or superscripts are of course
        As we said, typing x=y+z+1 should produce                                                     z
                                                                  allowed: ‘‘x sup y sup z’’ is x y . The construct
x =y +z +1, and indeed it does. Variables are made
                                                                  ‘‘something sub something sup something’’ is recog-
italic, operators and digits become roman, and normal
                                                                  nized as a special case, so ‘‘x sub i sup 2’’ is xi 2
spacings between letters and operators are altered
                                                                  instead of xi 2.
slightly to give a more pleasing appearance.
                                                                        More complicated expressions can now be
       Input is free-form. Spaces and new lines in
                                                                  formed with these primitives:
the input are used by EQN to separate pieces of the
input; they are not used to create space in the output.                                ∂2
                                                                                       ___ x
                                                                                       _ f =_ +_
                                                                                             2
                                                                                            __ y
                                                                                               __
                                                                                                 2

Thus                                                                                   ∂x 2
                                                                                            a b2
                                                                                             2


   x    = y                                                       is produced by
       +z+1                                                              {partial sup 2 f} over {partial x sup 2} =
also gives x =y +z +1. Free-form input is easier to                      x sup 2 over a sup 2 + y sup 2 over b sup 2
type initially; subsequent editing is also easier, for an         Braces {} are used to group objects together; in this
expression may be typed as many short lines.                      case they indicate unambiguously what goes over
       Extra white space can be forced into the output            what on the left-hand side of the expression. The
by several characters of various sizes. A tilde ‘‘ ˜ ’’           language deﬁnes the precedence of sup to be higher
gives a space equal to the normal word spacing in                 than that of over, so no braces are needed to get the
text; a circumﬂex gives half this much, and a tab                 correct association on the right side. Braces can
charcter spaces to the next tab stop.                             always be used when in doubt about precedence.
       Spaces (or tildes, etc.) also serve to delimit                    The braces convention is an example of the
pieces of the input. For example, to get                          power of using a recursive grammar to deﬁne the
                                                                  language. It is part of the language that if a construct
                  f (t )=2π∫ sin(ωt )dt                           can appear in some context, then any expression in
we write                                                          braces can also occur in that context.

   f(t) = 2 pi int sin ( omega t )dt                                     There is a sqrt operator for making square
                                                                  roots of the appropriate size: ‘‘sqrt a+b’’ produces
Here spaces are necessary in the input to indicate that            , and
                                                                  √ a +b
sin, pi, int, and omega are special, and potentially
worth special treatment. EQN looks up each such                        x = {−b +− sqrt{b sup 2 −4ac}} over 2a
string of characters in a table, and if appropriate gives         is
it a translation. In this case, pi and omega become
                                                                                        −b ± b 2−4ac
                                                                                            √
                                                                                            
their greek equivalents, int becomes the integral sign                               x =_
                                                                                        ___________
(which must be moved down and enlarged so it looks                                           2a
‘‘right’’), and sin is made roman, following conven-              Since large radicals look poor on our typesetter, sqrt
tional mathematical practice. Parentheses, digits and             is not useful for tall expressions.
operators are automatically made roman wherever                          Limits on summations, integrals and similar
found.                                                            constructions are speciﬁed with the keywords from
       Fractions are speciﬁed with the keyword over:              and to. To get
                                                                                            ∞

                                                                                         Σxi →0
                                                                                         i =0
                                                            -4-


we need only type                                                 inch; this paper is set in 9 point type.)
     sum from i=0 to inf x sub i −> 0                                     If necessary, an input string can be quoted in
                                                                  "...", which turns off grammatical signiﬁcance, and
Centering and making the Σ big enough and the limits              any font or spacing changes that might otherwise be
smaller are all automatic. The from and to parts are              done on it. Thus we can say
both optional, and the central part (e.g., the Σ) can in
fact be anything:                                                    lim˜ roman "sup" ˜x sub n = 0

     lim from {x −> pi /2} ( tan˜x) = inf                         to ensure that the supremum doesn’t become a super-
                                                                  script:
is
                                                                                        lim sup xn =0
                      lim (tan x )=∞
                     x →π⁄2
                                                                         Diacritical marks, long a problem in traditional
Again, the braces indicate just what goes into the                typesetting, are straightforward:
from part.                                                                            .          ..
                                                                                     _ +x +y +X +Y =z +Z
                                                                                     x ˆ ˜ ˆ        
                                                                                                    
       There is a facility for making braces, brackets,
parentheses, and vertical bars of the right height,               is made by typing
using the keywords left and right:
                                                                     x dot under + x hat + y tilde
     left [ x+y over 2a right ]˜=˜1                                  + X hat + Y dotdot = z+Z bar
makes                                                                    There are also facilities for globally changing
                        x +y                                    default sizes and fonts, for example for making view-
                        ____  = 1                               graphs or for setting chemical equations. The
                        2a                                      language allows for matrices, and for lining up equa-
A left need not have a corresponding right, as we                 tions at the same horizontal position.
shall see in the next example. Any characters may                       Finally, there is a deﬁnition facility, so a user
follow left and right, but generally only various                 can say
parentheses and bars are meaningful.
                                                                     deﬁne name "..."
        Big brackets, etc., are often used with another
facility, called piles, which make vertical piles of              at any time in the document; henceforth, any
objects. For example, to get                                      occurrence of the token ‘‘name’’ in an expression will
                                                                 be expanded into whatever was inside the double
                              1 if x >0                          quotes in its deﬁnition. This lets users tailor the
                 sign (x ) ≡  0 if x =0                          language to their own speciﬁcations, for it is quite
                             −1 if                               possible to redeﬁne keywords like sup or over. Sec-
                                   x <0
                                                                  tion 6 shows an example of deﬁnitions.
we can type                                                               The EQN preprocessor reads intermixed text
     sign (x) ˜==˜ left {                                         and equations, and passes its output to TROFF. Since
        rpile {1 above 0 above −1}                                TROFF uses lines beginning with a period as control
        ˜˜lpile {if above if above if}                            words (e.g., ‘‘.ce’’ means ‘‘center the next output
        ˜˜lpile {x>0 above x=0 above x<0}                         line’’), EQN uses the sequence ‘‘.EQ’’ to mark the
                                                                  beginning of an equation and ‘‘.EN’’ to mark the end.
The construction ‘‘left {’’ makes a left brace big                The ‘‘.EQ’’ and ‘‘.EN’’ are passed through to TROFF
enough to enclose the ‘‘rpile {...}’’, which is a right-          untouched, so they can also be used by a knowledge-
justiﬁed pile of ‘‘above ... above ...’’. ‘‘lpile’’ makes         able user to center equations, number them automati-
a left-justiﬁed pile. There are also centered piles.              cally, etc. By default, however, ‘‘.EQ’’ and ‘‘.EN’’
Because of the recursive language deﬁnition, a pile               are simply ignored by TROFF, so by default equations
can contain any number of elements; any element of a              are printed in-line.
pile can of course contain piles.
                                                                         ‘‘.EQ’’ and ‘‘.EN’’ can be supplemented by
       Although EQN makes a valiant attempt to use                TROFF commands as desired; for example, a centered
the right sizes and fonts, there are times when the               display equation can be produced with the input:
default assumptions are simply not what is wanted.
For instance the italic sign in the previous example                           .ce
would conventionally be in roman. Slides and tran-                             .EQ
sparencies often require larger characters than normal                         x sub i = y sub i ...
text. Thus we also provide size and font changing                              .EN
commands: ‘‘size 12 bold {A˜x˜=˜y}’’ will produce
A x = y. Size is followed by a number represent-                        Since it is tedious to type ‘‘.EQ’’ and ‘‘.EN’’
                                                                  around very short expressions (single letters, for
ing a character size in points. (One point is 1/72
                                                          -5-


instance), the user can also deﬁne two characters to                  The grammar makes it obvious why there are
serve as the left and right delimiters of expressions.          few exceptions. For example, the observation that
These characters are recognized anywhere in subse-              something can be replaced by a more complicated
quent text. For example if the left and right delim-            something in braces is implicit in the productions:
iters have both been set to ‘‘#’’, the input:
                                                                        eqn : box  eqn box
   Let #x sub i#, #y# and #alpha# be positive                           box : text  { eqn }
produces:                                                       Anywhere a single character could be used, any legal
                                                                construction can be used.
   Let xi , y and α be positive
                                                                      Clearly, our grammar is highly ambiguous.
      Running a preprocessor is strikingly easy on              What, for instance, do we do with the input
UNIX. To typeset text stored in ﬁle ‘‘f ’’, one issues
                                                                    a over b over c ?
the command:
                                                                Is it
   eqn f  troff
                                                                    {a over b} over c
The vertical bar connects the output of one process
(EQN) to the input of another (TROFF).                          or is it
                                                                    a over {b over c} ?
5. Language Theory
       The basic structure of the language is not a                      To answer questions like this, the grammar is
particularly original one. Equations are pictured as a          supplemented with a small set of rules that describe
set of ‘‘boxes,’’ pieced together in various ways. For          the precedence and associativity of operators. In par-
example, something with a subscript is just a box fol-          ticular, we specify (more or less arbitrarily) that over
lowed by another box moved downward and shrunk                  associates to the left, so the ﬁrst alternative above is
by an appropriate amount. A fraction is just a box              the one chosen. On the other hand, sub and sup bind
centered above another box, at the right altitude, with         to the right, because this is closer to standard
                                                                                                                    b
a line of correct length drawn between them.                    mathematical practice. That is, we assume x a is
                                                                    b
       The grammar for the language is shown below.             x (a ), not (x a )b .
For purposes of exposition, we have collapsed some                     The precedence rules resolve the ambiguity in
productions. In the original grammar, there are about           a construction like
70 productions, but many of these are simple ones
used only to guarantee that some keyword is recog-                  a sup 2 over b
nized early enough in the parsing process. Symbols              We deﬁne sup to have a higher precedence than over,
in capital letters are terminal symbols; lower case                                                              2
                                                                                                                 __
                                                                                                  a2
symbols are non-terminals, i.e., syntactic categories.          so this construction is parsed as _ instead of a b .
                                                                                                  __
                                                                                                   b
The vertical bar  indicates an alternative; the brack-
                                                                       Naturally, a user can always force a particular
ets [ ] indicate optional material. A TEXT is a string
                                                                parsing by placing braces around expressions.
of non-blank characters or any string inside double
quotes; the other terminal symbols represent literal                    The ambiguous grammar approach seems to be
occurrences of the corresponding keyword.                       quite useful. The grammar we use is small enough to
                                                                be easily understood, for it contains none of the pro-
  eqn : box  eqn box                                           ductions that would be normally used for resolving
  box : text                                                    ambiguity. Instead the supplemental information
       { eqn }                                                 about precedence and associativity (also small enough
       box OVER box                                            to be understood) provides the compiler-compiler with
       SQRT box                                                the information it needs to make a fast, deterministic
       box SUB box  box SUP box                               parser for the speciﬁc language we want. When the
       [ L  C  R ]PILE { list }                              language is supplemented by the disambiguating
       LEFT text eqn [ RIGHT text ]                            rules, it is in fact LR(1) and thus easy to parse[5].
       box [ FROM box ] [ TO box ]                                    The output code is generated as the input is
       SIZE text box                                           scanned. Any time a production of the grammar is
       [ROMAN  BOLD  ITALIC] box                             recognized, (potentially) some TROFF commands are
       box [HAT  BAR  DOT  DOTDOT  TILDE]                  output. For example, when the lexical analyzer
       DEFINE text text                                        reports that it has found a TEXT (i.e., a string of con-
  list   : eqn  list ABOVE eqn                                 tiguous characters), we have recognized the produc-
                                                                tion:
  text : TEXT
                                                                    text    : TEXT
                                                             -6-


The translation of this is simple. We generate a local             ﬂowers of illuminated manuscripts on esthetic
name for the string, then hand the name and the                    grounds, either, but they have some clear economic
string to TROFF, and let TROFF perform the storage                 advantages.
management. All we save is the name of the string,                        Some of the deﬁciencies in the output could be
its height, and its baseline.                                      cleaned up with more work on our part. For exam-
       As another example, the translation associated              ple, we sometimes leave too much space between a
with the production                                                roman letter and an italic one. If we were willing to
                                                                   keep track of the fonts involved, we could do this
       box   : box OVER box
                                                                   better more of the time.
is:                                                                       Some other weaknesses are inherent in our out-
      Width of output box =                                        put device. It is hard, for instance, to draw a line of
       slightly more than largest input width                      an arbitrary length without getting a perceptible over-
      Height of output box =                                       strike at one end.
       slightly more than sum of input heights                            As to ease of use, at the time of writing, the
      Base of output box =                                         system has been used by two distinct groups. One
       slightly more than height of bottom input box               user population consists of mathematicians, chemists,
      String describing output box =                               physicists, and computer scientists. Their typical
       move down;                                                  reaction has been something like:
       move right enough to center bottom box;
                                                                   (1)      It’s easy to write, although I make the follow-
       draw bottom box (i.e., copy string for bottom box);
                                                                            ing mistakes...
       move up; move left enough to center top box;
       draw top box (i.e., copy string for top box);               (2)      How do I do...?
       move down and left; draw line full width;                    (3)     It botches the following things.... Why don’t
       return to proper base line.                                          you ﬁx them?
Most of the other productions have equally simple                  (4)      You really need the following features...
semantic actions. Picturing the output as a set of
properly placed boxes makes the right sequence of                         The learning time is short. A few minutes
positioning commands quite obvious. The main                       gives the general ﬂavor, and typing a page or two of
difﬁculty is in ﬁnding the right numbers to use for                a paper generally uncovers most of the misconcep-
esthetically pleasing positioning.                                 tions about how it works.
      With a grammar, it is usually clear how to                          The second user group is much larger, the
extend the language. For instance, one of our users                secretaries and mathematical typists who were the ori-
suggested a TENSOR operator, to make constructions                 ginal target of the system. They tend to be enthusias-
like                                                               tic converts. They ﬁnd the language easy to learn
                              k j
                                                                   (most are largely self-taught), and have little trouble
                            l                                      producing the output they want. They are of course
                            mT
                              ni
                                                                   less critical of the esthetics of their output than users
Grammatically, this is easy: it is sufﬁcient to add a              trained in mathematics. After a transition period,
production like                                                    most ﬁnd using a computer more interesting than a
                                                                   regular typewriter.
       box   : TENSOR { list }
                                                                          The main difﬁculty that users have seems to be
Semantically, we need only juggle the boxes to the                 remembering that a blank is a delimiter; even experi-
right places.                                                      enced users use blanks where they shouldn’t and omit
                                                                   them when they are needed. A common instance is
6. Experience                                                      typing
       There are really three aspects of interest—how
                                                                         f(x sub i)
well EQN sets mathematics, how well it satisﬁes its
goal of being ‘‘easy to use,’’ and how easy it was to              which produces
build.
                                                                                              f (xi )
       The ﬁrst question is easily addressed. This
entire paper has been set by the program. Readers                  instead of
can judge for themselves whether it is good enough                                            f (xi )
for their purposes. One of our users commented that
although the output is not as good as the best hand-               Since the EQN language knows no mathematics, it
set material, it is still better than average, and much            cannot deduce that the right parenthesis is not part of
better than the worst. In any case, who cares?                     the subscript.
Printed books cannot compete with the birds and                             The language is somewhat prolix, but this
                                                            -7-


doesn’t seem excessive considering how much is                    7. Conclusions
being done, and it is certainly more compact than the                    We think we have shown that it is possible to
corresponding TROFF commands. For example, here                   do acceptably good typesetting of mathematics on a
is the source for the continued fraction expression in            phototypesetter, with an input language that is easy to
Section 1 of this paper:                                          learn and use and that satisﬁes many users’ demands.
        a sub 0 + b sub 1 over                                    Such a package can be implemented in short order,
          {a sub 1 + b sub 2 over                                 given a compiler-compiler and a decent typesetting
           {a sub 2 + b sub 3 over                                program underneath.
             {a sub 3 + ... }}}                                           Deﬁning a language, and building a compiler
This is the input for the large integral of Section 1;            for it with a compiler-compiler seems like the only
notice the use of deﬁnitions:                                     sensible way to do business. Our experience with the
                                                                  use of a grammar and a compiler-compiler has been
  deﬁne emx "{e sup mx}"                                          uniformly favorable. If we had written everything
  deﬁne mab "{m sqrt ab}"                                         into code directly, we would have been locked into
  deﬁne sa "{sqrt a}"                                             our original design. Furthermore, we would have
  deﬁne sb "{sqrt b}"                                             never been sure where the exceptions and special
  int dx over {a emx − be sup −mx} ˜=˜                            cases were. But because we have a grammar, we can
  left { lpile {                                                  change our minds readily and still be reasonably sure
       1 over {2 mab} ˜log˜                                       that if a construction works in one place it will work
            {sa emx − sb} over {sa emx + sb}                      everywhere.
     above
       1 over mab ˜ tanh sup −1 ( sa over sb emx )                Acknowledgements
     above
                                                                         We are deeply indebted to J. F. Ossanna, the
       −1 over mab ˜ coth sup −1 ( sa over sb emx )
                                                                  author of TROFF, for his willingness to modify
  }
                                                                  TROFF to make our task easier and for his continuous
       As to ease of construction, we have already                assistance during the development of our program.
mentioned that there are really only a few person-                We are also grateful to A. V. Aho for help with
months invested. Much of this time has gone into                  language theory, to S. C. Johnson for aid with the
two things—ﬁne-tuning (what is the most esthetically              compiler-compiler, and to our early users A. V. Aho,
pleasing space to use between the numerator and                   S. I. Feldman, S. C. Johnson, R. W. Hamming, and
denominator of a fraction?), and changing things                  M. D. McIlroy for their constructive criticisms.
found deﬁcient by our users (shouldn’t a tilde be a
delimiter?).                                                      References

       The program consists of a number of small,                 [1]   A Manual of Style, 12th Edition. University of
essentially unconnected modules for code generation,                    Chicago Press, 1969. p 295.
a simple lexical analyzer, a canned parser which we               [2]   Model C/A/T Phototypesetter.      Graphic Sys-
did not have to write, and some miscellany associated                   tems, Inc., Hudson, N. H.
with input ﬁles and the macro facility. The program               [3]   Ritchie, D. M., and Thompson, K. L., ‘‘The
is now about 1600 lines of C [6], a high-level                          UNIX time-sharing system.’’ Comm. ACM 17,
language reminiscent of BCPL. About 20 percent of                       7 (July 1974), 365-375.
these lines are ‘‘print’’ statements, generating the out-
put code.                                                         [4]   Ossanna, J. F., TROFF User’s Manual. Bell
                                                                        Laboratories Computing Science Technical
       The semantic routines that generate the actual                   Report 54, 1977.
TROFF commands can be changed to accommodate
other formatting languages and devices. For example,              [5]   Aho, A. V., and Johnson, S. C., ‘‘LR Pars-
in less than 24 hours, one of us changed the entire                     ing.’’ Comp. Surv. 6, 2 (June 1974), 99-124.
semantic package to drive NROFF, a variant of                     [6]   B. W. Kernighan and D. M. Ritchie, The C
TROFF, for typesetting mathematics on teletypewriter                    Programming Language. Prentice-Hall, Inc.,
devices capable of reverse line motions. Since many                     1978.
potential users do not have access to a typesetter, but
still have to type mathematics, this provides a way to
get a typed version of the ﬁnal output which is close
enough for debugging purposes, and sometimes even
for ultimate use.
               Typesetting Mathematics — User’s Guide                                   (Second Edition)

                                           Brian W. Kernighan and Lorinda L. Cherry
                                                        Bell Laboratories
                                                  Murray Hill, New Jersey 07974



                                                              ABSTRACT

         This is the user’s guide for a system for typesetting mathematics, using the phototypesetters on the
UNIX†     and GCOS operating systems.
       Mathematical expressions are described in a language designed to be easy to use by people who
know neither mathematics nor typesetting. Enough of the language to set in-line expressions like
 lim (tan x )sin 2x = 1 or display equations like
x →π⁄2
                                                Sk z k 
               G (z ) = e ln G (z ) = exp  Σ _     ____  = e S z ⁄k
                                                              Π
                                                                            k
                                                                        k


                                               k ≥1 k  k ≥1
                                    S 1 z 2 . . .   _ 2z 2 _ 2 z 4 . . .  . . .
                                       2
                                                             S      S2
                      = 1+S 1z + _  ____ +             1+ ____ + ____ +     
                                      2!                    2    22.2!      
                                                        k       k           k   
                                                    _ S1 _ S2            ______ z m
                                                     _____ _____ . . . _ Sm
                                                          1         2               m

                      =Σ              Σ               k       k           k     
                       m ≥0
                             k ,k , .. .. .. , k ≥0 1 k 1! 2 k 2!        m km ! 
                                                      1         2               m
                                  1    2      m

                            k +2k + +mk =m
                              1       2           m                              
can be learned in an hour or so.
      The language interfaces directly with the phototypesetting language TROFF, so mathematical
expressions can be embedded in the running text of a manuscript, and the entire document produced in
one process. This user’s guide is an example of its output.
     The same language may be used with the UNIX formatter NROFF to set mathematical expressions
on DASI and GSI terminals and Model 37 teletypes.



August 15, 1978




_
______________
†UNIX is a Trademark of Bell Laboratories.
             Typesetting Mathematics — User’s Guide                       (Second Edition)

                                Brian W. Kernighan and Lorinda L. Cherry
                                               Bell Laboratories
                                         Murray Hill, New Jersey 07974



1. Introduction                                                                 x =y +z
       EQN is a program for typesetting                   The .EQ and .EN are copied through untouched;
mathematics on the Graphics Systems photo-                they are not otherwise processed by EQN. This
typesetters on UNIX and GCOS. The EQN                     means that you have to take care of things like
language was designed to be easy to use by peo-           centering, numbering, and so on yourself. The
ple who know neither mathematics nor typeset-             most common way is to use the TROFF and
ting. Thus EQN knows relatively little about              NROFF macro package package ‘−ms’ developed
mathematics. In particular, mathematical sym-             by M. E. Lesk[3], which allows you to center,
bols like +, −, ×, parentheses, and so on have no         indent, left-justify and number equations.
special meanings. EQN is quite happy to set gar-
                                                                With the ‘−ms’ package, equations are
bage (but it will look good).
                                                          centered by default. To left-justify an equation,
      EQN works as a preprocessor for the                 use .EQ L instead of .EQ. To indent it, use .EQ I.
typesetter formatter, TROFF[1], so the normal             Any of these can be followed by an arbitrary
mode of operation is to prepare a document with           ‘equation number’ which will be placed at the
both mathematics and ordinary text interspersed,          right margin. For example, the input
and let EQN set the mathematics while TROFF
does the body of the text.                                        .EQ I (3.1a)
                                                                  x = f(y/2) + y/2
      On UNIX, EQN will also produce                              .EN
mathematics on DASI and GSI terminals and on
Model 37 teletypes. The input is identical, but           produces the output
you have to use the programs NEQN and NROFF                           x =f (y ⁄2)+y ⁄2                (3.1a)
instead of EQN and TROFF. Of course, some
things won’t look as good because terminals                     There is also a shorthand notation so in-
don’t provide the variety of characters, sizes and        line expressions like πi2 can be entered without
fonts that a typesetter does, but the output is           .EQ and .EN. We will talk about it in section 19.
usually adequate for proofreading.
       To use EQN on UNIX,                                3. Input spaces
         eqn ﬁles  troff                                       Spaces and newlines within an expression
                                                          are thrown away by EQN. (Normal text is left
GCOS   use is discussed in section 26.                    absolutely alone.) Thus between .EQ and .EN,

2. Displayed Equations                                            x=y+z
      To tell EQN where a mathematical expres-            and
sion begins and ends, we mark it with lines                       x=y+z
beginning .EQ and .EN. Thus if you type the
lines                                                     and
         .EQ                                                      x = y
         x=y+z                                                     +z
         .EN                                              and so on all produce the same output
your output will look like                                                      x =y +z
                                                       -2-


You should use spaces and newlines freely to                 lines), as we did in the previous section.
make your input equations readable and easy to                     You can also make special words stand
edit. In particular, very long lines are a bad               out by surrounding them with tildes or
idea, since they are often hard to ﬁx if you make            circumﬂexes:
a mistake.
                                                                      x˜=˜2˜pi˜int˜sin˜(˜omega˜t˜)˜dt
4. Output spaces                                             is much the same as the last example, except
       To force extra spaces into the output, use            that the tildes not only separate the magic words
a tilde ‘‘ ˜ ’’ for each space you want:                     like sin, omega, and so on, but also add extra
                                                             spaces, one space per tilde:
          x˜=˜y˜+˜z
gives
                                                                         x =2π    ∫    sin ( ω t ) dt

                      x =y +z                                      Special words can also be separated by
                                                             braces { } and double quotes "...", which have
You can also use a circumﬂex ‘‘ˆ’’, which gives
                                                             special meanings that we will see soon.
a space half the width of a tilde. It is mainly
useful for ﬁne-tuning. Tabs may also be used to
                                                             7. Subscripts and Superscripts
position pieces of an expression, but the tab
stops must be set by TROFF commands.                               Subscripts and superscripts are obtained
                                                             with the words sub and sup.
5. Symbols, Special Names, Greek                                      x sup 2 + y sub k
        EQNknows some mathematical symbols,
                                                             gives
some mathematical names, and the Greek alpha-
bet. For example,                                                                  x 2+yk
          x=2 pi int sin ( omega t)dt                        EQN   takes care of all the size changes and verti-
                                                             cal motions needed to make the output look
produces
                                                             right. The words sub and sup must be sur-
                 x =2π∫ sin(ωt )dt                           rounded by spaces; x sub2 will give you xsub 2
                                                             instead of x 2. Furthermore, don’t forget to leave
Here the spaces in the input are necessary to tell           a space (or a tilde, etc.) to mark the end of a
EQN   that int, pi, sin and omega are separate enti-         subscript or superscript. A common error is to
ties that should get special treatment. The sin,             say something like
digit 2, and parentheses are set in roman type
instead of italic; pi and omega are made Greek;                       y = (x sup 2)+1
and int becomes the integral sign.                           which causes
        When in doubt, leave spaces around
                                                                                  y =(x 2)+1
separate parts of the input. A very common
error is to type f(pi) without leaving spaces on             instead of the intended
both sides of the pi. As a result, EQN does not
                                                                                 y =(x 2)+1
recognize pi as a special word, and it appears as
f (pi ) instead of f (π).                                          Subscripted subscripts and superscripted
      A complete list of EQN names appears in                superscripts also work:
section 23. Knowledgeable users can also use
                                                                      x sub i sub 1
TROFF four-character names for anything EQN
doesn’t know about, like \(bs for the Bell Sys-              is
tem sign .
                                                                                       xi   1


6. Spaces, Again                                             A subscript and superscript on the same thing
      The only way EQN can deduce that some                  are printed one above the other if the subscript
sequence of letters might be special is if that              comes ﬁrst:
sequence is separated from the letters on either                      x sub i sup 2
side of it. This can be done by surrounding a
special word by ordinary spaces (or tabs or new-             is
                                                     -3-


                        xi2                                tion 14.

       Other than this special case, sub and sup           9. Fractions
                                              y
group to the right, so x sup y sub z means x ,  z

                                                                   To make a fraction, use the word over:
     y
not x z .
                                                                      a+b over 2c =1
8. Braces for Grouping                                     gives
       Normally, the end of a subscript or super-
script is marked simply by a blank (or tab or                                    _ +b =1
                                                                                 a
                                                                                 ____
                                                                                  2c
tilde, etc.) What if the subscript or superscript
is something that has to be typed with blanks in           The line is made the right length and positioned
it? In that case, you can use the braces { and }           automatically. Braces can be used to make clear
to mark the beginning and end of the subscript             what goes over what:
or superscript:                                                       {alpha + beta} over {sin (x)}
          e sup {i omega t}                                is
is                                                                                _α+β
                                                                                  _____
                           i ωt                                                   sin(x )
                       e
                                                           What happens when there is both an over and a
                                                           sup in the same expression? In such an
Rule: Braces can always be used to force EQN
                                                           apparently ambiguous case, EQN does the sup
to treat something as a unit, or just to make your
                                                           before the over, so
intent perfectly clear. Thus:
                                                                      −b sup 2 over pi
          x sub {i sub 1} sup 2
                                                                                    2
                                                              −b 2               __
is                                                         is ____ instead of −b π The rules which decide
                                                                π
                        xi2  1
                                                           which operation is done ﬁrst in cases like this
                                                           are summarized in section 23. When in doubt,
with braces, but
                                                           however, use braces to make clear what goes
          x sub i sub 1 sup 2                              with what.
is
                                                           10. Square Roots
                        xi 2                                       To draw a square root, use sqrt:
                             1

which is rather different.                                      sqrt a+b + 1 over sqrt {ax sup 2 +bx+c}
        Braces can occur within braces if neces-           is
sary:
                                                                                        1
                                                                           √ + ___________
                                                                           a +b
          e sup {i pi sup {rho +1}}                                                
                                                                                   √ax 2+bx +c
is                                                         Warning — square roots of tall quantities look
                                                           lousy, because a root-sign big enough to cover
                       eiπ
                             ρ+1


                                                           the quantity is too dark and heavy:
The general rule is that anywhere you could use
                                                                      sqrt {a sup 2 over b sub 2}
some single thing like x, you can use an arbi-
trarily complicated thing if you enclose it in             is
braces. EQN will look after all the details of
positioning it and making it the right size.
      In all cases, make sure you have the right
                                                                                  
                                                                                  √     a2
                                                                                        ___
                                                                                        b2

number of braces. Leaving one out or adding an             Big square roots are generally better written as
extra will cause EQN to complain bitterly.                 something to the power 1⁄2 :
                                                                                 (a 2⁄b 2) ⁄
                                                                                          1
     Occasionally you will have to print braces.                                              2



To do this, enclose them in double quotes, like
                                                           which is
"{". Quoting is discussed in more detail in sec-
                                                     -4-


                                                                                     xy
        (a sup 2 /b sub 2 ) sup half
                                                           and
11. Summation, Integral, Etc.                                      size 14 bold x = y +
       Summations, integrals, and similar con-                        size 14 {alpha + beta}
structions are easy:                                       gives
        sum from i=0 to {i= inf} x sup i                                      x=y +α+β
produces                                                   As always, you can use braces if you want to
                        i =∞
                                                           affect something more complicated than a single
                        Σx
                        i =0
                               i
                                                           letter. For example, you can change the size of
                                                           an entire equation by
Notice that we used braces to indicate where the
upper part i =∞ begins and ends. No braces                         size 12 { ... }
were necessary for the lower part i =0, because it
contained no blanks. The braces will never hurt,                 Legal sizes which may follow size are 6,
and if the from and to parts contain any blanks,           7, 8, 9, 10, 11, 12, 14, 16, 18, 20, 22, 24, 28,
you must use braces around them.                           36. You can also change the size by a given
                                                           amount; for example, you can say size +2 to
       The from and to parts are both optional,            make the size two points bigger, or size −3 to
but if both are used, they have to occur in that           make it three points smaller. This has the
order.                                                     advantage that you don’t have to know what the
      Other useful characters can replace the              current size is.
sum in our example:                                               If you are using fonts other than roman,
        int prod union inter                               italic and bold, you can say font X where X is a
                                                           one character TROFF name or number for the
become, respectively,                                      font. Since EQN is tuned for roman, italic and
            ∫      Π           ∪   ∩                       bold, other fonts may not give quite as good an
                                                           appearance.
Since the thing before the from can be anything,
                                                                  The fat operation takes the current font
even something in braces, from-to can often be
                                                           and widens it by overstriking: fat grad is ∇ and
used in unexpected ways:
                                                           fat {x sub i} is xi .
        lim from {n −> inf} x sub n =0                           If an entire document is to be in a non-
is                                                         standard size or font, it is a severe nuisance to
                                                           have to write out a size and font change for each
                    lim xn =0                              equation. Accordingly, you can set a ‘‘global’’
                    n →∞
                                                           size or font which thereafter affects all equa-
                                                           tions. At the beginning of any equation, you
12. Size and Font Changes                                  might say, for instance,
       By default, equations are set in 10-point
                                                                   .EQ
type (the same size as this guide), with standard
                                                                   gsize 16
mathematical conventions to determine what
                                                                   gfont R
characters are in roman and what in italic.
                                                                    ...
Although EQN makes a valiant attempt to use
                                                                   .EN
esthetically pleasing sizes and fonts, it is not
perfect. To change sizes and fonts, use size n             to set the size to 16 and the font to roman
and roman, italic, bold and fat. Like sub and              thereafter. In place of R, you can use any of the
sup, size and font changes affect only the thing           TROFF font names. The size after gsize can be a
that follows them, and revert to the normal                relative change with + or −.
situation at the end of it. Thus                                 Generally, gsize and gfont will appear at
        bold x y                                           the beginning of a document but they can also
                                                           appear thoughout a document: the global font
is                                                         and size can be changed as often as needed. For
                                                           -5-


example, in a footnote‡ you will typically want                  something, but you don’t actually want anything
the size of equations to match the size of the                   in your output. For example, to make 2He, you
footnote text, which is two points smaller than                  can’t just type sup 2 roman He because a sup
the main text. Don’t forget to reset the global                  has to be a superscript on something. Thus you
size at the end of the footnote.                                 must say
                                                                         "" sup 2 roman He
13. Diacritical Marks
      To get funny marks on top of letters, there                       To get a literal quote use ‘‘\"’’. TROFF
are several words:                                               characters like \(bs can appear unquoted, but
                          .                                      more complicated things like horizontal and
         x dot           x
                         ..                                      vertical motions with \h and \v should always be
         x dotdot        x
                                                                 quoted. (If you’ve never heard of \h and \v,
         x hat           x
                         ˆ
                                                                 ignore this section.)
         x tilde         x
                         ˜
                        →
         x vec           x
                        →
                        ←                                        15. Lining Up Equations
         x dyad          x
                                                                       Sometimes it’s necessary to line up a
         x bar         x
         x under        _x                                       series of equations at some horizontal position,
                                                                 often at an equals sign. This is done with two
The diacritical mark is placed at the right height.              operations called mark and lineup.
The bar and under are made the right length for
the entire construct, as in x +y +z ; other marks                       The word mark may appear once at any
                             
                                                            place in an equation. It remembers the horizon-
are centered.
                                                                 tal position where it appeared. Successive equa-
14. Quoted Text                                                  tions can contain one occurrence of the word
                                                                 lineup. The place where lineup appears is made
       Any input entirely within quotes ( "..." ) is             to line up with the place marked by the previous
not subject to any of the font changes and spac-                 mark if at all possible. Thus, for example, you
ing adjustments normally done by the equation                    can say
setter. This provides a way to do your own
spacing and adjusting if needed:                                         .EQ I
                                                                         x+y mark = z
          italic "sin(x)" + sin (x)                                      .EN
is                                                                       .EQ I
                                                                         x lineup = 1
                      sin(x) +sin(x )                                    .EN
      Quotes are also used to get braces and                     to produce
other EQN keywords printed:
                                                                              x +y =z
          "{ size alpha }"
                                                                                x =1
is
                                                                 For reasons too complicated to talk about, when
                     { size alpha }                              you use EQN and ‘−ms’, use either .EQ I or .EQ L.
                                                                 mark and lineup don’t work with centered equa-
and
                                                                 tions. Also bear in mind that mark doesn’t look
          roman "{ size alpha }"                                 ahead;
is                                                                       x mark =1
                                                                          ...
                     { size alpha }
                                                                         x+y lineup =z
      The construction "" is often used as a                     isn’t going to work, because there isn’t room for
place-holder when grammatically EQN needs                        the x+y part after the mark remembers where the
__________________
                                                                 x is.
‡Like this one, in which we have a few random
expressions like xi and π2. The sizes for these were set
by the command gsize −2.
                                                      -6-


16. Big Brackets, Etc.
                                                                     A ˜=˜ left [
       To get big brackets [ ], braces { },                            pile { a above b above c }
parentheses ( ), and bars   around things, use                       ˜˜ pile { x above y above z }
the left and right commands:                                         right ]
         left { a over b + 1 right }                        will make
          ˜=˜ left ( c over d right )
                                                                                   a x 
          + left [ e right ]                                                   A = b y
is                                                                                 c z 
               a  c                                   The elements of the pile (there can be as many
                __ +1  =  __ +  e                     as you want) are centered one above another, at
               b  d                                     the right height for most purposes. The key-
The resulting brackets are made big enough to               word above is used to separate the pieces; braces
cover whatever they enclose. Other characters               are used around the entire list. The elements of
can be used besides these, but the are not likely           a pile can be as complicated as needed, even
to look very good. One exception is the ﬂoor                containing more piles.
and ceiling characters:                                            Three other forms of pile exist: lpile
                                                            makes a pile with the elements left-justiﬁed;
         left ﬂoor x over y right ﬂoor
                                                            rpile makes a right-justiﬁed pile; and cpile
         <= left ceiling a over b right ceiling
                                                            makes a centered pile, just like pile. The verti-
produces                                                    cal spacing between the pieces is somewhat
                      x  a                              larger for l-, r- and cpiles than it is for ordinary
                      _ ≤  __ 
                       _                                    piles.
                     y   b 
                                                              roman sign (x)˜=˜
      Several warnings about brackets are in                  left {
order. First, braces are typically bigger than                   lpile {1 above 0 above −1}
brackets and parentheses, because they are made                  ˜˜ lpile
up of three, ﬁve, seven, etc., pieces, while brack-               {if˜x>0 above if˜x=0 above if˜x<0}
ets can be made up of two, three, etc. Second,              makes
big left and right parentheses often look poor,
because the character set is poorly designed.                                        
                                                                                     1 if x >0
       The right part may be omitted: a ‘‘left                            sign(x ) = 0 if x =0
something’’ need not have a corresponding                                            −1 if x <0
‘‘right something’’. If the right part is omitted,                                   
put braces around the thing you want the left               Notice the left brace without a matching right
bracket to encompass. Otherwise, the resulting              one.
brackets may be too large.
      If you want to omit the left part, things are         18. Matrices
more complicated, because technically you can’t                  It is also possible to make matrices. For
have a right without a corresponding left.                  example, to make a neat array like
Instead you have to say
                                                                                  xi x 2
         left "" ..... right )                                                    yi y 2
for example. The left "" means a ‘‘left noth-               you have to type
ing’’. This satisﬁes the rules without hurting
your output.                                                         matrix {
                                                                       ccol { x sub i above y sub i }
17. Piles                                                              ccol { x sup 2 above y sup 2 }
                                                                     }
      There is a general facility for making vert-
ical piles of things; it comes in several ﬂavors.           This produces a matrix with two centered
For example:                                                columns. The elements of the columns are then
                                                            listed just as for a pile, each element separated
                                                       -7-


by the word above. You can also use lcol or
                                                                      .EQ
rcol to left or right adjust columns. Each
                                                                      delim off
column can be separately adjusted, and there can
                                                                      .EN
be as many columns as you like.
       The reason for using a matrix instead of              Warning: don’t use braces, tildes, circumﬂexes,
two adjacent piles, by the way, is that if the ele-          or double quotes as delimiters — chaos will
ments of the piles don’t all have the same                   result.
height, they won’t line up properly. A matrix
forces them to line up, because it looks at the              20. Deﬁnitions
entire structure before deciding what spacing to                   EQN provides a facility so you can give a
use.                                                         frequently-used string of characters a name, and
       A word of warning about matrices — each               thereafter just type the name instead of the
column must have the same number of elements                 whole string. For example, if the sequence
in it. The world will end if you get this wrong.                     x sub i sub 1 + y sub i sub 1

19. Shorthand for In-line Equations                          appears repeatedly throughout a paper, you can
                                                             save re-typing it each time by deﬁning it like
       In a mathematical document, it is neces-              this:
sary to follow mathematical conventions not just
in display equations, but also in the body of the              deﬁne xy ′x sub i sub 1 + y sub i sub 1′
text, for example by making variable names like              This makes xy a shorthand for whatever charac-
x italic. Although this could be done by sur-                ters occur between the single quotes in the
rounding the appropriate parts with .EQ and .EN,             deﬁnition. You can use any character instead of
the continual repetition of .EQ and .EN is a nui-            quote to mark the ends of the deﬁnition, so long
sance. Furthermore, with ‘−ms’, .EQ and .EN                  as it doesn’t appear inside the deﬁnition.
imply a displayed equation.
                                                                   Now you can use xy like this:
        EQN provides a shorthand for short in-line
expressions. You can deﬁne two characters to                         .EQ
mark the left and right ends of an in-line equa-                     f(x) = xy ...
tion, and then type expressions right in the mid-                    .EN
dle of text lines. To set both the left and right            and so on. Each occurrence of xy will expand
characters to dollar signs, for example, add to              into what it was deﬁned as. Be careful to leave
the beginning of your document the three lines               spaces or their equivalent around the name when
              .EQ                                            you actually use it, so EQN will be able to iden-
              delim $$                                       tify it as special.
              .EN                                                  There are several things to watch out for.
Having done this, you can then say things like               First, although deﬁnitions can use previous
                                                             deﬁnitions, as in
              Let $alpha sub i$ be the primary
              variable, and let $beta$ be zero. Then                  .EQ
              we can show that $x sub 1$ is $>=0$.                    deﬁne xi ′ x sub i ′
                                                                      deﬁne xi1 ′ xi sub 1 ′
This works as you might expect — spaces, new-                         .EN
lines, and so on are signiﬁcant in the text, but
not in the equation part itself. Multiple equa-              don’t deﬁne something in terms of itself’ A
tions can occur in a single input line.                      favorite error is to say
      Enough room is left before and after a line                    deﬁne X ′ roman X ′
that contains in-line expressions that something             This is a guaranteed disaster, since X is now
        n
like   Σ xi does not interfere with the lines sur-
       i =1
                                                             deﬁned in terms of itself. If you say
rounding it.                                                         deﬁne X ′ roman "X" ′
        To turn off the delimiters,                          however, the quotes protect the second X, and
                                                             everything works ﬁne.
                                                              -8-


     EQN keywords can be redeﬁned. You can                          { S sub 2 sup {k sub 2} } over {2 sup k sub 2 k sub 2 ! } ˜
                                                                    ...
make / mean over by saying
                                                                    { S sub m sup {k sub m} } over {m sup k sub m k sub m ! }
         deﬁne / ′ over ′                                           right ) z sup m
                                                                    .EN
or redeﬁne over as / with
         deﬁne over ′ / ′
                                                                    23. Keywords, Precedences, Etc.
      If you need different things to print on a                          If you don’t use braces, EQN will do
terminal and on the typesetter, it is sometimes                     operations in the order shown in this list.
worth deﬁning a symbol differently in NEQN and
                                                                       dyad vec under bar tilde hat dot dotdot
EQN. This can be done with ndeﬁne and tdeﬁne.
                                                                       fwd back down up
A deﬁnition made with ndeﬁne only takes effect
                                                                       fat roman italic bold size
if you are running NEQN; if you use tdeﬁne, the
                                                                       sub sup sqrt over
deﬁnition only applies for EQN. Names deﬁned
                                                                       from to
with plain deﬁne apply to both EQN and NEQN.
                                                                    These operations group to the left:
21. Local Motions
                                                                             over sqrt left right
       Although EQN tries to get most things at
the right place on the paper, it isn’t perfect, and                 All others group to the right.
occasionally you will need to tune the output to                          Digits, parentheses, brackets, punctuation
make it just right. Small extra horizontal spaces                   marks, and these mathematical words are con-
can be obtained with tilde and circumﬂex. You                       verted to Roman font when encountered:
can also say back n and fwd n to move small
                                                                             sin cos tan sinh cosh tanh arc
amounts horizontally. n is how far to move in
                                                                             max min lim log ln exp
1/100’s of an em (an em is about the width of
                                                                             Re Im and if for det
the letter ‘m’.) Thus back 50 moves back about
half the width of an m. Similarly you can move                      These character sequences are recognized and
things up or down with up n and down n. As                          translated as shown.
with sub or sup, the local motions affect the
next thing in the input, and this can be some-                               >=                   ≥
thing arbitrarily complicated if it is enclosed in                           <=                   ≤
braces.                                                                      ==                   ≡
                                                                             !=                   ≠
22. A Large Example                                                          +−                   ±
      Here is the complete source for the three                              −>                   →
display equations in the abstract of this guide.                             <−                   ←
                                                                             <<                   < <
.EQ I                                                                        >>                   > >
G(z)˜mark =˜ e sup { ln ˜ G(z) }                                             inf                  ∞
˜=˜ exp left (                                                               partial              ∂
sum from k>=1 {S sub k z sup k} over k right )
                                                                             half                 1
                                                                                                    ⁄2
˜=˜ prod from k>=1 e sup {S sub k z sup k /k}
.EN                                                                          prime                ′
.EQ I                                                                        approx               ∼
                                                                                                  ∼
lineup = left ( 1 + S sub 1 z +                                              nothing
{ S sub 1 sup 2 z sup 2 } over 2! + ... right )                              cdot                 .
left ( 1+ { S sub 2 z sup 2 } over 2
                                                                             times                ×
+ { S sub 2 sup 2 z sup 4 } over { 2 sup 2 cdot 2! }
+ ... right ) ...                                                            del                  ∇
.EN                                                                          grad                 ∇
.EQ I                                                                        ...                    ...
lineup = sum from m>=0 left (                                                ,...,                ,...,
sum from
pile { k sub 1 ,k sub 2 ,..., k sub m >=0
                                                                             sum                  Σ
above                                                                        int                  ∫
                                                                                                  Π
k sub 1 +2k sub 2 + ... +mk sub m =m}
{ S sub 1 sup {k sub 1} } over {1 sup k sub 1 k sub 1 ! } ˜                  prod
                                                    -9-


        union             ∪                               24. Troubleshooting
        inter             ∩                                     If you make a mistake in an equation, like
                                                          leaving out a brace (very common) or having
      To obtain Greek letters, simply spell them          one too many (very common) or having a sup
out in whatever case you want:                            with nothing before it (common), EQN will tell
                                                          you with the message
   DELTA        ∆          iota         ι                   syntax error between lines x and y, ﬁle z
   GAMMA        Γ          kappa        κ
   LAMBDA       Λ          lambda       λ                 where x and y are approximately the lines
   OMEGA        Ω          mu           µ                 between which the trouble occurred, and z is the
   PHI          Φ          nu           ν                 name of the ﬁle in question. The line numbers
   PI           Π          omega        ω                 are approximate — look nearby as well. There
   PSI          Ψ          omicron      ο                 are also self-explanatory messages that arise if
   SIGMA        Σ          phi          φ                 you leave out a quote or try to run EQN on a
   THETA        Θ          pi           π                 non-existent ﬁle.
   UPSILON      Υ          psi          ψ                       If you want to check a document before
   XI           Ξ          rho          ρ                 actually printing it (on UNIX only),
   alpha        α          sigma        σ
   beta         β          tau          τ                         eqn ﬁles >/dev/null
   chi          χ          theta        θ                 will throw away the output but print the mes-
   delta        δ          upsilon      υ                 sages.
   epsilon      ε          xi           ξ
                                                                If you use something like dollar signs as
   eta          η          zeta         ζ
                                                          delimiters, it is easy to leave one out. This
   gamma        γ
                                                          causes very strange troubles. The program
                                                          checkeq (on GCOS, use ./checkeq instead) checks
      These are all the words known to EQN                for misplaced or missing dollar signs and similar
(except for characters with names), together with         troubles.
the section where they are discussed.
                                                                In-line equations can only be so big
                                                          because of an internal buffer in TROFF. If you
   above        17, 18     lpile        17
                                                          get a message ‘‘word overﬂow’’, you have
   back         21         mark         15
                                                          exceeded this limit. If you print the equation as
   bar          13         matrix       18
                                                          a displayed equation this message will usually
   bold         12         ndeﬁne       20
                                                          go away. The message ‘‘line overﬂow’’ indi-
   ccol         18         over         9
                                                          cates you have exceeded an even bigger buffer.
   col          18         pile         17
                                                          The only cure for this is to break the equation
   cpile        17         rcol         18
                                                          into two separate ones.
   deﬁne        20         right        16
   delim        19         roman        12                      On a related topic, EQN does not break
   dot          13         rpile        17                equations by itself — you must split long equa-
   dotdot       13         size         12                tions up across multiple lines by yourself, mark-
   down         21         sqrt         10                ing each by a separate .EQ ... .EN sequence. EQN
   dyad         13         sub          7                 does warn about equations that are too long to
   fat          12         sup          7                 ﬁt on one line.
   font         12         tdeﬁne       20
   from         11         tilde        13                25. Use on UNIX
   fwd          21         to           11                     To print a document that           contains
   gfont        12         under        13                mathematics on the UNIX typesetter,
   gsize        12         up           21
                                                                  eqn ﬁles  troff
   hat          13         vec          13
   italic       12         ˜, ˆ         4, 6              If there are any TROFF options, they go after the
   lcol         18         {}           8                 TROFF   part of the command. For example,
   left         16         "..."        8, 14
                                                                  eqn ﬁles  troff −ms
   lineup       15
                                                          To run the same document on the GCOS
                                                    - 10 -


typesetter, use
         eqn ﬁles  troff −g (other options)  gcat

       A compatible version of EQN can be used
on devices like teletypes and DASI and GSI termi-
nals which have half-line forward and reverse
capabilities. To print equations on a Model 37
teletype, for example, use
         neqn ﬁles  nroff
The language for equations recognized by NEQN
is identical to that of EQN, although of course
the output is more restricted.
      To use a GSI or DASI terminal as the out-
put device,
         neqn ﬁles  nroff −Tx
where x is the terminal type you are using, such
as 300 or 300S.
      EQN and NEQN can be used with the TBL
program[2] for setting tables that contain
mathematics. Use TBL before [N]EQN, like this:
         tbl ﬁles  eqn  troff
         tbl ﬁles  neqn  nroff


26. Acknowledgments
       We are deeply indebted to J. F. Ossanna,
the author of TROFF, for his willingness to
extend TROFF to make our task easier, and for
his continuous assistance during the develop-
ment and evolution of EQN. We are also grate-
ful to A. V. Aho for advice on language design,
to S. C. Johnson for assistance with the YACC
compiler-compiler, and to all the EQN users who
have made helpful suggestions and criticisms.

References
[1]   J. F. Ossanna, ‘‘NROFF/TROFF User’s
      Manual’’, Bell Laboratories Computing
      Science Technical Report #54, 1976.
[2]   M. E. Lesk, ‘‘Typing Documents on
      UNIX’’,
           Bell Laboratories, 1976.
[3]   M. E. Lesk, ‘‘TBL — A Program for Set-
      ting Tables’’, Bell Laboratories Comput-
      ing Science Technical Report #49, 1976.
                                  Tbl — A Program to Format Tables

                                                        M. E. Lesk
                                                Bell Laboratories
                                          Murray Hill, New Jersey 07974



                                                        ABSTRACT

                 Tbl is a document formatting preprocessor for troff or nroff which makes even
          fairly complex tables easy to specify and enter. It is available on the PDP-11 UNIX* sys-
          tem and on Honeywell 6000 GCOS. Tables are made up of columns which may be
          independently centered, right-adjusted, left-adjusted, or aligned by decimal points.
          Headings may be placed over single columns or groups of columns. A table entry may
          contain equations, or may consist of several rows of text. Horizontal or vertical lines
          may be drawn as desired in the table, and any table or element may be enclosed in a
          box. For example:
                              _
                              _______________________________________
                                      1970 Federal Budget Transfers           
                              
                              _______________________________________
                              _               (in billions of dollars)
                                                                              
                                               Taxes  Money 
                                    State       collected  spent      Net 
                              
                              _______________________________________
                              _
                               New York                             
                                                    22.91  21.35  – 1.56 
                               New Jersey 
                                                     8.33  6.96  – 1.37 
                                                                              
                               Connecticut          4.12  3.10  – 1.02 
                               Maine                0.74  0.67  – 0.07 
                               California      22.29  22.42  +0.13 
                               New Mexico                           
                                                      0.70  1.49  +0.79 
                               Georgia        
                                                     3.30  4.28  +0.98 
                                                                              
                               Mississippi          1.15  2.32  +1.17 
                               Texas                9.33  11.13  +1.80
                              _______________________________________
                              _
                                                                    




January 16, 1979




_
______________
* UNIX is a Trademark/Service Mark of the Bell System
                             Tbl — A Program to Format Tables

                                                M. E. Lesk
                                           Bell Laboratories
                                     Murray Hill, New Jersey 07974


Introduction.
       Tbl turns a simple description of a table into a troff or nroff [1] program (list of commands) that
prints the table. Tbl may be used on the PDP-11 UNIX [2] system and on the Honeywell 6000 GCOS sys-
tem. It attempts to isolate a portion of a job that it can successfully handle and leave the remainder for
other programs. Thus tbl may be used with the equation formatting program eqn [3] or various layout
macro packages [4,5,6], but does not duplicate their functions.
      This memorandum is divided into two parts. First we give the rules for preparing tbl input; then
some examples are shown. The description of rules is precise but technical, and the beginning user may
prefer to read the examples ﬁrst, as they show some common table arrangements. A section explaining
how to invoke tbl precedes the examples. To avoid repetition, henceforth read troff as ‘‘troff or nroff.’’
      The input to tbl is text for a document, with tables preceded by a ‘‘ .TS’’ (table start) command
and followed by a ‘‘ .TE’’ (table end) command. Tbl processes the tables, generating troff formatting
commands, and leaves the remainder of the text unchanged. The ‘‘ .TS’’ and ‘‘ .TE’’ lines are copied,
too, so that troff page layout macros (such as the memo formatting macros [4] ) can use these lines to
delimit and place tables as they see ﬁt. In particular, any arguments on the ‘‘ .TS’’ or ‘‘ .TE’’ lines are
copied but otherwise ignored, and may be used by document layout macro commands.
      The format of the input is as follows:
        text
        .TS
        table
        .TE
        text
        .TS
        table
        .TE
        text
         ...
where the format of each table is as follows:
        .TS
        options ;
        format .
        data
        .TE
Each table is independent, and must contain formatting information followed by the data to be entered in
the table. The formatting information, which describes the individual columns and rows of the table,
may be preceded by a few options that affect the entire table. A detailed description of tables is given
in the next section.
                                                    -2-


Input commands.
      As indicated above, a table contains, ﬁrst, global options, then a format section describing the lay-
out of the table entries, and then the data to be printed. The format and data are always required, but
not the options. The various parts of the table are entered as follows:

1)    OPTIONS. There may be a single line of options affecting the whole table. If present, this line
      must follow the .TS line immediately and must contain a list of option names separated by
      spaces, tabs, or commas, and must be terminated by a semicolon. The allowable options are:
       center         — center the table (default is left-adjust);
       expand         — make the table as wide as the current line length;
       box            — enclose the table in a box;
       allbox         — enclose each item in the table in a box;
       doublebox      — enclose the table in two boxes;
       tab (x)        — use x instead of tab to separate data items.
       linesize (n)   — set lines or rules (e.g. from box) in n point type;
       delim (xy)     — recognize x and y as the eqn delimiters.
      The tbl program tries to keep boxed tables on one page by issuing appropriate ‘‘need’’ ( .ne ) com-
      mands. These requests are calculated from the number of lines in the tables, and if there are spac-
      ing commands embedded in the input, these requests may be inaccurate; use normal troff pro-
      cedures, such as keep-release macros, in that case. The user who must have a multi-page boxed
      table should use macros designed for this purpose, as explained below under ‘Usage.’

2)    FORMAT. The format section of the table speciﬁes the layout of the columns. Each line in this
      section corresponds to one line of the table (except that the last line corresponds to all following
      lines up to the next .T&, if any — see below), and each line contains a key-letter for each column
      of the table. It is good practice to separate the key letters for each column by spaces or tabs.
      Each key-letter is one of the following:
       L or l     to indicate a left-adjusted column entry;
       R or r     to indicate a right-adjusted column entry;
       C or c     to indicate a centered column entry;
       N or n     to indicate a numerical column entry, to be aligned with other numerical entries so
                  that the units digits of numbers line up;
       A or a     to indicate an alphabetic subcolumn; all corresponding entries are aligned on the left,
                  and positioned so that the widest is centered within the column (see example on page
                  12);
       S or s     to indicate a spanned heading, i.e. to indicate that the entry from the previous column
                  continues across this column (not allowed for the ﬁrst column, obviously); or
                  to indicate a vertically spanned heading, i.e. to indicate that the entry from the previ-
        ˆ         ous row continues down through this row. (Not allowed for the ﬁrst row of the table,
                  obviously).
      When numerical alignment is speciﬁed, a location for the decimal point is sought. The rightmost
      dot ( .) adjacent to a digit is used as a decimal point; if there is no dot adjoining a digit, the right-
      most digit is used as a units digit; if no alignment is indicated, the item is centered in the column.
      However, the special non-printing character string \& may be used to override unconditionally dots
      and digits, or to align alphabetic data; this string lines up where a dot normally would, and then
      disappears from the ﬁnal output. In the example below, the items shown at the left will be
      aligned (in a numerical column) as shown on the right:
                                                                -3-


                                                      13                     13
                                                      4 .2                     4 .2
                                                      26 .4 .12            26 .4 .12
                                                      abc                     abc
                                                      abc\&                 abc
                                                      43\&3 .22              433 .22
                                                      749 .12               749 .12

       Note: If numerical data are used in the same column with wider L or r type table entries, the
       widest number is centered relative to the wider L or r items (L is used instead of l for readability;
       they have the same meaning as key-letters). Alignment within the numerical items is preserved.
       This is similar to the behavior of a type data, as explained above. However, alphabetic sub-
       columns (requested by the a key-letter) are always slightly indented relative to L items; if neces-
       sary, the column width is increased to force this. This is not true for n type entries.
       Warning: the n and a items should not be used in the same column.
       For readability, the key-letters describing each column should be separated by spaces. The end of
       the format section is indicated by a period. The layout of the key-letters in the format section
       resembles the layout of the actual data in the table. Thus a simple format might appear as:
            c s s
            l n n .
       which speciﬁes a table of three columns. The ﬁrst line of the table contains a heading centered
       across all three columns; each remaining line contains a left-adjusted item in the ﬁrst column fol-
       lowed by two columns of numerical data. A sample table in this format might be:
                             Overall title
                    Item-a        34.22             9.1
                    Item-b        12.65              .02
                    Items: c,d,e  23                5.8
                    Total         69.87            14.92
       There are some additional features of the key-letter system:
         Horizontal lines — A key-letter may be replaced by ‘_’ (underscore) to indicate a horizontal line
             in place of the corresponding column entry, or by ‘=’ to indicate a double horizontal line. If
             an adjacent column contains a horizontal line, or if there are vertical lines adjoining this
             column, this horizontal line is extended to meet the nearby lines. If any data entry is pro-
             vided for this column, it is ignored and a warning message is printed.
         Vertical lines — A vertical bar may be placed between column key-letters. This will cause a
             vertical line between the corresponding columns of the table. A vertical bar to the left of
             the ﬁrst key-letter or to the right of the last one produces a line at the edge of the table. If
             two vertical bars appear between key-letters, a double vertical line is drawn.
         Space between columns — A number may follow the key-letter. This indicates the amount of
             separation between this column and the next column. The number normally speciﬁes the
             separation in ens (one en is about the width of the letter ‘n’).* If the ‘‘expand’’ option is
             used, then these numbers are multiplied by a constant such that the table is as wide as the
             current line length. The default column separation number is 3. If the separation is
             changed the worst case (largest space requested) governs.
         Vertical spanning — Normally, vertically spanned items extending over several rows of the table
             are centered in their vertical range. If a key-letter is followed by t or T, any corresponding
             vertically spanned item will begin at the top line of its range.

__________________
* More precisely, an en is a number of points (1 point = 1/72 inch) equal to half the current type size.
                                                 -4-


      Font changes — A key-letter may be followed by a string containing a font name or number
          preceded by the letter f or F. This indicates that the corresponding column should be in a
          different font from the default font (usually Roman). All font names are one or two letters;
          a one-letter font name should be separated from whatever follows by a space or tab. The
          single letters B, b, I, and i are shorter synonyms for f B and f I. Font change commands
          given with the table entries override these speciﬁcations.
      Point size changes — A key-letter may be followed by the letter p or P and a number to indi-
          cate the point size of the corresponding table entries. The number may be a signed digit, in
          which case it is taken as an increment or decrement from the current point size. If both a
          point size and a column separation value are given, one or more blanks must separate them.
      Vertical spacing changes — A key-letter may be followed by the letter v or V and a number to
          indicate the vertical line spacing to be used within a multi-line corresponding table entry.
          The number may be a signed digit, in which case it is taken as an increment or decrement
          from the current vertical spacing. A column separation value must be separated by blanks
          or some other speciﬁcation from a vertical spacing request. This request has no effect
          unless the corresponding table entry is a text block (see below).
      Column width indication — A key-letter may be followed by the letter w or W and a width
          value in parentheses. This width is used as a minimum column width. If the largest ele-
          ment in the column is not as wide as the width value given after the w, the largest element
          is assumed to be that wide. If the largest element in the column is wider than the speciﬁed
          value, its width is used. The width is also used as a default line length for included text
          blocks. Normal troff units can be used to scale the width value; if none are used, the
          default is ens. If the width speciﬁcation is a unitless integer the parentheses may be omit-
          ted. If the width value is changed in a column, the last one given controls.
      Equal width columns — A key-letter may be followed by the letter e or E to indicate equal
         width columns. All columns whose key-letters are followed by e or E are made the same
         width. This permits the user to get a group of regularly spaced columns.
      Note: The order of the above features is immaterial; they need not be separated by spaces,
          except as indicated above to avoid ambiguities involving point size and font changes. Thus
          a numerical column entry in italic font and 12 point type with a minimum width of 2.5
          inches and separated by 6 ens from the next column could be speciﬁed as
                      np12w(2 .5i)f I 6
      Alternative notation — Instead of listing the format of successive lines of a table on consecutive
           lines of the format section, successive line formats may be given on the same line, separated
           by commas, so that the format for the example above might have been written:
                        c s s, l n n .
      Default — Column descriptors missing from the end of a format line are assumed to be L. The
          longest line in the format section, however, deﬁnes the number of columns in the table;
          extra columns in the data are ignored silently.

3)   DATA. The data for the table are typed after the format. Normally, each table line is typed as one
     line of data. Very long input lines can be broken: any line whose last character is \ is combined
     with the following line (and the \ vanishes). The data for different columns (the table entries) are
     separated by tabs, or by whatever character has been speciﬁed in the option tabs option. There
     are a few special cases:
      Troff commands within tables — An input line beginning with a ‘ .’ followed by anything but a
          number is assumed to be a command to troff and is passed through unchanged, retaining its
          position in the table. So, for example, space within a table may be produced by ‘‘ .sp’’
          commands in the data.
                                                  -5-


      Full width horizontal lines — An input line containing only the character _ (underscore) or =
          (equal sign) is taken to be a single or double line, respectively, extending the full width of
          the table.
      Single column horizontal lines — An input table entry containing only the character _ or = is
          taken to be a single or double line extending the full width of the column. Such lines are
          extended to meet horizontal or vertical lines adjoining this column. To obtain these charac-
          ters explicitly in a column, either precede them by \& or follow them by a space before the
          usual tab or newline.
      Short horizontal lines — An input table entry containing only the string \_ is taken to be a sin-
          gle line as wide as the contents of the column. It is not extended to meet adjoining lines.
      Repeated characters — An input table entry containing only a string of the form \  \Rx where x is
          any character is replaced by repetitions of the character x as wide as the data in the column.
          The sequence of x ’s is not extended to meet adjoining columns.
      Vertically spanned items — An input table entry containing only the character string \ˆ indicates
          that the table entry immediately above spans downward over this row. It is equivalent to a
          table format key-letter of ‘ˆ’.
      Text blocks — In order to include a block of text as a table entry, precede it by T{ and follow it
          by T} Thus the sequence
              T}.
                  . . . T{
                 block of
                 text
                 T} . . .
          is the way to enter, as a single entry in the table, something that cannot conveniently be
          typed as a simple string between tabs. Note that the T} end delimiter must begin a line;
          additional columns of data may follow after a tab on the same line. See the example on
          page 10 for an illustration of included text blocks in a table. If more than twenty or thirty
          text blocks are used in a table, various limits in the troff program are likely to be exceeded,
          producing diagnostics such as ‘too many string/macro names’ or ‘too many number regis-
          ters.’
          Text blocks are pulled out from the table, processed separately by troff, and replaced in the
          table as a solid block. If no line length is speciﬁed in the block of text itself, or in the table
          format, the default is to use L ×C ⁄(N +1) where L is the current line length, C is the number
          of table columns spanned by the text, and N is the total number of columns in the table.
          The other parameters (point size, font, etc.) used in setting the block of text are those in
          effect at the beginning of the table (including the effect of the ‘‘ .TS’’ macro) and any table
          format speciﬁcations of size, spacing and font, using the p, v and f modiﬁers to the column
          key-letters. Commands within the text block itself are also recognized, of course. However,
          troff commands within the table data but not within the text block do not affect that block.
      Warnings: — Although any number of lines may be present in a table, only the ﬁrst 200 lines
         are used in calculating the widths of the various columns. A multi-page table, of course,
         may be arranged as several single-page tables if this proves to be a problem. Other
         difﬁculties with formatting may arise because, in the calculation of column widths all table
         entries are assumed to be in the font and size being used when the ‘‘ .TS’’ command was
         encountered, except for font and size changes indicated (a) in the table format section and
         (b) within the table data (as in the entry \s+3\fIdata\fP\s0 ). Therefore, although arbitrary
         troff requests may be sprinkled in a table, care must be taken to avoid confusing the width
         calculations; use requests such as ‘ .ps’ with care.

4)   ADDITIONAL COMMAND LINES. If the format of a table must be changed after many similar lines,
     as with sub-headings or summarizations, the ‘‘ .T&’’ (table continue) command can be used to
     change column parameters. The outline of such a table input is:
                                                      -6-


               .TS
               options ;
               format .
               data
               ...
               .T&
               format   .
               data
               .T&
               format   .
               data
               .TE
      as in the examples on pages 10 and 12. Using this procedure, each table line can be close to its
      corresponding format line.
      Warning: it is not possible to change the number of columns, the space between columns, the
      global options such as box, or the selection of columns to be made equal width.

Usage.
      On UNIX, tbl can be run on a simple table with the command
         tbl input-ﬁle  troff
but for more complicated use, where there are several input ﬁles, and they contain equations and ms
memorandum layout commands as well as tables, the normal command would be
         tbl ﬁle-1 ﬁle-2    ...   eqn  troff – ms
and, of course, the usual options may be used on the troff and eqn commands. The usage for nroff is
similar to that for troff, but only TELETYPE® Model 37 and Diablo-mechanism (DASI or GSI) terminals
can print boxed tables directly.
       For the convenience of users employing line printers without adequate driving tables or post-
ﬁlters, there is a special – TX command line option to tbl which produces output that does not have
fractional line motions in it. The only other command line options recognized by tbl are – ms and
– mm which are turned into commands to fetch the corresponding macro ﬁles; usually it is more con-
venient to place these arguments on the troff part of the command line, but they are accepted by tbl as
well.
      Note that when eqn and tbl are used together on the same ﬁle tbl should be used ﬁrst. If there are
no equations within tables, either order works, but it is usually faster to run tbl ﬁrst, since eqn normally
produces a larger expansion of the input than tbl. However, if there are equations within tables (using
the delim mechanism in eqn), tbl must be ﬁrst or the output will be scrambled. Users must also beware
of using equations in n-style columns; this is nearly always wrong, since tbl attempts to split numerical
format items into two parts and this is not possible with equations. The user can defend against this by
giving the delim(xx) table option; this prevents splitting of numerical columns within the delimiters. For
example, if the eqn delimiters are $$ , giving delim($$) a numerical column such as ‘‘1245 $+- 16$’’
will be divided after 1245, not after 16.
       Tbl limits tables to twenty columns; however, use of more than 16 numerical columns may fail
because of limits in troff, producing the ‘too many number registers’ message. Troff number registers
used by tbl must be avoided by the user within tables; these include two-digit names from 31 to 99, and
names of the forms #x, x+, x  , ˆx, and x−, where x is any lower case letter. The names ##, #−, and #ˆ
are also used in certain circumstances. To conserve number register names, the n and a formats share a
register; hence the restriction above that they may not be used in the same column.
     For aid in writing layout macros, tbl deﬁnes a number register TW which is the table width; it is
deﬁned by the time that the ‘‘ .TE’’ macro is invoked and may be used in the expansion of that macro.
More importantly, to assist in laying out multi-page boxed tables the macro T# is deﬁned to produce the
                                                   -7-


bottom lines and side lines of a boxed table, and then invoked at its end. By use of this macro in the
page footer a multi-page table can be boxed. In particular, the ms macros can be used to print a multi-
page boxed table with a repeated heading by giving the argument H to the ‘‘ .TS’’ macro. If the table
start macro is written
       .TS H
a line of the form
       .TH
must be given in the table after any table heading (or at the start if none). Material up to the ‘‘ .TH’’ is
placed at the top of each page of table; the remaining lines in the table are placed on several pages as
required. Note that this is not a feature of tbl, but of the ms layout macros.

Examples.
      Here are some examples illustrating features of tbl. The symbol      T   in the input represents a tab
character.

Input:                                               Output:
                                                     ____________________________________________
   .TS                                                Language      Authors          Runs on     
   box;                                                                                          
                                                      Fortran
   ccc                                                           Many             Almost anything 
                                                                                                 
   l l l.                                             PL/1      IBM              360/370         
   Language   T   Authors   T   Runs on              C          BTL              11/45,H6000,370 
                                                      BLISS     Carnegie-Mellon  PDP-10,11       
   Fortran T Many T Almost anything                   IDS       Honeywell        H6000           
   PL/1 T IBM T 360/370                               Pascal                                     
                                                     _
                                                     ___________________________________________
                                                                 Stanford         370
   C T BTL T 11/45,H6000,370
   BLISS T Carnegie-Mellon T PDP-10,11
   IDS T Honeywell T H6000
   Pascal T Stanford T 370
   .TE
Input:                                               Output:
                                                     _
                                                     ________________________
   .TS                                               _ AT&T Common Stock 
                                                     
                                                     ________________________
                                                                               
                                                     _ Year  Price  Dividend 
   allbox;
                                                     ________________________
                                                     
   css                                                                
   ccc                                               _1971  41-54  $2.60 
                                                     
                                                     ________________________
                                                     
   n n n.                                            _ 2  41-54  2.70 
                                                     ________________________
                                                                     
   AT&T Common Stock                                 _ 3  46-55  2.87 
                                                     ________________________
                                                     
   Year T Price T Dividend                           _ 4  40-53  3.24 
                                                     
                                                     ________________________
   1971 T 41-54 T $2 .60                                                       
                                                     _ 5  45-52  3.40 
                                                     ________________________
                                                     
   2 T 41-54 T 2 .70                                                  
                                                     _ 6  51-59 
                                                     ________________________
                                                                          .95*
   3 T 46-55 T 2 .87
                                                     * (ﬁrst quarter only)
   4 T 40-53 T 3 .24
   5 T 45-52 T 3 .40
   6 T 51-59 T .95*
   .TE
   * (ﬁrst quarter only)
                                               -8-


Input:                                          Output:
                                                ___________________________________________
   .TS                                          __________________________________________
                                                _
                                                _            Major New York Bridges
                                                
   box;                                                                               Length 
                                                __________________________________________
                                                _       Bridge             Designer
   css                                                                J. A. Roebling  1595 
                                                 Brooklyn
   c c c                                       Manhattan                          
   l  l  n.                                                         G. Lindenthal  1470 
                                                __________________________________________
                                                _Williamsburg         L. L. Buck      1600 
   Major New York Bridges                                            Palmer &        1182 
   =                                             Queensborough       Hornbostel     
                                                __________________________________________
                                                _
   Bridge T Designer T Length                                                        
                                                
   _                                                                                  1380 
                                                 Triborough                          _
                                                                                      ________
   Brooklyn T J . A . Roebling T 1595                                 O. H. Ammann 
                                                
   Manhattan T G . Lindenthal T 1470            _                                     383 
                                                __________________________________________
                                                 Bronx Whitestone                   
   Williamsburg T L . L . Buck T 1600
                                                 Throgs Neck         O. H. Ammann  2300 
   _                                                                  O. H. Ammann  1800 
                                                __________________________________________
                                                _
   Queensborough T Palmer & T 1182              _George Washington  O. H. Ammann  3500 
                                                __________________________________________
                                                                                     
    T   Hornbostel
   _
    T T 1380

   Triborough T O . H . Ammann T _
    T T 383

   _
   Bronx Whitestone T O . H . Ammann T 2300
   Throgs Neck T O . H . Ammann T 1800
   _
   George Washington T O . H . Ammann T 3500
   .TE
Input:                                          Output:
   .TS                                               _ Stack
                                                      _______
   cc                                           1    _______
                                                     _ 46
   np-2  n    .                                     23     
                                                     _______
                                                     _
                                                2
    T Stack

    T _
                                                3    _______
                                                     _ 15
                                                     _______
                                                4    _ 6.5 
   1 T 46                                            
    T _                                         5    _______
                                                     _ 2.1 
   2 T 23
    T _

   3 T 15
    T _

   4 T 6 .5
    T _

   5 T 2 .1
    T _

   .TE
                                    -9-


Input:                               Output:
                                     ______________________________
   .TS                                january february    march    
   box;                               april             _
                                                         __________
                                               may
   LLL                                june                        
                                               july       Months 
                                                        _
                                                         __________
                                                         
   LL_                                august  september            
   L L  LB                          ______________________________
                                      october november    december
   LL_
   L L L.
   january T february T march
   april T may
   june T july T Months
   august T september
   october T november T december
   .TE
Input:                               Output:
                                     ___________________________________
   .TS                               ___________________________________
                                              Composition of Foods
   box;                                          ______________________
                                                 _    Percent by Weight     
   cfB s s s .                                                   
                                      Food        Protein  Fat  Carbo- 
   Composition of Foods               __________________________________
   _                                 _                           
                                                                     hydrate
                                                                           
   .T&                                Apples           .4  .5  13.0 
                                                   18.4  5.2  ...
   c  css                            Halibut                              
   c  css                            Lima beans  7.5  .8  22.0 
                                      Milk                   4.0  5.0 
   c  c  c  c.                                  3.3
                                      Mushrooms  3.5  .4  6.0 
   Food T Percent by Weight                                               
   \ˆ T _                             Rye bread  9.0  .6  52.7
                                     ___________________________________
                                                  
   \ˆ T Protein T Fat T Carbo-
   \ˆ T \ˆ T \ˆ T hydrate
   _
   .T&
   l  n  n  n.
   Apples T .4 T .5 T 13 .0
   Halibut T 18 .4 T 5 .2 T . . .
   Lima beans T 7 .5 T .8 T 22 .0
   Milk T 3 .3 T 4 .0 T 5 .0
   Mushrooms T 3 .5 T .4 T 6 .0
   Rye bread T 9 .0 T .6 T 52 .7
   .TE
                                                  - 10 -


Input:                                               Output:
                                                     ______________________________________________
   .TS                                                _____________________________________________
                                                     _                 New York Area Rocks
   allbox;                                                                                                 
                                                      _____________________________________________
                                                     _     Era            Formation         Age (years)
   cfI s s                                                                            
                                                      Precambrian  Reading Prong
                                                     ______________________________________________
                                                                                        >1 billion
   c cw(1i) cw(1i)                                    Paleozoic                                              
   lp9 lp9 lp9 .                                                    Manhattan Prong    400 million
                                                     ______________________________________________
                                                                   Newark Basin,      200 million
   New York Area Rocks                                Mesozoic     incl. Stockton,                         
   Era T Formation T Age (years)                                   Lockatong, and                          
   Precambrian T Reading Prong T >1 billion                                                                
                                                                   Brunswick forma-                        
   Paleozoic T Manhattan Prong T 400 million                       tions; also                             
   Mesozoic T T{                                                   Watchungs and                           
   .na                                                _____________________________________________
                                                     _              Palisades.        
   Newark Basin, incl .                                            Coastal Plain      On Long Island 
   Stockton, Lockatong, and Brunswick                 Cenozoic                        30,000 years; Cre- 
                                                                                      taceous sediments 
   formations; also Watchungs                                                                                
   and Palisades .                                                                    
                                                                                      redeposited       by 
   T} T 200 million                                   _____________________________________________
                                                     _
                                                                                      recent glaciation. 
   Cenozoic T Coastal Plain T T{
   On Long Island 30,000 years;
   Cretaceous sediments redeposited
   by recent glaciation .
   .ad
   T}
   .TE
Input:                                                Output:
                                                     ________________________________
                                                      ________________________________
                                                      _
   .EQ                                                Name              Deﬁnition          
   delim $$                                                                                
   .EN                                                                  ∞                  
                                                     Gamma Γ(z )=∫ 0 t e dt
                                                                              z −1 −t
                                                                                             
                                                                         1 ix −ix          
   ...                                               Sine     sin(x )= _ (e −e )
                                                                          __
                                                                                             
                                                                           2i
                                                                                z          
                                                                erf(z )= ___ ∫ e −t dt
                                                                           2
                                                     Error                                 
                                                                                   2

   .TS                                                                    π 0
                                                                          √
   doublebox;                                                                              
                                                     Bessel             1 π
                                                                         __ ∫ cos(z sinθ)d θ 
   cc                                                           J 0(z )=
                                                                        π 0                
   l l.                                                               ∞
                                                                                             
   Name T Deﬁnition                                  Zeta     ζ(s )= Σ k −s (Re s >1)      
   .sp                                               ________________________________
                                                      _
                                                      
                                                     ________________________________
                                                                       k =1

   .vs +2p
   Gamma T $GAMMA (z) = int sub 0 sup inf t sup {z-1} e sup -t dt$
   Sine T $sin (x) = 1 over 2i ( e sup ix - e sup -ix )$
   Error T $ roman erf (z) = 2 over sqrt pi int sub 0 sup z e sup {-t sup 2} dt$
   Bessel T $ J sub 0 (z) = 1 over pi int sub 0 sup pi cos ( z sin theta ) d theta $
   Zeta T $ zeta (s) = sum from k=1 to inf k sup -s ˜˜( Re˜s > 1)$
   .vs -2p
   .TE
                                                 - 11 -


Input:                                              Output:
                                                    ________________________________________
   .TS                                                             Readability of Text              
   box, tab( : );                                                                                   
                                                    ________________________________________
                                                    
                                                            Line Width and Leading for 10-Point Type
   cb s s s s
                                                     Line  Set  1-Point  2-Point  4-Point 
                                                     Width Solid  Leading  Leading  Leading
   cp-2 s s s s
                                                    ________________________________________
   c c c c c                                    9 Pica  – 9.3  – 6.0  – 5.3  – 7.1 
   c c c c c                                    14 Pica  – 4.5  – 0.6  – 0.3  – 1.7 
   r2   n2  n2  n2  n .                                                                   
   Readability of Text                               19 Pica  – 5.0  – 5.1  0.0  – 2.0 
                                                     31 Pica  – 3.7  – 3.8  – 2.4  – 3.6 
                                                     43 Pica  – 9.1  – 9.0  – 5.9  – 8.8 
                                                                                    
   Line Width and Leading for 10-Point Type
   =                                                ________________________________________
                                                                                             
   Line : Set : 1-Point : 2-Point : 4-Point
   Width : Solid : Leading : Leading : Leading
   _
   9 Pica : \-9 .3 : \-6 .0 : \-5 .3 : \-7 .1
   14 Pica : \-4 .5 : \-0 .6 : \-0 .3 : \-1 .7
   19 Pica : \-5 .0 : \-5 .1 : 0 .0 : \-2 .0
   31 Pica : \-3 .7 : \-3 .8 : \-2 .4 : \-3 .6
   43 Pica : \-9 .1 : \-9 .0 : \-5 .9 : \-8 .8
   .TE
                                      - 12 -


Input:                                   Output:
   .TS                                         Some London Transport Statistics
   cs                                                     (Year 1964)
   cip-2 s                               Railway route miles                  244
   ln                                      Tube                                66
   a n.                                    Sub-surface                         22
   Some London Transport Statistics        Surface                            156
   (Year 1964)
                                         Passenger trafﬁc − railway
   Railway route miles T 244
                                           Journeys                       674 million
   Tube T 66
                                           Average length                  4.55 miles
   Sub-surface T 22
                                           Passenger miles              3,066 million
   Surface T 156
                                         Passenger trafﬁc − road
   .sp .5                                  Journeys                     2,252 million
   .T&                                     Average length                  2.26 miles
   lr
                                           Passenger miles              5,094 million
   a r.
   Passenger trafﬁc \- railway           Vehicles                          12,521
   Journeys T 674 million                  Railway motor cars               2,905
   Average length T 4 .55 miles            Railway trailer cars             1,269
   Passenger miles T 3,066 million         Total railway                    4,174
   .T&                                     Omnibuses                        8,347
   lr
                                         Staff                             73,739
   a r.
                                            Administrative, etc.            5,582
   Passenger trafﬁc \- road
                                            Civil engineering               5,134
   Journeys T 2,252 million
                                            Electrical eng.                 1,714
   Average length T 2 .26 miles
                                            Mech. eng. − railway            4,310
   Passenger miles T 5,094 million
                                            Mech. eng. − road               9,152
   .T&                                      Railway operations              8,930
   ln
                                            Road operations                35,946
   a n.
                                            Other                           2,971
   .sp .5
   Vehicles T 12,521
   Railway motor cars T 2,905
   Railway trailer cars T 1,269
   Total railway T 4,174
   Omnibuses T 8,347
   .T&
   ln
   a n.
   .sp .5
   Staff T 73,739
   Administrative, etc . T 5,582
   Civil engineering T 5,134
   Electrical eng . T 1,714
   Mech . eng . \- railway T 4,310
   Mech . eng . \- road T 9,152
   Railway operations T 8,930
   Road operations T 35,946
   Other T 2,971
   .TE
                                               - 13 -


Input:
   .ps 8
   .vs 10p
   .TS
   center box;
   css
   ci s s
   ccc
   lB l n .
   New Jersey Representatives
   (Democrats)
   .sp .5
   Name T Ofﬁce address T Phone
   .sp .5
   James J . Florio T 23 S . White Horse Pike, Somerdale 08083 T 609-627-8222
   William J . Hughes T 2920 Atlantic Ave ., Atlantic City 08401 T 609-345-4844
   James J . Howard T 801 Bangs Ave ., Asbury Park 07712 T 201-774-1600
   Frank Thompson, Jr . T 10 Rutgers Pl ., Trenton 08618 T 609-599-1619
   Andrew Maguire T 115 W . Passaic St ., Rochelle Park 07662 T 201-843-0240
   Robert A . Roe T U .S .P .O ., 194 Ward St ., Paterson 07510 T 201-523-5152
   Henry Helstoski T 666 Paterson Ave ., East Rutherford 07073 T 201-939-9090
   Peter W . Rodino, Jr . T Suite 1435A, 970 Broad St ., Newark 07102 T 201-645-3213
   Joseph G . Minish T 308 Main St ., Orange 07050 T 201-645-6363
   Helen S . Meyner T 32 Bridge St ., Lambertville 08530 T 609-397-1830
   Dominick V . Daniels T 895 Bergen Ave ., Jersey City 07306 T 201-659-7700
   Edward J . Patten T Natl . Bank Bldg ., Perth Amboy 08861 T 201-826-4610
   .sp .5
   .T&
   ci s s
   lB l n .
   (Republicans)
   .sp .5v
   Millicent Fenwick T 41 N . Bridge St ., Somerville 08876 T 201-722-8200
   Edwin B . Forsythe T 301 Mill St ., Moorestown 08057 T 609-235-6622
   Matthew J . Rinaldo T 1961 Morris Ave ., Union 07083 T 201-687-4235
   .TE
   .ps 10
   .vs 12p
                                                   - 14 -


Output:
                __________________________________________________________________________
                                         New Jersey Representatives                         
                                                 (Democrats)                                
                                                                                            
                         Name                        Ofﬁce address                Phone     
                                                                                            
                 James J. Florio      23 S. White Horse Pike, Somerdale 08083  609-627-8222 
                 William J. Hughes    2920 Atlantic Ave., Atlantic City 08401  609-345-4844 
                                                                                            
                 James J. Howard      801 Bangs Ave., Asbury Park 07712        201-774-1600 
                 Frank Thompson, Jr. 10 Rutgers Pl., Trenton 08618             609-599-1619 
                 Andrew Maguire       115 W. Passaic St., Rochelle Park 07662  201-843-0240 
                 Robert A. Roe        U.S.P.O., 194 Ward St., Paterson 07510   201-523-5152 
                                                                                            
                 Henry Helstoski      666 Paterson Ave., East Rutherford 07073 201-939-9090 
                 Peter W. Rodino, Jr. Suite 1435A, 970 Broad St., Newark 07102 201-645-3213 
                 Joseph G. Minish     308 Main St., Orange 07050               201-645-6363 
                 Helen S. Meyner      32 Bridge St., Lambertville 08530        609-397-1830 
                                                                                            
                 Dominick V. Daniels  895 Bergen Ave., Jersey City 07306       201-659-7700 
                 Edward J. Patten     Natl. Bank Bldg., Perth Amboy 08861      201-826-4610 
                                                                                            
                                                (Republicans)                               
                                                                                            
                 Millicent Fenwick    41 N. Bridge St., Somerville 08876       201-722-8200 
                 Edwin B. Forsythe    301 Mill St., Moorestown 08057           609-235-6622 
                 Matthew J. Rinaldo
                __________________________________________________________________________
                                       1961 Morris Ave., Union 07083            201-687-4235 
                

This is a paragraph of normal text placed here only to indicate where the left and right margins are. In
this way the reader can judge the appearance of centered tables or expanded tables, and observe how
such tables are formatted.

Input:
   .TS
   expand;
   csss
   cccc
   l l n n.
   Bell Labs Locations
   Name T Address T Area Code T Phone
   Holmdel T Holmdel, N . J . 07733 T 201 T 949-3000
   Murray Hill T Murray Hill, N . J . 07974 T 201 T 582-6377
   Whippany T Whippany, N . J . 07981 T 201 T 386-3000
   Indian Hill T Naperville, Illinois 60540 T 312 T 690-2000
   .TE
Output:
                                           Bell Labs Locations
   Name                            Address                              Area Code                 Phone
Holmdel                    Holmdel, N. J. 07733                            201                   949-3000
Murray Hill                Murray Hill, N. J. 07974                        201                   582-6377
Whippany                   Whippany, N. J. 07981                           201                   386-3000
Indian Hill                Naperville, Illinois 60540                      312                   690-2000
                                                                                 - 15 -


Input:
   . TS
   box;
   cb s s s
   c c c s
                                     .
   ltiw(1i)  ltw(2i)  lp8  lw(1 6i)p8         .
   Some Interesting Places
   _
   Name T Description T Practical Information
   _
   T{
   American Museum of Natural History
   T} T T{
                         .
   The collections ﬁll 11 5 acres (Michelin) or 25 acres (MTA)
                                         .
   of exhibition halls on four ﬂoors There is a full-sized replica
   of a blue whale and the world’s largest star sapphire (stolen in 1964)                     .
                          .
   T} T Hours T 10-5, ex Sun 11-5, Wed to 9              .
   \ˆ T \ˆ T Location T T{
   Central Park West & 79th St       .
   T}
   \ˆ T \ˆ T Admission T Donation: $1 00 asked   .
   \ˆ T \ˆ T Subway T AA to 81st St          .
   \ˆ T \ˆ T Telephone T 212-873-4225
   _
   Bronx Zoo T T{
                             .
   About a mile long and 6 mile wide, this is the largest zoo in America                          .
   A lion eats 18 pounds
   of meat a day while a sea lion eats 15 pounds of ﬁsh                  .
   T} T Hours T T{
   10-4:30 winter, to 5:00 summer
   T}
   \ˆ T \ˆ T Location T T{
           .
   185th St & Southern Blvd, the Bronx               .
   T}
                                 .
   \ˆ T \ˆ T Admission T $1 00, but Tu,We,Th free
   \ˆ T \ˆ T Subway T 2, 5 to East Tremont Ave                   .
   \ˆ T \ˆ T Telephone T 212-933-1759
   _
   Brooklyn Museum T T{
   Five ﬂoors of galleries contain American and ancient art                  .
   There are American period rooms and architectural ornaments saved
   from wreckers, such as a classical ﬁgure from Pennsylvania Station                     .
   T} T Hours T Wed-Sat, 10-5, Sun 12-5
   \ˆ T \ˆ T Location T T{
   Eastern Parkway & Washington Ave , Brooklyn   .                   .
   T}
   \ˆ T \ˆ T Admission T Free
   \ˆ T \ˆ T Subway T 2,3 to Eastern Parkway                 .
   \ˆ T \ˆ T Telephone T 212-638-5000
   _
   T{
   New-York Historical Society
   T} T T{
   All the original paintings for Audubon’s
   . I
   Birds of America
   . R
   are here, as are exhibits of American decorative arts, New York history,
   Hudson River school paintings, carriages, and glass paperweights                   .
   T} T Hours T T{
   Tues-Fri & Sun, 1-5; Sat 10-5
   T}
   \ˆ T \ˆ T Location T T{
   Central Park West & 77th St       .
   T}
   \ˆ T \ˆ T Admission T Free
   \ˆ T \ˆ T Subway T AA to 81st St          .
   \ˆ T \ˆ T Telephone T 212-873-3400
   . TE
                                                 - 16 -


Output:
_____________________________________________________________________________________
____________________________________________________________________________________
_                                     Some Interesting Places
                                                                                                    
____________________________________________________________________________________
_       Name                     Description                         Practical Information
                    The collections ﬁll 11.5 acres  Hours            10-5, ex. Sun 11-5, Wed. to 9
 American Muse-                                                                                     
 um of Natural  (Michelin) or 25 acres (MTA) of  Location  Central Park West & 79th St.            
 History                                                                                             
                    exhibition halls on four ﬂoors.  Admission  Donation: $1.00 asked
                   There is a full-sized replica of a  Subway                                       
                                                                      AA to 81st St.
                                                                                                       
                    blue whale and the world’s largest  Telephone  212-873-4225
                   star sapphire (stolen in 1964).                                                  
                                                                      
____________________________________________________________________________________
_                                                                    10-4:30 winter, to 5:00 summer
 Bronx Zoo         About a mile long and .6 mile  Hours                                             
                                                                     
                    wide, this is the largest zoo in  Location  185th St. & Southern Blvd, the 
                   America. A lion eats 18 pounds                                                   
                                                                      Bronx.                         
                    of meat a day while a sea lion eats  Admission  $1.00, but Tu,We,Th free
                                                        Subway                                      
                                                                      2, 5 to East Tremont Ave.      
                    15 pounds of ﬁsh.                               
____________________________________________________________________________________
_                                                        Telephone  212-933-1759
                                                                                                    
 Brooklyn Museum  Five ﬂoors of galleries contain  Hours            Wed-Sat, 10-5, Sun 12-5        
                    American and ancient art. There       Location    Eastern Parkway & Washington 
                                                                     Ave., Brooklyn.
                   are American period rooms and ar-                                                
                                                          Admission  Free                            
                    chitectural ornaments saved from 
                                                                       2,3 to Eastern Parkway.
                   wreckers, such as a classical ﬁgure  Subway                                      
                                                                      212-638-5000                   
_                   from Pennsylvania Station.          
____________________________________________________________________________________
                                                           Telephone
                                                                      
                    All the original paintings for  Hours            Tues-Fri & Sun, 1-5; Sat 10-5
 New-York Histor-                                                                                   
 ical Society      Audubon’s Birds of America are  Location  Central Park West & 77th St.          
                   here, as are exhibits of American  Admission  Free                              
                                                                                                     
                    decorative arts, New York history,  Subway       AA to 81st St.
                   Hudson River school paintings,  Telephone  212-873-3400                         
                   carriages, and glass paperweights.                                               
                                                                      
____________________________________________________________________________________
_                                                                   

Acknowledgments.
      Many thanks are due to J. C. Blinn, who has done a large amount of testing and assisted with the
design of the program. He has also written many of the more intelligible sentences in this document
and helped edit all of it. All phototypesetting programs on UNIX are dependent on the work of the late J.
F. Ossanna, whose assistance with this program in particular had been most helpful. This program is
patterned on a table formatter originally written by J. F. Gimpel. The assistance of T. A. Dolotta, B. W.
Kernighan, and J. N. Sturman is gratefully acknowledged.

References.
[1]   J. F. Ossanna, NROFF/TROFF User’s Manual, Computing Science Technical Report No. 54, Bell
      Laboratories, 1976.
[2]   K. Thompson and D. M. Ritchie, ‘‘The UNIX Time-Sharing System,’’ Comm. ACM. 17, pp.
      365−75 (1974).
[3]   B. W. Kernighan and L. L. Cherry, ‘‘A System for Typesetting Mathematics,’’ Comm. ACM. 18,
      pp. 151−57 (1975).
[4]   M. E. Lesk, Typing Documents on UNIX, UNIX Programmer’s Manual, Volume 2.
[5]   M. E. Lesk and B. W. Kernighan, Computer Typesetting of Technical Journals on UNIX, Proc.
      AFIPS NCC, vol. 46, pp. 879-888 (1977).
[6]   J. R. Mashey and D. W. Smith, ‘‘Documentation Tools and Techniques,’’ Proc. 2nd Int. Conf. on
      Software Engineering, pp. 177-181 (October, 1976).
                         - 17 -


      List of Tbl Command Characters and Words
Command                    Meaning               Section
aA             Alphabetic subcolumn                  2
allbox         Draw box around all items             1
bB             Boldface item                         2
box            Draw box around table                 1
cC             Centered column                       2
center         Center table in page                  1
doublebox      Doubled box around table              1
eE             Equal width columns                   2
expand         Make table full line width            1
fF             Font change                           2
iI             Italic item                           2
lL             Left adjusted column                  2
nN             Numerical column                      2
nnn            Column separation                     2
pP             Point size change                     2
rR             Right adjusted column                 2
sS             Spanned item                          2
tT             Vertical spanning at top              2
tab (x )       Change data separator character       1
T{ T}          Text block                            3
vV             Vertical spacing change               2
wW             Minimum width value                   2
.xx            Included troff command                3
              Vertical line                         2
             Double vertical line                  2
ˆ              Vertical span                         2
\ˆ             Vertical span                         3
=              Double horizontal line              2,3
_              Horizontal line                     2,3
\_             Short horizontal line                 3
\
\Rx            Repeat character                      3
                                      Bell Laboratories
                                Murray Hill, New Jersey 07974




                           Computing Science Technical Report No. 69

                Some Applications of Inverted Indexes on the UNIX System

                                          M. E. Lesk




June 21, 1978
                Some Applications of Inverted Indexes on the UNIX System

                                               M. E. Lesk
                                          Bell Laboratories
                                    Murray Hill, New Jersey 07974



                                              ABSTRACT

        I. Some Applications of Inverted Indexes – Overview
             This memorandum describes a set of programs which make inverted indexes to
        UNIX* text ﬁles, and their application to retrieving and formatting citations for docu-
        ments prepared using troff.
               These indexing and searching programs make keyword indexes to volumes of
        material too large for linear searching. Searches for combinations of single words can
        be performed quickly. The programs are divided into two phases. The ﬁrst makes an
        index from the original data; the second searches the index and retrieves items. Both
        of these phases are further divided into two parts to separate the data-dependent and
        algorithm dependent code.
               The major current application of these programs is the troff preprocessor refer.
        A list of 4300 references is maintained on line, containing primarily papers written and
        cited by local authors. Whenever one of these references is required in a paper, a few
        words from the title or author list will retrieve it, and the user need not bother to re-
        enter the exact citation. Alternatively, authors can use their own lists of papers.
               This memorandum is of interest to those who are interested in facilities for
        searching large but relatively unchanging text ﬁles on the UNIX system, and those who
        are interested in handling bibliographic citations with UNIX troff.
        II. Updating Publication Lists
               This section is a brief note describing the auxiliary programs for managing the
        updating processing. It is written to aid clerical users in maintaining lists of refer-
        ences. Primarily, the programs described permit a large amount of individual control
        over the content of publication lists while retaining the usefulness of the ﬁles to other
        users.
        III. Manual Pages
              This section contains the pages from the UNIX programmer’s manual for the
        lookall, pubindex, and refer commands. It is useful for reference.

        _
        ___________________________________________
        * UNIX is a Trademark of Bell Laboratories.



June 21, 1978
                 Some Applications of Inverted Indexes on the UNIX System

                                                      M. E. Lesk
                                                   Bell Laboratories
                                             Murray Hill, New Jersey 07974


1. Introduction.
      The UNIX† system has many utilities (e.g. grep, awk, lex, egrep, fgrep, ...) to search through ﬁles
of text, but most of them are based on a linear scan through the entire ﬁle, using some deterministic
automaton. This memorandum discusses a program which uses inverted indexes1 and can thus be used
on much larger data bases.
       As with any indexing system, of course, there are some disadvantages; once an index is made, the
ﬁles that have been indexed can not be changed without remaking the index. Thus applications are res-
tricted to those making many searches of relatively stable data. Furthermore, these programs depend on
hashing, and can only search for exact matches of whole keywords. It is not possible to look for arith-
metic or logical expressions (e.g. ‘‘date greater than 1970’’) or for regular expression searching such as
that in lex.2
      Currently there are two uses of this software, the refer preprocessor to format references, and the
lookall command to search through all text ﬁles on the UNIX system.
       The remaining sections of this memorandum discuss the searching programs and their uses. Sec-
tion 2 explains the operation of the searching algorithm and describes the data collected for use with the
lookall command. The more important application, refer has a user’s description in section 3. Section
4 goes into more detail on reference ﬁles for the beneﬁt of those who wish to add references to data
bases or write new troff macros for use with refer. The options to make refer collect identical citations,
or otherwise relocate and adjust references, are described in section 5. The UNIX manual sections for
refer, lookall, and associated commands are attached as appendices.

2. Searching.
     The indexing and searching process is divided into two phases, each made of two parts. These are
shown below.
A.     Construct the index.
       (1)    Find keys — turn the input ﬁles into a sequence of tags and keys, where each tag identiﬁes
              a distinct item in the input and the keys for each such item are the strings under which it is
              to be indexed.
       (2)    Hash and sort — prepare a set of inverted indexes from which, given a set of keys, the
              appropriate item tags can be found quickly.
B.     Retrieve an item in response to a query.



__________________
†UNIX is a Trademark of Bell Laboratories.
1.     D. Knuth, The Art of Computer Programming: Vol. 3, Sorting and Searching, Addison-Wesley, Reading, Mass. (1977).
       See section 6.5.
2.     M. E. Lesk, ‘‘Lex — A Lexical Analyzer Generator,’’ Comp. Sci. Tech. Rep. No. 39, Bell Laboratories, Murray Hill,
       New Jersey (D).
                                                     -2-


      (3)   Search — Given some keys, look through the ﬁles prepared by the hashing and sorting facil-
            ity and derive the appropriate tags.
      (4)   Deliver — Given the tags, ﬁnd the original items. This completes the searching process.
The ﬁrst phase, making the index, is presumably done relatively infrequently. It should, of course, be
done whenever the data being indexed change. In contrast, the second phase, retrieving items, is
presumably done often, and must be rapid.
       An effort is made to separate code which depends on the data being handled from code which
depends on the searching procedure. The search algorithm is involved only in steps (2) and (3), while
knowledge of the actual data ﬁles is needed only by steps (1) and (4). Thus it is easy to adapt to dif-
ferent data ﬁles or different search algorithms.
       To start with, it is necessary to have some way of selecting or generating keys from input ﬁles.
For dealing with ﬁles that are basically English, we have a key-making program which automatically
selects words and passes them to the hashing and sorting program (step 2). The format used has one
line for each input item, arranged as follows:
        name:start,length (tab) key1 key2 key3 ...
where name is the ﬁle name, start is the starting byte number, and length is the number of bytes in the
entry.
      These lines are the only input used to make the index. The ﬁrst ﬁeld (the ﬁle name, byte position,
and byte count) is the tag of the item and can be used to retrieve it quickly. Normally, an item is either
a whole ﬁle or a section of a ﬁle delimited by blank lines. After the tab, the second ﬁeld contains the
keys. The keys, if selected by the automatic program, are any alphanumeric strings which are not
among the 100 most frequent words in English and which are not entirely numeric (except for four-digit
numbers beginning 19, which are accepted as dates). Keys are truncated to six characters and converted
to lower case. Some selection is needed if the original items are very large. We normally just take the
ﬁrst n keys, with n less than 100 or so; this replaces any attempt at intelligent selection. One ﬁle in our
system is a complete English dictionary; it would presumably be retrieved for all queries.
       To generate an inverted index to the list of record tags and keys, the keys are hashed and sorted to
produce an index. What is wanted, ideally, is a series of lists showing the tags associated with each
key. To condense this, what is actually produced is a list showing the tags associated with each hash
code, and thus with some set of keys. To speed up access and further save space, a set of three or pos-
sibly four ﬁles is produced. These ﬁles are:
                                     File             Contents
                                   entry      Pointers to posting ﬁle
                                              for each hash code
                                   posting    Lists of tag pointers for
                                              each hash code
                                   tag        Tags for each item
                                   key        Keys for each item
                                              (optional)
The posting ﬁle comprises the real data: it contains a sequence of lists of items posted under each hash
code. To speed up searching, the entry ﬁle is an array of pointers into the posting ﬁle, one per potential
hash code. Furthermore, the items in the lists in the posting ﬁle are not referred to by their complete
tag, but just by an address in the tag ﬁle, which gives the complete tags. The key ﬁle is optional and
contains a copy of the keys used in the indexing.
      The searching process starts with a query, containing several keys. The goal is to obtain all items
which were indexed under these keys. The query keys are hashed, and the pointers in the entry ﬁle used
to access the lists in the posting ﬁle. These lists are addresses in the tag ﬁle of documents posted under
the hash codes derived from the query. The common items from all lists are determined; this must
include the items indexed by every key, but may also contain some items which are false drops, since
items referenced by the correct hash codes need not actually have contained the correct keys. Normally,
                                                  -3-


if there are several keys in the query, there are not likely to be many false drops in the ﬁnal combined
list even though each hash code is somewhat ambiguous. The actual tags are then obtained from the tag
ﬁle, and to guard against the possibility that an item has false-dropped on some hash code in the query,
the original items are normally obtained from the delivery program (4) and the query keys checked
against them by string comparison.
      Usually, therefore, the check for bad drops is made against the original ﬁle. However, if the key
derivation procedure is complex, it may be preferable to check against the keys fed to program (2). In
this case the optional key ﬁle which contains the keys associated with each item is generated, and the
item tag is supplemented by a string
        ;start,length
which indicates the starting byte number in the key ﬁle and the length of the string of keys for each
item. This ﬁle is not usually necessary with the present key-selection program, since the keys always
appear in the original document.
       There is also an option (-Cn ) for coordination level searching. This retrieves items which match
all but n of the query keys. The items are retrieved in the order of the number of keys that they match.
Of course, n must be less than the number of query keys (nothing is retrieved unless it matches at least
one key).
       As an example, consider one set of 4377 references, comprising 660,000 bytes. This included
51,000 keys, of which 5,900 were distinct keys. The hash table is kept full to save space (at the
expense of time); 995 of 997 possible hash codes were used. The total set of index ﬁles (no key ﬁle)
included 171,000 bytes, about 26% of the original ﬁle size. It took 8 minutes of processor time to hash,
sort, and write the index. To search for a single query with the resulting index took 1.9 seconds of pro-
cessor time, while to ﬁnd the same paper with a sequential linear search using grep (reading all of the
tags and keys) took 12.3 seconds of processor time.
      We have also used this software to index all of the English stored on our UNIX system. This is the
index searched by the lookall command. On a typical day there were 29,000 ﬁles in our user ﬁle sys-
tem, containing about 152,000,000 bytes. Of these 5,300 ﬁles, containing 32,000,000 bytes (about 21%)
were English text. The total number of ‘words’ (determined mechanically) was 5,100,000. Of these
227,000 were selected as keys; 19,000 were distinct, hashing to 4,900 (of 5,000 possible) different hash
codes. The resulting inverted ﬁle indexes used 845,000 bytes, or about 2.6% of the size of the original
ﬁles. The particularly small indexes are caused by the fact that keys are taken from only the ﬁrst 50
non-common words of some very long input ﬁles.
       Even this large lookall index can be searched quickly. For example, to ﬁnd this document by
looking for the keys ‘‘lesk inverted indexes’’ required 1.7 seconds of processor time and system time.
By comparison, just to search the 800,000 byte dictionary (smaller than even the inverted indexes, let
alone the 32,000,000 bytes of text ﬁles) with grep takes 29 seconds of processor time. The lookall pro-
gram is thus useful when looking for a document which you believe is stored on-line, but do not know
where. For example, many memos from the Computing Science Research Center are in its UNIX ﬁle
system, but it is often difﬁcult to guess where a particular memo might be (it might have several
authors, each with many directories, and have been worked on by a secretary with yet more directories).
Instructions for the use of the lookall command are given in the manual section, shown in the appendix
to this memorandum.
       The only indexes maintained routinely are those of publication lists and all English ﬁles. To make
other indexes, the programs for making keys, sorting them, searching the indexes, and delivering
answers must be used. Since they are usually invoked as parts of higher-level commands, they are not
in the default command directory, but are available to any user in the directory /usr/lib/refer . Three
programs are of interest: mkey , which isolates keys from input ﬁles; inv , which makes an index from a
set of keys; and hunt , which searches the index and delivers the items. Note that the two parts of the
retrieval phase are combined into one program, to avoid the excessive system work and delay which
would result from running these as separate processes.
      These three commands have a large number of options to adapt to different kinds of input. The
                                                    -4-


user not interested in the detailed description that now follows may skip to section 3, which describes
the refer program, a packaged-up version of these tools speciﬁcally oriented towards formatting refer-
ences.
       Make Keys. The program mkey is the key-making program corresponding to step (1) in phase A.
Normally, it reads its input from the ﬁle names given as arguments, and if there are no arguments it
reads from the standard input. It assumes that blank lines in the input delimit separate items, for each of
which a different line of keys should be generated. The lines of keys are written on the standard output.
Keys are any alphanumeric string in the input not among the most frequent words in English and not
entirely numeric (except that all-numeric strings are acceptable if they are between 1900 and 1999). In
the output, keys are translated to lower case, and truncated to six characters in length; any associated
punctuation is removed. The following ﬂag arguments are recognized by mkey:
           – c name     Name of ﬁle of common words; default is /usr/lib/eign.
           – f name     Read a list of ﬁles from name and take each as an input argument.
           – i chars    Ignore all lines which begin with ‘%’ followed by any character in
                        chars .
           – kn         Use at most n keys per input item.
           – ln         Ignore items shorter than n letters long.
           – nm         Ignore as a key any word in the ﬁrst m words of the list of common
                        English words. The default is 100.
           –s           Remove the labels (ﬁle:start,length) from the output; just give the
                        keys. Used when searching rather than indexing.
           –w           Each whole ﬁle is a separate item; blank lines in ﬁles are irrelevant.

      The normal arguments for indexing references are the defaults, which are – c /usr/lib/eign , – n100 ,
and – l3 . For searching, the – s option is also needed. When the big lookall index of all English ﬁles
is run, the options are – w , – k50 , and – f (ﬁlelist) . When running on textual input, the mkey program
processes about 1000 English words per processor second. Unless the – k option is used (and the input
ﬁles are long enough for it to take effect) the output of mkey is comparable in size to its input.
      Hash and invert. The inv program computes the hash codes and writes the inverted ﬁles. It
reads the output of mkey and writes the set of ﬁles described earlier in this section. It expects one argu-
ment, which is used as the base name for the three (or four) ﬁles to be written. Assuming an argument
of Index (the default) the entry ﬁle is named Index.ia , the posting ﬁle Index.ib , the tag ﬁle Index.ic , and
the key ﬁle (if present) Index.id . The inv program recognizes the following options:
          –a              Append the new keys to a previous set of inverted ﬁles, making new
                          ﬁles if there is no old set using the same base name.
          –d              Write the optional key ﬁle. This is needed when you can not check
                          for false drops by looking for the keys in the original inputs, i.e.
                          when the key derivation procedure is complicated and the output keys
                          are not words from the input ﬁles.
          – hn            The hash table size is n (default 997); n should be prime. Making n
                          bigger saves search time and spends disk space.
          – i[u] name     Take input from ﬁle name , instead of the standard input; if u is
                          present name is unlinked when the sort is started. Using this option
                          permits the sort scratch space to overlap the disk space used for input
                          keys.
          –n              Make a completely new set of inverted ﬁles, ignoring previous ﬁles.
          –p              Pipe into the sort program, rather than writing a temporary input ﬁle.
                          This saves disk space and spends processor time.
          –v              Verbose mode; print a summary of the number of keys which
                          ﬁnished indexing.

     About half the time used in inv is in the contained sort. Assuming the sort is roughly linear,
however, a guess at the total timing for inv is 250 keys per second. The space used is usually of more
                                                   -5-


importance: the entry ﬁle uses four bytes per possible hash (note the – h option), and the tag ﬁle around
15-20 bytes per item indexed. Roughly, the posting ﬁle contains one item for each key instance and one
item for each possible hash code; the items are two bytes long if the tag ﬁle is less than 65336 bytes
long, and the items are four bytes wide if the tag ﬁle is greater than 65536 bytes long. To minimize
storage, the hash tables should be over-full; for most of the ﬁles indexed in this way, there is no other
real choice, since the entry ﬁle must ﬁt in memory.
       Searching and Retrieving. The hunt program retrieves items from an index. It combines, as
mentioned above, the two parts of phase (B): search and delivery. The reason why it is efﬁcient to
combine delivery and search is partly to avoid starting unnecessary processes, and partly because the
delivery operation must be a part of the search operation in any case. Because of the hashing, the
search part takes place in two stages: ﬁrst items are retrieved which have the right hash codes associ-
ated with them, and then the actual items are inspected to determine false drops, i.e. to determine if
anything with the right hash codes doesn’t really have the right keys. Since the original item is
retrieved to check on false drops, it is efﬁcient to present it immediately, rather than only giving the tag
as output and later retrieving the item again. If there were a separate key ﬁle, this argument would not
apply, but separate key ﬁles are not common.
      Input to hunt is taken from the standard input, one query per line. Each query should be in mkey
– s output format; all lower case, no punctuation. The hunt program takes one argument which speciﬁes
the base name of the index ﬁles to be searched. Only one set of index ﬁles can be searched at a time,
although many text ﬁles may be indexed as a group, of course. If one of the text ﬁles has been changed
since the index, that ﬁle is searched with fgrep; this may occasionally slow down the searching, and
care should be taken to avoid having many out of date ﬁles. The following option arguments are recog-
nized by hunt:
           –a           Give all output; ignore checking for false drops.
           – Cn         Coordination level n; retrieve items with not more than n terms of
                        the input missing; default C0 , implying that each search term must
                        be in the output items.
           – F[ynd ]    ‘‘– Fy’’ gives the text of all the items found; ‘‘– Fn’’ suppresses
                        them. ‘‘– Fd ’’ where d is an integer gives the text of the ﬁrst d
                        items. The default is – Fy.
           –g           Do not use fgrep to search ﬁles changed since the index was made;
                        print an error comment instead.
           – i string   Take string as input, instead of reading the standard input.
           –l n         The maximum length of internal lists of candidate items is n; default
                        1000.
           – o string   Put text output (‘‘– Fy’’) in string; of use only when invoked from
                        another program.
           –p           Print hash code frequencies; mostly for use in optimizing hash table
                        sizes.
           – T[ynd ]    ‘‘– Ty’’ gives the tags of the items found; ‘‘– Tn’’ suppresses them.
                        ‘‘– Td ’’ where d is an integer gives the ﬁrst d tags. The default is
                        – Tn .
           – t string   Put tag output (‘‘– Ty’’) in string; of use only when invoked from
                        another program.

       The timing of hunt is complex. Normally the hash table is overfull, so that there will be many
false drops on any single term; but a multi-term query will have few false drops on all terms. Thus if a
query is underspeciﬁed (one search term) many potential items will be examined and discarded as false
drops, wasting time. If the query is overspeciﬁed (a dozen search terms) many keys will be examined
only to verify that the single item under consideration has that key posted. The variation of search time
with number of keys is shown in the table below. Queries of varying length were constructed to retrieve
a particular document from the ﬁle of references. In the sequence to the left, search terms were chosen
so as to select the desired paper as quickly as possible. In the sequence on the right, terms were chosen
inefﬁciently, so that the query did not uniquely select the desired document until four keys had been
                                                            -6-


used. The same document was the target in each case, and the ﬁnal set of eight keys are also identical;
the differences at ﬁve, six and seven keys are produced by measurement error, not by the slightly dif-
ferent key lists.
                        Efﬁcient Keys                                          Inefﬁcient Keys
     No. keys     Total drops     Retrieved   Search time     No. keys    Total drops     Retrieved     Search time
                                                             
                  (incl. false)   Documents    (seconds)                  (incl. false)   Documents      (seconds)
        1             15             3           1.27            1            68             55            5.96
        2              1             1           0.11            2            29             29            2.72
        3              1             1           0.14            3             8              8            0.95
        4              1             1           0.17            4             1              1            0.18
                                                             
        5              1             1           0.19            5             1              1            0.21
        6              1             1           0.23            6             1              1            0.22
        7              1             1           0.27            7             1              1            0.26
        8              1             1           0.29            8             1              1            0.29
As would be expected, the optimal search is achieved when the query just speciﬁes the answer; however,
overspeciﬁcation is quite cheap. Roughly, the time required by hunt can be approximated as 30 mil-
liseconds per search key plus 75 milliseconds per dropped document (whether it is a false drop or a real
answer). In general, overspeciﬁcation can be recommended; it protects the user against additions to the
data base which turn previously uniquely-answered queries into ambiguous queries.
       The careful reader will have noted an enormous discrepancy between these times and the earlier
quoted time of around 1.9 seconds for a search. The times here are purely for the search and retrieval:
they are measured by running many searches through a single invocation of the hunt program alone.
Usually, the UNIX command processor (the shell) must start both the mkey and hunt processes for each
query, and arrange for the output of mkey to be fed to the hunt program. This adds a ﬁxed overhead of
about 1.7 seconds of processor time to any single search. Furthermore, remember that all these times
are processor times: on a typical morning on our PDP 11/70 system, with about one dozen people
logged on, to obtain 1 second of processor time for the search program took between 2 and 12 seconds
of real time, with a median of 3.9 seconds and a mean of 4.8 seconds. Thus, although the work
involved in a single search may be only 200 milliseconds, after you add the 1.7 seconds of startup pro-
cessor time and then assume a 4:1 elapsed/processor time ratio, it will be 8 seconds before any response
is printed.

3. Selecting and Formatting References for TROFF
      The major application of the retrieval software is refer, which is a troff preprocessor like eqn .3 It
scans its input looking for items of the form
            .[
            imprecise citation
            .]
where an imprecise citation is merely a string of words found in the relevant bibliographic citation. This
is translated into a properly formatted reference. If the imprecise citation does not correctly identify a
single paper (either selecting no papers or too many) a message is given. The data base of citations
searched may be tailored to each system, and individual users may specify their own citation ﬁles. On
our system, the default data base is accumulated from the publication lists of the members of our organi-
zation, plus about half a dozen personal bibliographies that were collected. The present total is about
4300 citations, but this increases steadily. Even now, the data base covers a large fraction of local cita-
tions.
      For example, the reference for the eqn paper above was speciﬁed as
__________________
3.    B. W. Kernighan and L. L. Cherry, ‘‘A System for Typesetting Mathematics,’’ Comm. Assoc. Comp. Mach. 18, pp.151-157
      (March 1975).
                                                       -7-


         ...
         preprocessor like
         .I eqn.
         .[
         kernighan cherry acm 1975
         .]
         It scans its input looking for items
         ...
This paper was itself printed using refer. The above input text was processed by refer as well as tbl
and troff by the command
         refer memo-ﬁle  tbl  troff – ms
and the reference was automatically translated into a correct citation to the ACM paper on mathematical
typesetting.
       The procedure to use to place a reference in a paper using refer is as follows. First, use the look-
bib command to check that the paper is in the data base and to ﬁnd out what keys are necessary to
retrieve it. This is done by typing lookbib and then typing some potential queries until a suitable query
is found. For example, had one started to ﬁnd the eqn paper shown above by presenting the query
                 $ lookbib
                 kernighan cherry
                 (EOT)
lookbib would have found several items; experimentation would quickly have shown that the query
given above is adequate. Overspecifying the query is of course harmless; it is even desirable, since it
decreases the risk that a document added to the publication data base in the future will be retrieved in
addition to the intended document. The extra time taken by even a grossly overspeciﬁed query is quite
small. A particularly careful reader may have noticed that ‘‘acm’’ does not appear in the printed cita-
tion; we have supplemented some of the data base items with extra keywords, such as common abbrevi-
ations for journals or other sources, to aid in searching.
      If the reference is in the data base, the query that retrieved it can be inserted in the text, between
.[ and . ] brackets. If it is not in the data base, it can be typed into a private ﬁle of references, using the
format discussed in the next section, and then the – p option used to search this private ﬁle. Such a
command might read (if the private references are called myﬁle )
         refer – p myﬁle document  tbl  eqn  troff – ms . . .
where tbl and/or eqn could be omitted if not needed. The use of the – ms macros4 or some other macro
package, however, is essential. Refer only generates the data for the references; exact formatting is
done by some macro package, and if none is supplied the references will not be printed.
      By default, the references are numbered sequentially, and the – ms macros format references as
footnotes at the bottom of the page. This memorandum is an example of that style. Other possibilities
are discussed in section 5 below.

4. Reference Files.
       A reference ﬁle is a set of bibliographic references usable with refer. It can be indexed using the
software described in section 2 for fast searching. What refer does is to read the input document
stream, looking for imprecise citation references. It then searches through reference ﬁles to ﬁnd the full
citations, and inserts them into the document. The format of the full citation is arranged to make it con-
venient for a macro package, such as the – ms macros, to format the reference for printing. Since the
format of the ﬁnal reference is determined by the desired style of output, which is determined by the
__________________
4.    M. E. Lesk, Typing Documents on UNIX and GCOS: The -ms Macros for Troff, 1977.
                                                   -8-


macros used, refer avoids forcing any kind of reference appearance. All it does is deﬁne a set of string
registers which contain the basic information about the reference; and provide a macro call which is
expanded by the macro package to format the reference. It is the responsibility of the ﬁnal macro pack-
age to see that the reference is actually printed; if no macros are used, and the output of refer fed
untranslated to troff, nothing at all will be printed.
      The strings deﬁned by refer are taken directly from the ﬁles of references, which are in the fol-
lowing format. The references should be separated by blank lines. Each reference is a sequence of lines
beginning with % and followed by a key-letter. The remainder of that line, and successive lines until
the next line beginning with %, contain the information speciﬁed by the key-letter. In general, refer
does not interpret the information, but merely presents it to the macro package for ﬁnal formatting. A
user with a separate macro package, for example, can add new key-letters or use the existing ones for
other purposes without bothering refer.
       The meaning of the key-letters given below, in particular, is that assigned by the – ms macros.
Not all information, obviously, is used with each citation. For example, if a document is both an inter-
nal memorandum and a journal article, the macros ignore the memorandum version and cite only the
journal article. Some kinds of information are not used at all in printing the reference; if a user does not
like ﬁnding references by specifying title or author keywords, and prefers to add speciﬁc keywords to
the citation, a ﬁeld is available which is searched but not printed (K).
      The key letters currently recognized by refer and – ms, with the kind of information implied, are:
        Key             Information speciﬁed                 Key          Information speciﬁed
         A     Author’s name                                  N      Issue number
         B     Title of book containing item                  O      Other information
         C     City of publication                            P      Page(s) of article
         D     Date                                           R      Technical report reference
         E     Editor of book containing item                 T      Title
         G     Government (NTIS) ordering number              V      Volume number
         I     Issuer (publisher)
         J     Journal name
         K     Keys (for searching)                           X      or
         L     Label                                          Y      or
         M     Memorandum label                               Z      Information not used by refer
For example, a sample reference could be typed as:
        %T Bounds on the Complexity of the Maximal
        Common Subsequence Problem
        %Z ctr127
        %A A. V. Aho
        %A D. S. Hirschberg
        %A J. D. Ullman
        %J J. ACM
        %V 23
        %N 1
        %P 1-12
        %M abcd-78
        %D Jan. 1976
Order is irrelevant, except that authors are shown in the order given. The output of refer is a stream of
string deﬁnitions, one for each of the ﬁelds of each reference, as shown below.
                                                   -9-


        .]-
        .ds [A authors’ names ...
        .ds [T title ...
        .ds [J journal ...
        ...
        .] [ type-number
The refer program, in general, does not concern itself with the signiﬁcance of the strings. The different
ﬁelds are treated identically by refer , except that the X, Y and Z ﬁelds are ignored (see the – i option of
mkey ) in indexing and searching. All refer does is select the appropriate citation, based on the keys.
The macro package must arrange the strings so as to produce an appropriately formatted citation. In this
process, it uses the convention that the ‘T’ ﬁeld is the title, the ‘J’ ﬁeld the journal, and so forth.
      The refer program does arrange the citation to simplify the macro package’s job, however. The
special macro .]– precedes the string deﬁnitions and the special macro .] [ follows. These are changed
from the input .[ and . ] so that running the same ﬁle through refer again is harmless. The .]– macro
can be used by the macro package to initialize. The .] [ macro, which should be used to print the refer-
ence, is given an argument type-number to indicate the kind of reference, as follows:
                               Value             Kind of reference
                                1        Journal article
                                2        Book
                                3        Article within book
                                4        Technical report
                                5        Bell Labs technical memorandum
                                0        Other
The type is determined by the presence or absence of particular ﬁelds in the citation (a journal article
must have a ‘J’ ﬁeld, a book must have an ‘I’ ﬁeld, and so forth). To a small extent, this violates the
above rule that refer does not concern itself with the contents of the citation; however, the classiﬁcation
of the citation in troff macros would require a relatively expensive and obscure program. Any macro
writer may, of course, preserve consistency by ignoring the argument to the .] [ macro.
      The reference is ﬂagged in the text with the sequence
        \* ([.number\* (. ]
where number is the footnote number. The strings [. and . ] should be used by the macro package to
format the reference ﬂag in the text. These strings can be replaced for a particular footnote, as described
in section 5. The footnote number (or other signal) is available to the reference macro .] [ as the string
register [F. To simplify dealing with a text reference that occurs at the end of a sentence, refer treats a
reference which follows a period in a special way. The period is removed, and the reference is preceded
by a call for the string <. and followed by a call for the string >. For example, if a reference follows
‘‘end.’’ it will appear as
        end\*(<.\*([.number\*(.]\*(>.
where number is the footnote number. The macro package should turn either the string >. or <. into a
period and delete the other one. This permits the output to have either the form ‘‘end[31].’’ or ‘‘end.31’’
as the macro package wishes. Note that in one case the period precedes the number and in the other it
follows the number.
      In some cases users wish to suspend the searching, and merely use the reference macro formatting.
That is, the user doesn’t want to provide a search key between .[ and . ] brackets, but merely the refer-
ence lines for the appropriate document. Alternatively, the user can wish to add a few ﬁelds to those in
the reference as in the standard ﬁle, or override some ﬁelds. Altering or replacing ﬁelds, or supplying
whole references, is easily done by inserting lines beginning with %; any such line is taken as direct
input to the reference processor rather than keys to be searched. Thus
                                                   - 10 -


        .[
        key1 key2 key3 ...
        %Q New format item
        %R Override report name
        .]
makes the indicates changes to the result of searching for the keys. All of the search keys must be
given before the ﬁrst % line.
       If no search keys are provided, an entire citation can be provided in-line in the text. For example,
if the eqn paper citation were to be inserted in this way, rather than by searching for it in the data base,
the input would read
        ...
        preprocessor like
        .I eqn.
        .[
        %A B. W. Kernighan
        %A L. L. Cherry
        %T A System for Typesetting Mathematics
        %J Comm. ACM
        %V 18
        %N 3
        %P 151-157
        %D March 1975
        .]
        It scans its input looking for items
        ...
This would produce a citation of the same appearance as that resulting from the ﬁle search.
      As shown, ﬁelds are normally turned into troff strings. Sometimes users would rather have them
deﬁned as macros, so that other troff commands can be placed into the data. When this is necessary,
simply double the control character % in the data. Thus the input
        .[
        %V 23
        %%M
        Bell Laboratories,
        Murray Hill, N.J. 07974
        .]
is processed by refer into
        .ds [V 23
        .de [M
        Bell Laboratories,
        Murray Hill, N.J. 07974
        ..
The information after %%M is deﬁned as a macro to be invoked by .[M while the information after
%V is turned into a string to be invoked by \∗([V. At present – ms expects all information as strings.

5. Collecting References and other Refer Options
       Normally, the combination of refer and – ms formats output as troff footnotes which are consecu-
tively numbered and placed at the bottom of the page. However, options exist to place the references at
the end; to arrange references alphabetically by senior author; and to indicate references by strings in the
text of the form [Name1975a] rather than by number. Whenever references are not placed at the bottom
of a page identical references are coalesced.
                                                  - 11 -


      For example, the – e option to refer speciﬁes that references are to be collected; in this case they
are output whenever the sequence
        .[
        $LIST$
        .]
is encountered. Thus, to place references at the end of a paper, the user would run refer with the – e
option and place the above $LIST$ commands after the last line of the text. Refer will then move all
the references to that point. To aid in formatting the collected references, refer writes the references
preceded by the line
        .]<
and followed by the line
        .]>
to invoke special macros before and after the references.
      Another possible option to refer is the – s option to specify sorting of references. The default, of
course, is to list references in the order presented. The – s option implies the – e option, and thus
requires a
        .[
        $LIST$
        .]
entry to call out the reference list. The – s option may be followed by a string of letters, numbers, and
‘+’ signs indicating how the references are to be sorted. The sort is done using the ﬁelds whose key-
letters are in the string as sorting keys; the numbers indicate how many of the ﬁelds are to be con-
sidered, with ‘+’ taken as a large number. Thus the default is – sAD meaning ‘‘Sort on senior author,
then date.’’ To sort on all authors and then title, specify – sA+T. And to sort on two authors and then
the journal, write – sA2J.
      Other options to refer change the signal or label inserted in the text for each reference. Normally
these are just sequential numbers, and their exact placement (within brackets, as superscripts, etc.) is
determined by the macro package. The – l option replaces reference numbers by strings composed of the
senior author’s last name, the date, and a disambiguating letter. If a number follows the l as in – l3 only
that many letters of the last name are used in the label string. To abbreviate the date as well the form
-lm,n shortens the last name to the ﬁrst m letters and the date to the last n digits. For example, the
option – l3,2 would refer to the eqn paper (reference 3) by the signal Ker75a , since it is the ﬁrst cited
reference by Kernighan in 1975.
      A user wishing to specify particular labels for a private bibliography may use the – k option.
Specifying – kx causes the ﬁeld x to be used as a label. The default is L. If this ﬁeld ends in – , that
character is replaced by a sequence letter; otherwise the ﬁeld is used exactly as given.
      If none of the refer -produced signals are desired, the – b option entirely suppresses automatic text
signals.
       If the user wishes to override the – ms treatment of the reference signal (which is normally to
enclose the number in brackets in nroff and make it a superscript in troff ) this can be done easily. If
the lines .[ or .] contain anything following these characters, the remainders of these lines are used to
surround the reference signal, instead of the default. Thus, for example, to say ‘‘See reference (2).’’
and avoid ‘‘See reference.2’’ the input might appear
        See reference
        .[ (
        imprecise citation ...
        . ]).
Note that blanks are signiﬁcant in this construction. If a permanent change is desired in the style of
                                                  - 12 -


reference signals, however, it is probably easier to redeﬁne the strings [. and .] (which are used to
bracket each signal) than to change each citation.
      Although normally refer limits itself to retrieving the data for the reference, and leaves to a macro
package the job of arranging that data as required by the local format, there are two special options for
rearrangements that can not be done by macro packages. The – c option puts ﬁelds into all upper case
(CAPS-SMALL CAPS in troff output). The key-letters indicated what information is to be translated to
upper case follow the c, so that – cAJ means that authors’ names and journals are to be in caps. The – a
option writes the names of authors last name ﬁrst, that is A. D. Hall, Jr. is written as Hall, A. D. Jr .
The citation form of the Journal of the ACM , for example, would require both – cA and – a options.
This produces authors’ names in the style KERNIGHAN, B. W. AND CHERRY, L. L. for the previous exam-
ple. The – a option may be followed by a number to indicate how many author names should be
reversed; – a1 (without any – c option) would produce Kernighan, B. W. and L. L. Cherry, for example.
      Finally, there is also the previously-mentioned – p option to let the user specify a private ﬁle of
references to be searched before the public ﬁles. Note that refer does not insist on a previously made
index for these ﬁles. If a ﬁle is named which contains reference data but is not indexed, it will be
searched (more slowly) by refer using fgrep. In this way it is easy for users to keep small ﬁles of new
references, which can later be added to the public data bases.
                                       NROFF⁄TROFF User’s Manual

                                                 Joseph F. Ossanna

                                                Bell Laboratories
                                          Murray Hill, New Jersey 07974


Introduction
NROFF and TROFF are text processors under the PDP-11 UNIX Time-Sharing System1 that format text for
typewriter-like terminals and for a Graphic Systems phototypesetter, respectively. They accept lines of text inter-
spersed with lines of format control information and format the text into a printable, paginated document having
a user-designed style. NROFF and TROFF offer unusual freedom in document styling, including: arbitrary style
headers and footers; arbitrary style footnotes; multiple automatic sequence numbering for paragraphs, sections,
etc; multiple column output; dynamic font and point-size control; arbitrary horizontal and vertical local motions
at any point; and a family of automatic overstriking, bracket construction, and line drawing functions.
NROFF and TROFF are highly compatible with each other and it is almost always possible to prepare input
acceptable to both. Conditional input is provided that enables the user to embed input expressly destined for
either program. NROFF can prepare output directly for a variety of terminal types and is capable of utilizing the
full resolution of each terminal.
Usage
The general form of invoking NROFF (or TROFF) at UNIX command level is
          nroff options ﬁles                 (or troff options ﬁles)
where options represents any of a number of option arguments and ﬁles represents the list of ﬁles containing the
document to be formatted. An argument consisting of a single minus (– ) is taken to be a ﬁle name correspond-
ing to the standard input. If no ﬁle names are given input is taken from the standard input. The options, which
may appear in any order so long as they appear before the ﬁles, are:

   O pt io n
   Op ti on       E ff ec t
                  Ef fe ct
     – olist      Print only pages whose page numbers appear in list, which consists of comma-separated
                  numbers and number ranges. A number range has the form N– M and means pages N
                  through M; a initial – N means from the beginning to page N; and a ﬁnal N– means from
                  N to the end.
     – nN         Number ﬁrst generated page N.
     – sN         Stop every N pages. NROFF will halt prior to every N pages (default N=1) to allow paper
                  loading or changing, and will resume upon receipt of a newline. TROFF will stop the pho-
                  totypesetter every N pages, produce a trailer to allow changing cassettes, and will resume
                  after the phototypesetter START button is pressed.
     – mname      Prepends the macro ﬁle ⁄usr⁄lib⁄tmac.name to the input ﬁles.
     – raN        Register a (one-character) is set to N.
     –i           Read standard input after the input ﬁles are exhausted.
     –q           Invoke the simultaneous input-output mode of the rd request.




                                                        -1-
NROFF/TROFF User’s Manual
October 11, 1976


                                      N RO FF O nl y
                                      NR OF F On ly
      – Tname      Speciﬁes the name of the output terminal type. Currently deﬁned names are 37 for the
                   (default) Model 37 Teletype®, tn300 for the GE TermiNet 300 (or any terminal without
                   half-line capabilities), 300S for the DASI-300S, 300 for the DASI-300, and 450 for the
                   DASI-450 (Diablo Hyterm).
      –e           Produce equally-spaced words in adjusted lines, using full terminal resolution.

                                      T RO FF O nl y
                                      TR OF F On ly
      –t           Direct output to the standard output instead of the phototypesetter.
      –f           Refrain from feeding out paper and stopping phototypesetter at the end of the run.
      –w           Wait until phototypesetter is available, if currently busy.
      –b           TROFF will report whether the phototypesetter is busy or available. No text processing is
                   done.
      –a           Send a printable (ASCII) approximation of the results to the standard output.
      – pN         Print all characters in point size N while retaining all prescribed spacings and motions, to
                   reduce phototypesetter elasped time.
      –g           Prepare output for the Murray Hill Computation Center phototypesetter and direct it to the
                   standard output.

Each option is invoked as a separate argument; for example,
           nroff – o4,8– 10 – T300S – mabc ﬁle1 ﬁle2
requests formatting of pages 4, 8, 9, and 10 of a document contained in the ﬁles named ﬁle1 and ﬁle2, speciﬁes
the output terminal as a DASI-300S, and invokes the macro package abc.
Various pre- and post-processors are available for use with NROFF and TROFF. These include the equation
preprocessors NEQN and EQN2 (for NROFF and TROFF respectively), and the table-construction preprocessor
TBL3. A reverse-line postprocessor COL4 is available for multiple-column NROFF output on terminals without
reverse-line ability; COL expects the Model 37 Teletype escape sequences that NROFF produces by default. TK4
is a 37 Teletype simulator postprocessor for printing NROFF output on a Tektronix 4014. TCAT4 is
phototypesetter-simulator postprocessor for TROFF that produces an approximation of phototypesetter output on a
Tektronix 4014. For example, in
           tbl ﬁles  eqn  troff – t options  tcat
the ﬁrst  indicates the piping of TBL’s output to EQN’s input; the second the piping of EQN’s output to
TROFF’s input; and the third indicates the piping of TROFF’s output to TCAT. GCAT4 can be used to send
TROFF (– g) output to the Murray Hill Computation Center.
The remainder of this manual consists of: a Summary and Index; a Reference Manual keyed to the index; and a
set of Tutorial Examples. Another tutorial is [5].



                                                                          Joseph F. Ossanna

References
[1]   K. Thompson, D. M. Ritchie, UNIX Programmer’s Manual, Sixth Edition (May 1975).
[2]   B. W. Kernighan, L. L. Cherry, Typesetting Mathematics — User’s Guide (Second Edition), Bell Laboratories internal
      memorandum.
[3]   M. E. Lesk, Tbl — A Program to Format Tables, Bell Laboratories internal memorandum.
[4]   Internal on-line documentation, on UNIX.
[5]   B. W. Kernighan, A TROFF Tutorial, Bell Laboratories internal memorandum.



                                                          -2-
NROFF/TROFF User’s Manual
October 11, 1976


                                                          SUMMARY AND INDEX

R eq ue st
Re qu es t        I ni ti al
                  In it ia l        If No
                                    If No
F or m
Fo rm             V al ue *
                  Va lu e*          A rg um en t
                                    Ar gu me nt       N ot es# E xp la na ti on
                                                      No te s Ex pl an at io n
1. General Explanation
2. Font and Character Size Control
.ps ±N            10 point          previous          E          Point size; also \s±N.†
.ss N             12⁄36 em          ignored           E          Space-character size set to N⁄36 em.†
.cs F N M         off               -                 P          Constant character space (width) mode (font F ).†
.bd F N           off               -                 P          Embolden font F by N−1 units.†
.bd S F N         off               -                 P          Embolden Special Font when current font is F.†
.ft F             Roman             previous          E          Change to font F = x, xx, or 1-4. Also \fx, \f(xx, \fN.
.fp N F           R,I,B,S           ignored           -          Font named F mounted on physical position 1≤N≤4.
3. Page Control
.pl ±N            11 in             11 in             v          Page length.
.bp ±N            N=1               -                 B‡,v       Eject current page; next page number N.
.pn ±N            N=1               ignored           -          Next page number N.
.po ±N            0; 26⁄27 in       previous          v          Page offset.
.ne N             -                 N=1V              D,v        Need N vertical space (V = vertical spacing).
.mk R             none              internal          D          Mark current vertical place in register R.
.rt ±N            none              internal          D,v        Return (upward only) to marked vertical place.
4. Text Filling, Adjusting, and Centering
.br               -                 -                 B          Break.
.fi               ﬁll               -                 B,E        Fill output lines.
.nf               ﬁll               -                 B,E        No ﬁlling or adjusting of output lines.
.ad c             adj,both          adjust            E          Adjust output lines with mode c.
.na               adjust            -                 E          No output line adjusting.
.ce N             off               N=1               B,E        Center following N input text lines.
5. Vertical Spacing
.vs N             1⁄6in;12pts       previous          E,p        Vertical base line spacing (V).
.ls N             N=1               previous          E          Output N−1 Vs after each text output line.
.sp N             -                 N=1V              B,v        Space vertical distance N in either direction.
.sv N             -                 N=1V              v          Save vertical distance N.
.os               -                 -                 -          Output saved vertical distance.
.ns               space             -                 D          Turn no-space mode on.
.rs               -                 -                 D          Restore spacing; turn no-space mode off.
6. Line Length and Indenting
.ll ±N            6.5 in            previous          E,m   Line length.
.in ±N            N=0               previous          B,E,m Indent.
.ti ±N            -                 ignored           B,E,m Temporary indent.
7. Macros, Strings, Diversion, and Position Traps
.de xx yy     -                     .yy=..            -          Deﬁne or redeﬁne macro xx; end at call of yy.
.am xx yy     -                     .yy=..            -          Append to a macro.
.ds xx string -                     ignored           -          Deﬁne a string xx containing string.
__________________
*Values separated by ";" are for NROFF and TROFF respectively.
#Notes are explained at the end of this Summary and Index
†No effect in NROFF.
‡The use of " ´ " as control character (instead of ".") suppresses the break function.




                                                                     -3-
NROFF/TROFF User’s Manual
October 11, 1976


R eq ue st
Re qu es t       I ni ti al
                 In it ia l   If No
                              If No
Fo rm
F or m           V al ue
                 Va lu e      Ar gu me nt
                              A rg um en t   N ot es
                                             No te s   E xp la na ti on
                                                       Ex pl an at io n

.as xx string    -            ignored        -         Append string to string xx.
.rm xx           -            ignored        -         Remove request, macro, or string.
.rn xx yy        -            ignored        -         Rename request, macro, or string xx to yy.
.di xx           -            end            D         Divert output to macro xx.
.da xx           -            end            D         Divert and append to xx.
.wh N xx         -            -              v         Set location trap; negative is w.r.t. page bottom.
.ch xx N         -            -              v         Change trap location.
.dt N xx         -            off            D,v       Set a diversion trap.
.it N xx         -            off            E         Set an input-line count trap.
.em xx           none         none           -         End macro is xx.
8. Number Registers
.nr R ±N M -                  u              Deﬁne and set number register R; auto-increment by M.
.af R c    arabic             -              -      Assign format to register R (c=1, i, I, a, A).
.rr R      -                  -              -      Remove register R.
9. Tabs, Leaders, and Fields
.ta Nt ...       0.8; 0.5in   none           E,m       Tab settings; left type, unless t=R(right), C(centered).
.tc c            none         none           E         Tab repetition character.
.lc c            .            none           E         Leader repetition character.
.fc a b          off          off            -         Set ﬁeld delimiter a and pad character b.
10. Input and Output Conventions and Character Translations
.ec c            \            \              -         Set escape character.
.eo              on           -              -         Turn off escape character mechanism.
.lg N            -; on        on             -         Ligature mode on if N>0.
.ul N            off          N=1            E         Underline (italicize in TROFF) N input lines.
.cu N            off          N=1            E         Continuous underline in NROFF; like ul in TROFF.
.uf F            Italic       Italic         -         Underline font set to F (to be switched to by ul).
.cc c            .            .              E         Set control character to c.
.c2 c            ´            ´              E         Set nobreak control character to c.
.tr abcd....     none         -              O         Translate a to b, etc. on output.
11. Local Horizontal and Vertical Motions, and the Width Function
12. Overstrike, Bracket, Line-drawing, and Zero-width Functions
13. Hyphenation.
.nh           hyphenate       -              E       No hyphenation.
.hy N         hyphenate       hyphenate      E       Hyphenate; N = mode.
.hc c         \%              \%             E       Hyphenation indicator character c.
.hw word1 ... ignored         -              Exception words.
14. Three Part Titles.
.tl ´left ´center ´right ´    -              -         Three part title.
.pc c            %            off            -         Page number character.
.lt ±N           6.5 in       previous       E,m       Length of title.
15. Output Line Numbering.
.nm ±N M S I                  off            E         Number mode on or off, set parameters.
.nn N       -                 N=1            E         Do not number next N lines.




                                                            -4-
NROFF/TROFF User’s Manual
October 11, 1976


R eq ue st
Re qu es t       I ni ti al
                 In it ia l             If No
                                        If No
Fo rm
F or m           V al ue
                 Va lu e                Ar gu me nt
                                        A rg um en t   N ot es
                                                       No te s    E xp la na ti on
                                                                  Ex pl an at io n

16. Conditional Acceptance of Input
.if c anything                          -              -          If condition c true, accept anything as input,
                                                                  for multi-line use \{anything \}.
.if !c anything                 -                      -          If condition c false, accept anything.
.if N anything-                 u                      If   expression N > 0, accept anything.
.if !N anything                 -                      u          If expression N ≤ 0, accept anything.
.if ´string1 ´string2 ´ anything                       -          If string1 identical to string2, accept anything.
.if ! ´string1 ´string2 ´ anything                     -          If string1 not identical to string2, accept anything.
.ie c anything -                u                      If   portion of if-else; all above forms (like if).
.el anything                    -                      -          Else portion of if-else.
17. Environment Switching.
.ev N            N=0                    previous       -          Environment switched (push down).
18. Insertions from the Standard Input
.rd prompt       -                      prompt=BEL -              Read insertion.
.ex              -                      -          -              Exit from NROFF⁄TROFF.
19. Input⁄Output File Switching
.so ﬁlename                             -              -          Switch source ﬁle (push down).
.nx ﬁlename                             end-of-ﬁle     -          Next ﬁle.
.pi program                             -              -          Pipe output to program (NROFF only).
20. Miscellaneous
.mc c N          -                      off            E,m        Set margin character c and separation N.
.tm string       -                      newline        -          Print string on terminal (UNIX standard message output).
.ig yy           -                      .yy=..         -          Ignore till call of yy.
.pm t            -                      all            -          Print macro names and sizes;
                                                                  if t present, print only total of sizes.
.fl              -                      -              B          Flush output buffer.
21. Output and Error Messages
______________________________________________________________________________________________
  Notes-
    B        Request normally causes a break.
    D        Mode or relevant parameters associated with current diversion level.
    E        Relevant parameters are a part of the current environment.
    O        Must stay in effect until logical output.
    P        Mode must be still or again in effect at the time of physical output.
 v,p,m,u     Default scale indicator; if not speciﬁed, scale indicators are ignored.

Alphabetical Request and Section Number Cross Reference
ad     4     cc 10            ds    7       fc    9    ie   16     ll    6      nh   13   pi   19   rn 7      ta    9     vs 5
af     8     ce 4             dt    7       ﬁ     4    if   16     ls    5      nm   15   pl    3   rr  8     tc    9     wh 7
am     7     ch 7             ec   10       ﬂ    20    ig   20     lt   14      nn   15   pm   20   rs 5      ti    6
as     7     cs 2             el   16       fp    2    in    6     mc   20      nr    8   pn    3   rt  3     tl   14
bd     2     cu 10            em    7       ft    2    it    7     mk    3      ns    5   po    3   so 19     tm   20
bp     3     da 7             eo   10       hc   13    lc    9     na    4      nx   19   ps    2   sp 5      tr   10
br     4     de 7             ev   17       hw   13    lg   10     ne    3      os    5   rd   18   ss 2      uf   10
c2    10     di 7             ex   18       hy   13    li   10     nf    4      pc   14   rm    7   sv 5      ul   10




                                                                        -5-
NROFF/TROFF User’s Manual
October 11, 1976


Escape Sequences for Characters, Indicators, and Functions

 S ec ti on E sc ap e
 Se ct io n   Es ca pe
R ef er en ce S eq ue nc e
Re fe re nc e Se qu en ce    M ea ni ng
                             Me an in g
   10.1       \\            \ (to prevent or delay the interpretation of \ )
   10.1       \e            Printable version of the current escape character.
    2.1       \´            ´ (acute accent); equivalent to \(aa
    2.1       \`            ` (grave accent); equivalent to \(ga
    2.1       \–            – Minus sign in the current font
    7         \.            Period (dot) (see de)
   11.1       \(space)      Unpaddable space-size space character
   11.1       \0            Digit width space
   11.1       \            1⁄6 em narrow space character (zero width in NROFF)
   11.1       \ˆ            1⁄12 em half-narrow space character (zero width in NROFF)
    4.1       \&            Non-printing, zero width character
   10.6       \!            Transparent line indicator
   10.7       \"            Beginning of comment
    7.3       \$N           Interpolate argument 1≤N≤9
   13         \%            Default optional hyphenation character
    2.1       \(xx          Character named xx
    7.1       \∗x, \∗(xx    Interpolate string x or xx
    9.1       \a            Non-interpreted leader character
   12.3       \b´abc... ´   Bracket building function
    4.2       \c            Interrupt text processing
   11.1       \d            Forward (down) 1⁄2 em vertical motion (1⁄2 line in NROFF)
    2.2       \fx,\f(xx,\fN Change to font named x or xx, or position N
   11.1       \h´N ´        Local horizontal motion; move right N (negative left)
   11.3       \kx           Mark horizontal input place in register x
   12.4       \l ´Nc ´      Horizontal line drawing function (optionally with c )
   12.4       \L´Nc ´       Vertical line drawing function (optionally with c )
    8         \nx,\n(xx     Interpolate number register x or xx
   12.1       \o´abc... ´   Overstrike characters a, b, c, ...
    4.1       \p            Break and spread output line
   11.1       \r            Reverse 1 em vertical motion (reverse line in NROFF)
    2.3       \sN, \s±N     Point-size change function
    9.1       \t            Non-interpreted horizontal tab
   11.1       \u            Reverse (up) 1⁄2 em vertical motion (1⁄2 line in NROFF)
   11.1       \v´N ´        Local vertical motion; move down N (negative up)
   11.2       \w´string ´ Interpolate width of string
    5.2       \x´N ´        Extra line-space function (negative before, positive after)
   12.2       \zc           Print c with zero width (without spacing)
   16         \{            Begin conditional input
   16         \}            End conditional input
   10.7       \(newline)    Concealed (ignored) newline
    -         \X            X, any character not listed above


The escape sequences \\, \., \", \$, \∗, \a, \n, \t, and \(newline) are interpreted in copy mode (§7.2).




                                                         -6-
NROFF/TROFF User’s Manual
October 11, 1976


Predeﬁned General Number Registers

 S ec ti on R eg is te r
 Se ct io n Re gi st er
R ef er en ce N am e
Re fe re nc e Na me      D es cr ip ti on
                         De sc ri pt io n
    3         %           Current page number.
   11.2       ct          Character type (set by width function).
    7.4       dl          Width (maximum) of last completed diversion.
    7.4       dn          Height (vertical size) of last completed diversion.
    -         dw          Current day of the week (1-7).
    -         dy          Current day of the month (1-31).
   11.3       hp          Current horizontal place on input line.
   15         ln          Output line number.
    -         mo          Current month (1-12).
    4.1       nl          Vertical position of last printed text base-line.
   11.2       sb          Depth of string below base line (generated by width function).
   11.2       st          Height of string above base line (generated by width function).
    -         yr          Last two digits of current year.


Predeﬁned Read-Only Number Registers

 S ec ti on R eg is te r
 Se ct io n Re gi st er
R ef er en ce N am e
Re fe re nc e Na me      D es cr ip ti on
                         De sc ri pt io n
    7.3       .$          Number of arguments available at the current macro level.
    -         .A          Set to 1 in TROFF, if – a option used; always 1 in NROFF.
   11.1       .H          Available horizontal resolution in basic units.
    -         .T          Set to 1 in NROFF, if – T option used; always 0 in TROFF.
   11.1       .V          Available vertical resolution in basic units.
    5.2       .a          Post-line extra line-space most recently utilized using \x´N ´.
    -         .c          Number of lines read from current input ﬁle.
    7.4       .d          Current vertical place in current diversion; equal to nl, if no diversion.
    2.2       .f          Current font as physical quadrant (1-4).
    4         .h          Text base-line high-water mark on current page or diversion.
    6         .i          Current indent.
    6         .l          Current line length.
    4         .n          Length of text portion on previous output line.
    3         .o          Current page offset.
    3         .p          Current page length.
    2.3       .s          Current point size.
    7.5       .t          Distance to the next trap.
    4.1       .u          Equal to 1 in ﬁll mode and 0 in noﬁll mode.
    5.1       .v          Current vertical line spacing.
   11.2       .w          Width of previous character.
    -         .x          Reserved version-dependent register.
    -         .y          Reserved version-dependent register.
    7.4       .z          Name of current diversion.




                                                           -7-
NROFF/TROFF User’s Manual
October 11, 1976




                                          REFERENCE MANUAL

1. General Explanation
1.1. Form of input. Input consists of text lines, which are destined to be printed, interspersed with control lines,
which set parameters or otherwise control subsequent processing. Control lines begin with a control
character—normally . (period) or ´ (acute accent)—followed by a one or two character name that speciﬁes a
basic request or the substitution of a user-deﬁned macro in place of the control line. The control character ´
suppresses the break function—the forced output of a partially ﬁlled line—caused by certain requests. The con-
trol character may be separated from the request/macro name by white space (spaces and/or tabs) for esthetic rea-
sons. Names must be followed by either space or newline. Control lines with unrecognized names are ignored.
Various special functions may be introduced anywhere in the input by means of an escape character, normally \.
For example, the function \nR causes the interpolation of the contents of the number register R in place of the
function; here R is either a single character name as in \nx, or left-parenthesis-introduced, two-character name as
in \n(xx.
1.2. Formatter and device resolution. TROFF internally uses 432 units⁄inch, corresponding to the Graphic Sys-
tems phototypesetter which has a horizontal resolution of 1⁄432 inch and a vertical resolution of 1⁄144 inch.
NROFF internally uses 240 units⁄inch, corresponding to the least common multiple of the horizontal and vertical
resolutions of various typewriter-like output devices. TROFF rounds horizontal⁄vertical numerical parameter input
to the actual horizontal⁄vertical resolution of the Graphic Systems typesetter. NROFF similarly rounds numerical
input to the actual resolution of the output device indicated by the −T option (default Model 37 Teletype).
1.3. Numerical parameter input. Both NROFF and TROFF accept numerical input with the appended scale indica-
tors shown in the following table, where S is the current type size in points, V is the current vertical line spacing
in basic units, and C is a nominal character width in basic units.
                        ________________________________________________________
                         Scale                           Number of basic units           
                        _Indicator 
                        _______________________________________________________
                                           Meaning         TROFF          NROFF
                                                                                         
                            i       Inch                 432           240              
                            c       Centimeter           432×50⁄127  240×50⁄127         
                                    Pica = 1⁄6 inch      72            240⁄6            
                             P
                         m          Em = S points        6×S                            
                                                                       C
                                                                                            
                            n       En = Em⁄2            3×S           C, same as Em 
                            p       Point = 1⁄72 inch  6               240⁄72           
                            u       Basic unit           1            1                 
                                    Vertical line space  V                              
                             v                                            V
                         none
                         _______________________________________________________
                                     Default, see below 
                        _
                                                                                        

In NROFF, both the em and the en are taken to be equal to the C, which is output-device dependent; common
values are 1⁄10 and 1⁄12 inch. Actual character widths in NROFF need not be all the same and constructed char-
acters such as −> (→) are often extra wide. The default scaling is ems for the horizontally-oriented requests and
functions ll, in, ti, ta, lt, po, mc, \h, and \l; Vs for the vertically-oriented requests and functions pl, wh, ch, dt,
sp, sv, ne, rt, \v, \x, and \L; p for the vs request; and u for the requests nr, if, and ie. All other requests ignore
any scale indicators. When a number register containing an already appropriately scaled number is interpolated
to provide numerical input, the unit scale indicator u may need to be appended to prevent an additional inap-
propriate default scaling. The number, N, may be speciﬁed in decimal-fraction form but the parameter ﬁnally
stored is rounded to an integer number of basic units.



                                                        -8-
NROFF/TROFF User’s Manual
October 11, 1976


The absolute position indicator  may be prepended to a number N to generate the distance to the vertical or hor-
izontal place N. For vertically-oriented requests and functions,  N becomes the distance in basic units from the
current vertical place on the page or in a diversion (§7.4) to the the vertical place N. For all other requests and
functions,  N becomes the distance from the current horizontal place on the input line to the horizontal place N.
For example,
         .sp  3.2c
will space in the required direction to 3.2 centimeters from the top of the page.
1.4. Numerical expressions. Wherever numerical input is expected an expression involving parentheses, the arith-
metic operators +, −, ⁄, ∗, % (mod), and the logical operators <, >, <=, >=, = (or ==), & (and), : (or) may be
used. Except where controlled by parentheses, evaluation of expressions is left-to-right; there is no operator pre-
cedence. In the case of certain requests, an initial + or − is stripped and interpreted as an increment or decrement
indicator respectively. In the presence of default scaling, the desired scale indicator must be attached to every
number in an expression for which the desired and default scaling differ. For example, if the number register x
contains 2 and the current point size is 10, then
         .ll (4.25i+\nxP+3)⁄2u
will set the line length to 1⁄2 the sum of 4.25 inches + 2 picas + 30 points.
1.5. Notation. Numerical parameters are indicated in this manual in two ways. ±N means that the argument may
take the forms N, +N, or −N and that the corresponding effect is to set the affected parameter to N, to increment
it by N, or to decrement it by N respectively. Plain N means that an initial algebraic sign is not an increment
indicator, but merely the sign of N. Generally, unreasonable numerical input is either ignored or truncated to a
reasonable value. For example, most requests expect to set parameters to non-negative values; exceptions are sp,
wh, ch, nr, and if. The requests ps, ft, po, vs, ls, ll, in, and lt restore the previous parameter value in the
absence of an argument.
Single character arguments are indicated by single lower case letters and one/two character arguments are indi-
cated by a pair of lower case letters. Character string arguments are indicated by multi-character mnemonics.
2. Font and Character Size Control
2.1. Character set. The TROFF character set consists of the Graphics Systems Commercial II character set plus a
Special Mathematical Font character set—each having 102 characters. These character sets are shown in the
attached Table I. All ASCII characters are included, with some on the Special Font. With three exceptions, the
ASCII characters are input as themselves, and non-ASCII characters are input in the form \(xx where xx is a two-
character name given in the attached Table II. The three ASCII exceptions are mapped as follows:
                             ______________________________________________
                                    ASCII Input            Printed by TROFF       
                              _____________________________________________
                                                          Character
                             _Character        Name                       Name
                                                                                  
                                  ´       acute accent       ’       close quote 
                                  `       grave accent       ‘       open quote 
                             _
                                 −        minus         
                              _____________________________________________
                                                              -       hyphen       

The characters ´, `, and – may be input by \´, \`, and \– respectively or by their names (Table II). The ASCII
characters @, #, ", ´, `, <, >, \, {, }, ˜, ˆ, and _ exist only on the Special Font and are printed as a 1-em space if
that Font is not mounted.
NROFF understands the entire TROFF character set, but can in general print only ASCII characters, additional
characters as may be available on the output device, such characters as may be able to be constructed by over-
striking or other combination, and those that can reasonably be mapped into other printable characters. The exact
behavior is determined by a driving table prepared for each device. The characters ´, `, and _ print as them-
selves.
2.2. Fonts. The default mounted fonts are Times Roman (R), Times Italic (I), Times Bold (B), and the Special
Mathematical Font (S) on physical typesetter positions 1, 2, 3, and 4 respectively. These fonts are used in this
document. The current font, initially Roman, may be changed (among the mounted fonts) by use of the ft
request, or by imbedding at any desired point either \fx, \f(xx, or \fN where x and xx are the name of a mounted


                                                        -9-
NROFF/TROFF User’s Manual
October 11, 1976


font and N is a numerical font position. It is not necessary to change to the Special font; characters on that font
are automatically handled. A request for a named but not-mounted font is ignored. TROFF can be informed that
any particular font is mounted by use of the fp request. The list of known fonts is installation dependent. In the
subsequent discussion of font-related requests, F represents either a one⁄two-character font name or the numerical
font position, 1-4. The current font is available (as numerical position) in the read-only number register .f.
NROFF understands font control and normally underlines Italic characters (see §10.5).
2.3. Character size. Character point sizes available on the Graphic Systems typesetter are 6, 7, 8, 9, 10, 11, 12,
14, 16, 18, 20, 22, 24, 28, and 36. This is a range of 1⁄12 inch to 1⁄2 inch. The ps request is used to change or
restore the point size. Alternatively the point size may be changed between any two characters by imbedding a
\sN at the desired point to set the size to N, or a \s±N (1≤N≤9) to increment⁄decrement the size by N; \s0 restores
the previous size. Requested point size values that are between two valid sizes yield the larger of the two. The
current size is available in the .s register. NROFF ignores type size control.
R eq ue st
Re qu es t      I ni ti al
                In it ia l       If No
                                 If No
F or m
Fo rm           V al ue
                Va lu e          A rg um en t
                                 Ar gu me nt      N ot es * E xp la na ti on
                                                  No te s* Ex pl an at io n
.ps ±N          10 point         previous         E         Point size set to ±N. Alternatively imbed \sN or \s±N. Any
                                                            positive size value may be requested; if invalid, the next larger
                                                            valid size will result, with a maximum of 36. A paired
                                                            sequence +N, −N will work because the previous requested
                                                            value is also remembered. Ignored in NROFF.
.ss N           12⁄36 em         ignored          E         Space-character size is set to N⁄36 ems. This size is the
                                                            minimum word spacing in adjusted text. Ignored in NROFF.
.cs F N M       off              -                P         Constant character space (width) mode is set on for font F (if
                                                            mounted); the width of every character will be taken to be
                                                            N⁄36 ems. If M is absent, the em is that of the character’s
                                                            point size; if M is given, the em is M-points. All affected
                                                            characters are centered in this space, including those with an
                                                            actual width larger than this space. Special Font characters
                                                            occurring while the current font is F are also so treated. If N
                                                            is absent, the mode is turned off. The mode must be still or
                                                            again in effect when the characters are physically printed.
                                                            Ignored in NROFF.
.bd F N         off              -                P         The characters in font F will be artiﬁcially emboldened by
                                                            printing each one twice, separated by N−1 basic units. A rea-
                                                            sonable value for N is 3 when the character size is in the
                                                            vicinity of 10 points. If N is missing the embolden mode is
                                                            turned off. The column heads above were printed with
                                                            .bd I 3. The mode must be still or again in effect when the
                                                            characters are physically printed. Ignored in NROFF.
.bd S F N       off              -                P         The characters in the Special Font will be emboldened when-
                                                            ever the current font is F. This manual was printed with
                                                            .bd S B 3. The mode must be still or again in effect when the
                                                            characters are physically printed.
.ft F           Roman            previous         E         Font changed to F. Alternatively, imbed \fF. The font name
                                                            P is reserved to mean the previous font.
.fp N F         R,I,B,S          ignored          -         Font position. This is a statement that a font named F is
                                                            mounted on position N (1-4). It is a fatal error if F is not
                                                            known. The phototypesetter has four fonts physically
                                                            mounted. Each font consists of a ﬁlm strip which can be
__________________
*Notes are explained at the end of the Summary and Index above.




                                                                  - 10 -
NROFF/TROFF User’s Manual
October 11, 1976


                                                                 mounted on a numbered quadrant of a wheel. The default
                                                                 mounting sequence assumed by TROFF is R, I, B, and S on
                                                                 positions 1, 2, 3 and 4.
3. Page control
Top and bottom margins are not automatically provided; it is conventional to deﬁne two macros and to set traps
for them at vertical positions 0 (top) and −N (N from the bottom). See §7 and Tutorial Examples §T2. A
pseudo-page transition onto the ﬁrst page occurs either when the ﬁrst break occurs or when the ﬁrst non-diverted
text processing occurs. Arrangements for a trap to occur at the top of the ﬁrst page must be completed before
this transition. In the following, references to the current diversion (§7.4) mean that the mechanism being
described works during both ordinary and diverted output (the former considered as the top diversion level).
The useable page width on the Graphic Systems phototypesetter is about 7.54 inches, beginning about 1⁄27 inch
from the left edge of the 8 inch wide, continuous roll paper. The physical limitations on NROFF output are
output-device dependent.
R eq ue st
Re qu es t       I ni ti al
                 In it ia l         If No
                                    If No
Fo rm
F or m           V al ue
                 Va lu e            Ar gu me nt
                                    A rg um en t      N ot es
                                                      No te s    E xp la na ti on
                                                                 Ex pl an at io n
.pl ±N            11 in             11 in             v          Page length set to ±N. The internal limitation is about
                                                                 75 inches in TROFF and about 136 inches in NROFF. The
                                                                 current page length is available in the .p register.
.bp ±N            N=1               -                 B*,v       Begin page. The current page is ejected and a new page is
                                                                 begun. If ±N is given, the new page number will be ±N.
                                                                 Also see request ns.
.pn ±N            N=1               ignored           -          Page number. The next page (when it occurs) will have the
                                                                 page number ±N. A pn must occur before the initial pseudo-
                                                                 page transition to effect the page number of the ﬁrst page.
                                                                 The current page number is in the % register.
.po ±N            0; 26⁄27 in†      previous          v          Page offset. The current left margin is set to ±N. The TROFF
                                                                 initial value provides about 1 inch of paper margin including
                                                                 the physical typesetter margin of 1⁄27 inch. In TROFF the
                                                                 maximum (line-length)+(page-offset) is about 7.54 inches.
                                                                 See §6. The current page offset is available in the .o register.
.ne N             -                 N=1 V             D,v        Need N vertical space. If the distance, D, to the next trap
                                                                 position (see §7.5) is less than N, a forward vertical space of
                                                                 size D occurs, which will spring the trap. If there are no
                                                                 remaining traps on the page, D is the distance to the bottom of
                                                                 the page. If D < V, another line could still be output and
                                                                 spring the trap. In a diversion, D is the distance to the diver-
                                                                 sion trap, if any, or is very large.
.mk R             none              internal          D          Mark the current vertical place in an internal register (both
                                                                 associated with the current diversion level), or in register R, if
                                                                 given. See rt request.
.rt ±N            none              internal          D,v        Return upward only to a marked vertical place in the current
                                                                 diversion. If ±N (w.r.t. current place) is given, the place is ±N
                                                                 from the top of the page or diversion or, if N is absent, to a
                                                                 place marked by a previous mk. Note that the sp request
                                                                 (§5.3) may be used in all cases instead of rt by spacing to the
                                                                 absolute place stored in a explicit register; e. g. using the
                                                                 sequence .mk R ... .sp  \nRu.
__________________
*The use of " ´ " as control character (instead of ".") suppresses the break function.
†Values separated by ";" are for NROFF and TROFF respectively.



                                                                     - 11 -
NROFF/TROFF User’s Manual
October 11, 1976


4. Text Filling, Adjusting, and Centering
4.1. Filling and adjusting. Normally, words are collected from input text lines and assembled into a output text
line until some word doesn’t ﬁt. An attempt is then made the hyphenate the word in effort to assemble a part of
it into the output line. The spaces between the words on the output line are then increased to spread out the line
to the current line length minus any current indent. A word is any string of characters delimited by the space
character or the beginning/end of the input line. Any adjacent pair of words that must be kept together (neither
split across output lines nor spread apart in the adjustment process) can be tied together by separating them with
the unpaddable space character "\ " (backslash-space). The adjusted word spacings are uniform in TROFF and
the minimum interword spacing can be controlled with the ss request (§2). In NROFF, they are normally nonuni-
form because of quantization to character-size spaces; however, the command line option – e causes uniform
spacing with full output device resolution. Filling, adjustment, and hyphenation (§13) can all be prevented or
controlled. The text length on the last line output is available in the .n register, and text base-line position on the
page for this line is in the nl register. The text base-line high-water mark (lowest place) on the current page is in
the .h register.
An input text line ending with ., ?, or ! is taken to be the end of a sentence, and an additional space character is
automatically provided during ﬁlling. Multiple inter-word space characters found in the input are retained, except
for trailing spaces; initial spaces also cause a break.
When ﬁlling is in effect, a \p may be imbedded or attached to a word to cause a break at the end of the word
and have the resulting output line spread out to ﬁll the current line length.
A text input line that happens to begin with a control character can be made to not look like a control line by
prefacing it with the non-printing, zero-width ﬁller character \&. Still another way is to specify output transla-
tion of some convenient character into the control character using tr (§10.5).
4.2. Interrupted text. The copying of a input line in noﬁll (non-ﬁll) mode can be interrupted by terminating the
partial line with a \c. The next encountered input text line will be considered to be a continuation of the same
line of input text. Similarly, a word within ﬁlled text may be interrupted by terminating the word (and line) with
\c; the next encountered text will be taken as a continuation of the interrupted word. If the intervening control
lines cause a break, any partial line will be forced out along with any partial word.
R eq ue st
Re qu es t    I ni ti al
              In it ia l     If No
                             If No
Fo rm
F or m        V al ue
              Va lu e        Ar gu me nt
                             A rg um en t   N ot es
                                            No te s   E xp la na ti on
                                                      Ex pl an at io n
.br           -              -              B         Break. The ﬁlling of the line currently being collected is
                                                      stopped and the line is output without adjustment. Text lines
                                                      beginning with space characters and empty text lines (blank
                                                      lines) also cause a break.
.fi           ﬁll on         -              B,E       Fill subsequent output lines. The register .u is 1 in ﬁll mode
                                                      and 0 in noﬁll mode.
.nf           ﬁll on         -              B,E       Noﬁll. Subsequent output lines are neither ﬁlled nor adjusted.
                                                      Input text lines are copied directly to output lines without
                                                      regard for the current line length.
.ad c         adj,both       adjust         E         Line adjustment is begun. If ﬁll mode is not on, adjustment
                                                      will be deferred until ﬁll mode is back on. If the type indica-
                                                      tor c is present, the adjustment type is changed as shown in
                                                      the following table.
                                                                  ________________________________
                                                                   Indicator 
                                                                  ________________________________
                                                                                      Adjust Type
                                                                       l      adjust left margin only 
                                                                                                       
                                                                       r      adjust right margin only 
                                                                       c      center                   
                                                                   b or n  adjust both margins         
                                                                   absent  unchanged
                                                                  ________________________________
                                                                                                       



                                                          - 12 -
NROFF/TROFF User’s Manual
October 11, 1976


.na           adjust        -              E         Noadjust. Adjustment is turned off; the right margin will be
                                                     ragged. The adjustment type for ad is not changed. Output
                                                     line ﬁlling still occurs if ﬁll mode is on.
.ce N         off           N=1            B,E       Center the next N input text lines within the current (line-
                                                     length minus indent). If N=0, any residual count is cleared.
                                                     A break occurs after each of the N input lines. If the input
                                                     line is too long, it will be left adjusted.
5. Vertical Spacing
5.1. Base-line spacing. The vertical spacing (V) between the base-lines of successive output lines can be set
using the vs request with a resolution of 1⁄144 inch = 1⁄2 point in TROFF, and to the output device resolution in
NROFF. V must be large enough to accommodate the character sizes on the affected output lines. For the com-
mon type sizes (9-12 points), usual typesetting practice is to set V to 2 points greater than the point size; TROFF
default is 10-point type on a 12-point spacing (as in this document). The current V is available in the .v register.
Multiple-V line separation (e. g. double spacing) may be requested with ls.
5.2. Extra line-space. If a word contains a vertically tall construct requiring the output line containing it to have
extra vertical space before and⁄or after it, the extra-line-space function \x´N ´ can be imbedded in or attached to
that word. In this and other functions having a pair of delimiters around their parameter (here ´ ), the delimiter
choice is arbitrary, except that it can’t look like the continuation of a number expression for N. If N is negative,
the output line containing the word will be preceded by N extra vertical space; if N is positive, the output line
containing the word will be followed by N extra vertical space. If successive requests for extra space apply to
the same line, the maximum values are used. The most recently utilized post-line extra line-space is available in
the .a register.
5.3. Blocks of vertical space. A block of vertical space is ordinarily requested using sp, which honors the no-
space mode and which does not space past a trap. A contiguous block of vertical space may be reserved using
sv.
R eq ue st
Re qu es t    I ni ti al
              In it ia l    If No
                            If No
Fo rm
F or m        V al ue
              Va lu e       Ar gu me nt
                            A rg um en t   N ot es
                                           No te s   E xp la na ti on
                                                     Ex pl an at io n
.vs N         1⁄6in;12pts   previous       E,p       Set vertical base-line spacing size V. Transient extra vertical
                                                     space available with \x´N ´ (see above).
.ls N         N=1           previous       E         Line spacing set to ±N. N−1 Vs (blank lines) are appended to
                                                     each output text line. Appended blank lines are omitted, if the
                                                     text or previous appended blank line reached a trap position.
.sp N         -             N=1V           B,v       Space vertically in either direction. If N is negative, the
                                                     motion is backward (upward) and is limited to the distance to
                                                     the top of the page. Forward (downward) motion is truncated
                                                     to the distance to the nearest trap. If the no-space mode is on,
                                                     no spacing occurs (see ns, and rs below).
.sv N         -             N=1V           v         Save a contiguous vertical block of size N. If the distance to
                                                     the next trap is greater than N, N vertical space is output.
                                                     No-space mode has no effect. If this distance is less than N,
                                                     no vertical space is immediately output, but N is remembered
                                                     for later output (see os). Subsequent sv requests will
                                                     overwrite any still remembered N.
.os           -             -              -         Output saved vertical space. No-space mode has no effect.
                                                     Used to ﬁnally output a block of vertical space requested by
                                                     an earlier sv request.
.ns           space         -              D         No-space mode turned on. When on, the no-space mode inhi-
                                                     bits sp requests and bp requests without a next page number.
                                                     The no-space mode is turned off when a line of output occurs,
                                                     or with rs.


                                                         - 13 -
NROFF/TROFF User’s Manual
October 11, 1976


.rs                  space         -              D         Restore spacing. The no-space mode is turned off.
Blank text line.                   -              B         Causes a break and output of a blank line exactly like sp 1.
6. Line Length and Indenting
The maximum line length for ﬁll mode may be set with ll. The indent may be set with in; an indent applicable
to only the next output line may be set with ti. The line length includes indent space but not page offset space.
The line-length minus the indent is the basis for centering with ce. The effect of ll, in, or ti is delayed, if a par-
tially collected line exists, until after that line is output. In ﬁll mode the length of text on an output line is less
than or equal to the line length minus the indent. The current line length and indent are available in registers .l
and .i respectively. The length of three-part titles produced by tl (see §14) is independently set by lt.
R eq ue st
Re qu es t          I ni ti al
                    In it ia l     If No
                                   If No
Fo rm
F or m              V al ue
                    Va lu e        Ar gu me nt
                                   A rg um en t   N ot es
                                                  No te s   E xp la na ti on
                                                            Ex pl an at io n
.ll ±N               6.5 in        previous       E,m       Line length is set to ±N. In TROFF the maximum (line-
                                                            length)+(page-offset) is about 7.54 inches.
.in ±N               N=0           previous       B,E,m Indent is set to ±N. The indent is prepended to each output
                                                        line.
.ti ±N               -             ignored        B,E,m Temporary indent. The next output text line will be indented
                                                        a distance ±N with respect to the current indent. The resulting
                                                        total indent may not be negative. The current indent is not
                                                        changed.
7. Macros, Strings, Diversion, and Position Traps
7.1. Macros and strings. A macro is a named set of arbitrary lines that may be invoked by name or with a trap.
A string is a named string of characters, not including a newline character, that may be interpolated by name at
any point. Request, macro, and string names share the same name list. Macro and string names may be one or
two characters long and may usurp previously deﬁned request, macro, or string names. Any of these entities may
be renamed with rn or removed with rm. Macros are created by de and di, and appended to by am and da; di
and da cause normal output to be stored in a macro. Strings are created by ds and appended to by as. A macro
is invoked in the same way as a request; a control line beginning .xx will interpolate the contents of macro xx.
The remainder of the line may contain up to nine arguments. The strings x and xx are interpolated at any desired
point with \∗x and \∗(xx respectively. String references and macro invocations may be nested.
7.2. Copy mode input interpretation. During the deﬁnition and extension of strings and macros (not by diversion)
the input is read in copy mode. The input is copied without interpretation except that:
             •   The contents of number registers indicated by \n are interpolated.
             •   Strings indicated by \∗ are interpolated.
             •   Arguments indicated by \$ are interpolated.
             •   Concealed newlines indicated by \(newline) are eliminated.
             •   Comments indicated by \" are eliminated.
             •   \t and \a are interpreted as ASCII horizontal tab and SOH respectively (§9).
             •   \\ is interpreted as \.
             •   \. is interpreted as ".".
These interpretations can be suppressed by prepending a \. For example, since \\ maps into a \, \\n will copy as
\n which will be interpreted as a number register indicator when the macro or string is reread.
7.3. Arguments. When a macro is invoked by name, the remainder of the line is taken to contain up to nine argu-
ments. The argument separator is the space character, and arguments may be surrounded by double-quotes to
permit imbedded space characters. Pairs of double-quotes may be imbedded in double-quoted arguments to
represent a single double-quote. If the desired arguments won’t ﬁt on a line, a concealed newline may be used to
continue on the next line.
When a macro is invoked the input level is pushed down and any arguments available at the previous level
become unavailable until the macro is completely read and the previous level is restored. A macro’s own argu-
ments can be interpolated at any point within the macro with \$N, which interpolates the Nth argument (1≤N≤9).


                                                                - 14 -
NROFF/TROFF User’s Manual
October 11, 1976


If an invoked argument doesn’t exist, a null string results. For example, the macro xx may be deﬁned by
             .de xx       \"begin deﬁnition
             Today is \\$1 the \\$2.
             ..           \"end deﬁnition
and called by
             .xx Monday 14th
to produce the text
             Today is Monday the 14th.
Note that the \$ was concealed in the deﬁnition with a prepended \. The number of currently available arguments
is in the .$ register.
No arguments are available at the top (non-macro) level in this implementation. Because string referencing is
implemented as a input-level push down, no arguments are available from within a string. No arguments are
available within a trap-invoked macro.
Arguments are copied in copy mode onto a stack where they are available for reference. The mechanism does
not allow an argument to contain a direct reference to a long string (interpolated at copy time) and it is advisable
to conceal string references (with an extra \ ) to delay interpolation until argument reference time.
7.4. Diversions. Processed output may be diverted into a macro for purposes such as footnote processing (see
Tutorial §T5) or determining the horizontal and vertical size of some text for conditional changing of pages or
columns. A single diversion trap may be set at a speciﬁed vertical position. The number registers dn and dl
respectively contain the vertical and horizontal size of the most recently ended diversion. Processed text that is
diverted into a macro retains the vertical size of each of its lines when reread in noﬁll mode regardless of the
current V. Constant-spaced (cs) or emboldened (bd) text that is diverted can be reread correctly only if these
modes are again or still in effect at reread time. One way to do this is to imbed in the diversion the appropriate
cs or bd requests with the transparent mechanism described in §10.6.
Diversions may be nested and certain parameters and registers are associated with the current diversion level (the
top non-diversion level may be thought of as the 0th diversion level). These are the diversion trap and associated
macro, no-space mode, the internally-saved marked place (see mk and rt), the current vertical place (.d register),
the current high-water text base-line (.h register), and the current diversion name (.z register).
7.5. Traps. Three types of trap mechanisms are available—page traps, a diversion trap, and an input-line-count
trap. Macro-invocation traps may be planted using wh at any page position including the top. This trap position
may be changed using ch. Trap positions at or below the bottom of the page have no effect unless or until
moved to within the page or rendered effective by an increase in page length. Two traps may be planted at the
same position only by ﬁrst planting them at different positions and then moving one of the traps; the ﬁrst planted
trap will conceal the second unless and until the ﬁrst one is moved (see Tutorial Examples §T5). If the ﬁrst one
is moved back, it again conceals the second trap. The macro associated with a page trap is automatically
invoked when a line of text is output whose vertical size reaches or sweeps past the trap position. Reaching the
bottom of a page springs the top-of-page trap, if any, provided there is a next page. The distance to the next trap
position is available in the .t register; if there are no traps between the current position and the bottom of the
page, the distance returned is the distance to the page bottom.
A macro-invocation trap effective in the current diversion may be planted using dt. The .t register works in a
diversion; if there is no subsequent trap a large distance is returned. For a description of input-line-count traps,
see it below.
R eq ue st
Re qu es t        I ni ti al
                  In it ia l   If No
                               If No
Fo rm
F or m            V al ue
                  Va lu e      Ar gu me nt
                               A rg um en t   N ot es
                                              No te s   E xp la na ti on
                                                        Ex pl an at io n
.de xx yy         -            .yy=..         -         Deﬁne or redeﬁne the macro xx. The contents of the macro
                                                        begin on the next input line. Input lines are copied in copy
                                                        mode until the deﬁnition is terminated by a line beginning
                                                        with .yy, whereupon the macro yy is called. In the absence of
                                                        yy, the deﬁnition is terminated by a line beginning with "..".


                                                            - 15 -
NROFF/TROFF User’s Manual
October 11, 1976


                                                  A macro may contain de requests provided the terminating
                                                  macros differ or the contained deﬁnition terminator is con-
                                                  cealed. ".." can be concealed as \\.. which will copy as \.. and
                                                  be reread as "..".
.am xx yy     -             .yy=..        -       Append to macro (append version of de).
.ds xx string -             ignored       -       Deﬁne a string xx containing string. Any initial double-quote
                                                  in string is stripped off to permit initial blanks.
.as xx string -             ignored       -       Append string to string xx (append version of ds).
.rm xx        -             ignored       -       Remove request, macro, or string. The name xx is removed
                                                  from the name list and any related storage space is freed.
                                                  Subsequent references will have no effect.
.rn xx yy     -             ignored       -       Rename request, macro, or string xx to yy. If yy exists, it is
                                                  ﬁrst removed.
.di xx        -             end           D       Divert output to macro xx. Normal text processing occurs dur-
                                                  ing diversion except that page offsetting is not done. The
                                                  diversion ends when the request di or da is encountered
                                                  without an argument; extraneous requests of this type should
                                                  not appear when nested diversions are being used.
.da xx        -             end           D       Divert, appending to xx (append version of di).
.wh N xx      -             -             v       Install a trap to invoke xx at page position N; a negative N
                                                  will be interpreted with respect to the page bottom. Any
                                                  macro previously planted at N is replaced by xx. A zero N
                                                  refers to the top of a page. In the absence of xx, the ﬁrst
                                                  found trap at N, if any, is removed.
.ch xx N      -             -             v       Change the trap position for macro xx to be N. In the absence
                                                  of N, the trap, if any, is removed.
.dt N xx      -             off           D,v     Install a diversion trap at position N in the current diversion to
                                                  invoke macro xx. Another dt will redeﬁne the diversion trap.
                                                  If no arguments are given, the diversion trap is removed.
.it N xx      -             off           E       Set an input-line-count trap to invoke the macro xx after N
                                                  lines of text input have been read (control or request lines
                                                  don’t count). The text may be in-line text or text interpolated
                                                  by inline or trap-invoked macros.
.em xx        none          none          -       The macro xx will be invoked when all input has ended. The
                                                  effect is the same as if the contents of xx had been at the end
                                                  of the last ﬁle processed.
8. Number Registers
A variety of parameters are available to the user as predeﬁned, named number registers (see Summary and Index,
page 7). In addition, the user may deﬁne his own named registers. Register names are one or two characters
long and do not conﬂict with request, macro, or string names. Except for certain predeﬁned read-only registers, a
number register can be read, written, automatically incremented or decremented, and interpolated into the input in
a variety of formats. One common use of user-deﬁned registers is to automatically number sections, paragraphs,
lines, etc. A number register may be used any time numerical input is expected or desired and may be used in
numerical expressions (§1.4).
Number registers are created and modiﬁed using nr, which speciﬁes the name, numerical value, and the auto-
increment size. Registers are also modiﬁed, if accessed with an auto-incrementing sequence. If the registers x
and xx both contain N and have the auto-increment size M, the following access sequences have the effect shown:




                                                      - 16 -
NROFF/TROFF User’s Manual
October 11, 1976

                                 __________________________________________
                                                  Effect on      Value        
                                  _________________________________________
                                 _Sequence          Register      Interpolated
                                                                              
                                  \nx               none              N       
                                  \n(xx             none              N       
                                  \n+x      x incremented by M  N+M           
                                  \n– x     x decremented by M  N– M          
                                  \n+(xx    xx incremented by M  N+M          
                                                                              
                                 __________________________________________
                                  \n– (xx   xx decremented by M  N– M

When interpolated, a number register is converted to decimal (default), decimal with leading zeros, lower-case
Roman, upper-case Roman, lower-case sequential alphabetic, or upper-case sequential alphabetic according to the
format speciﬁed by af.
R eq ue st
Re qu es t    I ni ti al
              In it ia l     If No
                             If No
Fo rm
F or m        V al ue
              Va lu e        Ar gu me nt
                             A rg um en t   N ot es
                                            No te s   E xp la na ti on
                                                      Ex pl an at io n
.nr R ±N M -                 u              The number register R is assigned the value ±N with respect to the pre-
                                                   vious value, if any. The increment for auto-incrementing is
                                                   set to M.
.af R c       arabic         -              -         Assign format c to register R. The available formats are:
                                                              _______________________________________
                                                                                       Numbering          
                                                              ______________________________________
                                                              _ Format                   Sequence
                                                                                                          
                                                               1       0,1,2,3,4,5,...                    
                                                               001  000,001,002,003,004,005,...           
                                                               i       0,i,ii,iii,iv,v,...                
                                                               I       0,I,II,III,IV,V,...                
                                                               a       0,a,b,c,...,z,aa,ab,...,zz,aaa,... 
                                                                                                          
                                                              _ A
                                                              ______________________________________
                                                                        0,A,B,C,...,Z,AA,AB,...,ZZ,AAA,...

                                                      An arabic format having N digits speciﬁes a ﬁeld width of N
                                                      digits (example 2 above). The read-only registers and the
                                                      width function (§11.2) are always arabic.
.rr R         -              ignored        -         Remove register R. If many registers are being created
                                                      dynamically, it may become necessary to remove no longer
                                                      used registers to recapture internal storage space for newer
                                                      registers.
9. Tabs, Leaders, and Fields
9.1. Tabs and leaders. The ASCII horizontal tab character and the ASCII SOH (hereafter known as the leader
character) can both be used to generate either horizontal motion or a string of repeated characters. The length of
the generated entity is governed by internal tab stops speciﬁable with ta. The default difference is that tabs gen-
erate motion and leaders generate a string of periods; tc and lc offer the choice of repeated character or motion.
There are three types of internal tab stops—left adjusting, right adjusting, and centering. In the following table:
D is the distance from the current position on the input line (where a tab or leader was found) to the next tab
stop; next-string consists of the input characters following the tab (or leader) up to the next tab (or leader) or end
of line; and W is the width of next-string.
                           _
                           ____________________________________________________
                            Tab       Length of motion or           Location of          
                            type  repeated characters 
                           ____________________________________________________
                           _                                           next-string
                                                                                         
                            Left               D            Following D                  
                            Right            D– W           Right adjusted within D      
                            Centered 
                           ____________________________________________________
                           _
                                            D– W⁄2          Centered on right end of D 
                                                             



                                                          - 17 -
NROFF/TROFF User’s Manual
October 11, 1976


The length of generated motion is allowed to be negative, but that of a repeated character string cannot be.
Repeated character strings contain an integer number of characters, and any residual distance is prepended as
motion. Tabs or leaders found after the last tab stop are ignored, but may be used as next-string terminators.
Tabs and leaders are not interpreted in copy mode. \t and \a always generate a non-interpreted tab and leader
respectively, and are equivalent to actual tabs and leaders in copy mode.
9.2. Fields. A ﬁeld is contained between a pair of ﬁeld delimiter characters, and consists of sub-strings separated
by padding indicator characters. The ﬁeld length is the distance on the input line from the position where the
ﬁeld begins to the next tab stop. The difference between the total length of all the sub-strings and the ﬁeld
length is incorporated as horizontal padding space that is divided among the indicated padding places. The incor-
porated padding is allowed to be negative. For example, if the ﬁeld delimiter is # and the padding indicator is ˆ,
#ˆxxxˆright # speciﬁes a right-adjusted string with the string xxx centered in the remaining space.
R eq ue st
Re qu es t    I ni ti al
              In it ia l    If No
                            If No
Fo rm
F or m        V al ue
              Va lu e       Ar gu me nt
                            A rg um en t   N ot es
                                           No te s   E xp la na ti on
                                                     Ex pl an at io n
.ta Nt ...    0.8; 0.5in    none           E,m       Set tab stops and types. t=R, right adjusting; t=C, centering;
                                                     t absent, left adjusting. TROFF tab stops are preset every
                                                     0.5in.; NROFF every 0.8in. The stop values are separated by
                                                     spaces, and a value preceded by + is treated as an increment
                                                     to the previous stop value.
.tc c         none          none           E         The tab repetition character becomes c, or is removed specify-
                                                     ing motion.
.lc c         .             none           E         The leader repetition character becomes c, or is removed
                                                     specifying motion.
.fc a b       off           off            -         The ﬁeld delimiter is set to a; the padding indicator is set to
                                                     the space character or to b, if given. In the absence of argu-
                                                     ments the ﬁeld mechanism is turned off.
10. Input and Output Conventions and Character Translations
10.1. Input character translations. Ways of inputting the graphic character set were discussed in §2.1. The
ASCII control characters horizontal tab (§9.1), SOH (§9.1), and backspace (§10.3) are discussed elsewhere. The
newline delimits input lines. In addition, STX, ETX, ENQ, ACK, and BEL are accepted, and may be used as del-
imiters or translated into a graphic with tr (§10.5). All others are ignored.
The escape character \ introduces escape sequences—causes the following character to mean another character, or
to indicate some function. A complete list of such sequences is given in the Summary and Index on page 6. \
should not be confused with the ASCII control character ESC of the same name. The escape character \ can be
input with the sequence \\. The escape character can be changed with ec, and all that has been said about the
default \ becomes true for the new escape character. \e can be used to print whatever the current escape character
is. If necessary or convenient, the escape mechanism may be turned off with eo, and restored with ec.
R eq ue st
Re qu es t    I ni ti al
              In it ia l    If No
                            If No
Fo rm
F or m        V al ue
              Va lu e       Ar gu me nt
                            A rg um en t   N ot es
                                           No te s   E xp la na ti on
                                                     Ex pl an at io n
.ec c         \             \              -         Set escape character to \, or to c, if given.
.eo           on            -              -         Turn escape mechanism off.
10.2. Ligatures. Five ligatures are available in the current TROFF character set — ﬁ, ﬂ, ff, ffi, and ffl. They may
be input (even in NROFF) by \(fi, \(fl, \(ff, \(Fi, and \(Fl respectively. The ligature mode is normally on in
TROFF, and automatically invokes ligatures during input.
R eq ue st
Re qu es t    I ni ti al
              In it ia l    If No
                            If No
Fo rm
F or m        V al ue
              Va lu e       Ar gu me nt
                            A rg um en t   N ot es
                                           No te s   E xp la na ti on
                                                     Ex pl an at io n
.lg N         off; on       on             -         Ligature mode is turned on if N is absent or non-zero, and
                                                     turned off if N=0. If N=2, only the two-character ligatures are
                                                     automatically invoked. Ligature mode is inhibited for request,


                                                         - 18 -
NROFF/TROFF User’s Manual
October 11, 1976


                                                     macro, string, register, or ﬁle names, and in copy mode. No
                                                     effect in NROFF.
10.3. Backspacing, underlining, overstriking, etc. Unless in copy mode, the ASCII backspace character is replaced
by a backward horizontal motion having the width of the space character. Underlining as a form of line-drawing
is discussed in §12.4. A generalized overstriking function is described in §12.1.
NROFF automatically underlines characters in the underline font, speciﬁable with uf, normally that on font posi-
tion 2 (normally Times Italic, see §2.2). In addition to ft and \fF, the underline font may be selected by ul and
cu. Underlining is restricted to an output-device-dependent subset of reasonable characters.
R eq ue st
Re qu es t     I ni ti al
               In it ia l   If No
                            If No
Fo rm
F or m         V al ue
               Va lu e      Ar gu me nt
                            A rg um en t   N ot es
                                           No te s   E xp la na ti on
                                                     Ex pl an at io n
.ul N          off          N=1            E         Underline in NROFF (italicize in TROFF) the next N input text
                                                     lines. Actually, switch to underline font, saving the current
                                                     font for later restoration; other font changes within the span of
                                                     a ul will take effect, but the restoration will undo the last
                                                     change. Output generated by tl (§14) is affected by the font
                                                     change, but does not decrement N. If N>1, there is the risk
                                                     that a trap interpolated macro may provide text lines within
                                                     the span; environment switching can prevent this.
.cu N          off          N=1            E         A variant of ul that causes every character to be underlined in
                                                     NROFF. Identical to ul in TROFF.
.uf F          Italic       Italic         -         Underline font set to F. In NROFF, F may not be on position
                                                     1 (initially Times Roman).
10.4. Control characters. Both the control character . and the no-break control character ´ may be changed, if
desired. Such a change must be compatible with the design of any macros used in the span of the change, and
particularly of any trap-invoked macros.
R eq ue st
Re qu es t     I ni ti al
               In it ia l   If No
                            If No
Fo rm
F or m         V al ue
               Va lu e      Ar gu me nt
                            A rg um en t   N ot es
                                           No te s   E xp la na ti on
                                                     Ex pl an at io n
.cc c          .            .              E         The basic control character is set to c, or reset to ".".
.c2 c          ´            ´              E         The nobreak control character is set to c, or reset to "´".
10.5. Output translation. One character can be made a stand-in for another character using tr. All text process-
ing (e. g. character comparisons) takes place with the input (stand-in) character which appears to have the width
of the ﬁnal character. The graphic translation occurs at the moment of output (including diversion).
R eq ue st
Re qu es t     I ni ti al
               In it ia l   If No
                            If No
Fo rm
F or m         V al ue
               Va lu e      Ar gu me nt
                            A rg um en t   N ot es
                                           No te s   E xp la na ti on
                                                     Ex pl an at io n
.tr abcd....   none         -              O         Translate a into b, c into d, etc. If an odd number of charac-
                                                     ters is given, the last one will be mapped into the space char-
                                                     acter. To be consistent, a particular translation must stay in
                                                     effect from input to output time.
10.6. Transparent throughput. An input line beginning with a \! is read in copy mode and transparently output
(without the initial \!); the text processor is otherwise unaware of the line’s presence. This mechanism may be
used to pass control information to a post-processor or to imbed control lines in a macro created by a diversion.
10.7. Comments and concealed newlines. An uncomfortably long input line that must stay one line (e. g. a string
deﬁnition, or noﬁlled text) can be split into many physical lines by ending all but the last one with the escape \.
The sequence \(newline) is always ignored—except in a comment. Comments may be imbedded at the end of
any line by prefacing them with \". The newline at the end of a comment cannot be concealed. A line begin-
ning with \" will appear as a blank line and behave like .sp 1; a comment can be on a line by itself by beginning
the line with .\".




                                                         - 19 -
NROFF/TROFF User’s Manual
October 11, 1976


11. Local Horizontal and Vertical Motions, and the Width Function
11.1. Local Motions. The functions \v´N ´ and \h´N ´ can be used for local vertical and horizontal motion respec-
tively. The distance N may be negative; the positive directions are rightward and downward. A local motion is
one contained within a line. To avoid unexpected vertical dislocations, it is necessary that the net vertical local
motion within a word in ﬁlled text and otherwise within a line balance to zero. The above and certain other
escape sequences providing local motion are summarized in the following table.
          _____________________________________________________________________________
           Vertical                 Effect in          Horizontal              Effect in           
          ____________________________________________________________________________
          _ Local Motion  TROFF                NROFF   Local Motion        TROFF            NROFF
                                                                                                   
              \v´N ´      Move distance N                \h´N ´     Move distance N                
          _____________________________________
                                                                      Unpaddable space-size space 
                                                             \(space)
                         1              1                                                         
              \u         1 ⁄2 em up     1 ⁄2 line up      \0         Digit-size space
                                                        _______________________________________
                                                         _
              \d          ⁄2 em down  ⁄2 line down                                               
              \r          1 em up        1 line up      \         1⁄6 em space          ignored 
                                                        \ˆ         1⁄12 em space         ignored 
          ____________________________________________________________________________
          _                                                                              

As an example, E2 could be generated by the sequence E\s– 2\v´– 0.4m´2\v´0.4m´\s+2; it should be noted in this
example that the 0.4 em vertical motions are at the smaller size.
11.2. Width Function. The width function \w´string ´ generates the numerical width of string (in basic units).
Size and font changes may be safely imbedded in string, and will not affect the current environment. For exam-
ple, .ti – \w´1. ´u could be used to temporarily indent leftward a distance equal to the size of the string "1. ".
The width function also sets three number registers. The registers st and sb are set respectively to the highest
and lowest extent of string relative to the baseline; then, for example, the total height of the string is
\n(stu– \n(sbu. In TROFF the number register ct is set to a value between 0 and 3: 0 means that all of the char-
acters in string were short lower case characters without descenders (like e); 1 means that at least one character
has a descender (like y); 2 means that at least one character is tall (like H); and 3 means that both tall characters
and characters with descenders are present.
11.3. Mark horizontal place. The escape sequence \kx will cause the current horizontal position in the input line
to be stored in register x. As an example, the construction \kxword \h´  \nxu+2u´word will embolden word by
backing up to almost its beginning and overprinting it, resulting in word
                                                                     word.
12. Overstrike, Bracket, Line-drawing, and Zero-width Functions
12.1. Overstriking. Automatically centered overstriking of up to nine characters is provided by the overstrike
function \o´string ´. The characters in string overprinted with centers aligned; the total width is that of the widest
character. string should not contain local vertical motion. As examples, \o´e\´´ produces e, and \o´\(mo\(sl´ pro-
                                                                                              ´
duces ∈.
       ⁄
12.2. Zero-width characters. The function \zc will output c without spacing over it, and can be used to produce
left-aligned overstruck combinations. As examples, \z\(ci\(pl will produce +, and \(br\z\(rn\(ul\(br will produce
                                      _
the smallest possible constructed box  .
 12.3. Large Brackets. The Special Mathematical Font contains a number of bracket construction pieces
 (            ) that can be combined into various bracket styles. The function \b´string ´ may be used
 to pile up vertically the characters in string (the ﬁrst character on top and the last at the bottom); the characters
 are vertically separated by 1 em and the total pile is centered 1⁄2 em above the current baseline 1(2 line in
                                                                                                           ⁄
                                                                                      E .
NROFF). For example, \b´ \(lc\(lf ´E\  \b´ \(rc\(rf ´ \x´ – 0.5m´ \x´0.5m´ produces
                                                                                      
12.4. Line drawing. The function \ l ´Nc ´ will draw a string of repeated c ’s towards the right for a distance N.
( \l is \(lower case L). If c looks like a continuation of an expression for N, it may insulated from N with a \&.
If c is not speciﬁed, the _ (baseline rule) is used (underline character in NROFF). If N is negative, a backward
horizontal motion of size N is made before drawing the string. Any space resulting from N ⁄(size of c) having a
remainder is put at the beginning (left end) of the string. In the case of characters that are designed to be con-
nected such as baseline-rule _ , underrule _ , and root-en  , the remainder space is covered by over-lapping. If N


                                                        - 20 -
NROFF/TROFF User’s Manual
October 11, 1976


is less than the width of c, a single c is centered on a distance N. As an example, a macro to underscore a string
can be written
             .de us
             \\$1\ l ´  0\(ul´
             ..
or one to draw a box around a string
             .de bx
             \(br\  \\$1\  \(br\ l ´  0\(rn´\ l ´  0\(ul´
             ..
such that
             .ul "underlined words"
and
             .bx "words in a box"
      ______________
      _                    
                           _____________
                           .
yield underlined words and_
                           words in a box
The function \L´ Nc ´ will draw a vertical line consisting of the (optional) character c stacked vertically apart 1 em
(1 line in NROFF), with the ﬁrst two characters overlapped, if necessary, to form a continuous line. The default
 character is the box rule  ( \(br); the other suitable character is the bold vertical  ( \(bv). The line is begun
 without any initial motion relative to the current base line. A positive N speciﬁes a line drawn downward and a
 negative N speciﬁes a line drawn upward. After the line is drawn no compensating motions are made; the instan-
 taneous baseline is at the end of the line.
_______________________________________________________________________________________________
The horizontal and vertical line drawing functions may be used in combination to produce large boxes. The 
zero-width box-rule and the 1⁄2 -em wide underrule were designed to form corners when using 1-em vertical spac- 
ings. For example the macro                                                                                     
                                                                                                                
        .de eb                                                                                                  
        .sp – 1         \"compensate for next automatic base-line spacing                                       
                                                                                                                
        .nf             \"avoid possibly overﬂowing word buffer
                                                                                                                 
        \h´– .5n´\L´  \\nau– 1´\l´\\n(.lu+1n\(ul´\L´–  \\nau+1´\l´  0u– .5n\(ul´ \"draw box                  
        .fi                                                                                                     
        ..                                                                                                      
                                                                                                                
will draw a box around some text whose beginning vertical place was saved in number register a (e. g. using 
.mk a) as done for this paragraph.
_______________________________________________________________________________________________
13. Hyphenation.
The automatic hyphenation may be switched off and on. When switched on with hy, several variants may be set.
A hyphenation indicator character may be imbedded in a word to specify desired hyphenation points, or may be
prepended to suppress hyphenation. In addition, the user may specify a small exception word list.
Only words that consist of a central alphabetic string surrounded by (usually null) non-alphabetic strings are con-
sidered candidates for automatic hyphenation. Words that were input containing hyphens (minus), em-dashes
(\(em), or hyphenation indicator characters—such as mother-in-law—are always subject to splitting after those
characters, whether or not automatic hyphenation is on or off.
R eq ue st
Re qu es t         I ni ti al
                   In it ia l        If No
                                     If No
Fo rm
F or m             V al ue
                   Va lu e           Ar gu me nt
                                     A rg um en t     N ot es
                                                      No te s   E xp la na ti on
                                                                Ex pl an at io n
.nh                hyphenate         -                E         Automatic hyphenation is turned off.
.hyN               on,N=1            on,N=1           E         Automatic hyphenation is turned on for N ≥1, or off for N= 0.
                                                                If N= 2, last lines (ones that will cause a trap) are not
                                                                hyphenated. For N= 4 and 8, the last and ﬁrst two characters
                                                                respectively of a word are not split off. These values are addi-
                                                                tive; i. e. N= 14 will invoke all three restrictions.


                                                                    - 21 -
NROFF/TROFF User’s Manual
October 11, 1976


.hc c            \%           \%             E         Hyphenation indicator character is set to c or to the default
                                                       \%. The indicator does not appear in the output.
.hw word1 ... ignored         -              Specify hyphenation points in words with imbedded minus signs. Ver-
                                                     sions of a word with terminal s are implied; i. e. dig– it
                                                     implies dig– its. This list is examined initially and after each
                                                     sufﬁx stripping. The space available is small—about 128
                                                     characters.
14. Three Part Titles.
The titling function tl provides for automatic placement of three ﬁelds at the left, center, and right of a line with
a title-length speciﬁable with lt. tl may be used anywhere, and is independent of the normal text collecting pro-
cess. A common use is in header and footer macros.
R eq ue st
Re qu es t       I ni ti al
                 In it ia l   If No
                              If No
Fo rm
F or m           V al ue
                 Va lu e      Ar gu me nt
                              A rg um en t   N ot es
                                             No te s   E xp la na ti on
                                                       Ex pl an at io n
.tl ´left ´center ´right ´    -              -         The strings left, center, and right are respectively left-adjusted,
                                                       centered, and right-adjusted in the current title-length. Any of
                                                       the strings may be empty, and overlapping is permitted. If the
                                                       page-number character (initially %) is found within any of the
                                                       ﬁelds it is replaced by the current page number having the for-
                                                       mat assigned to register %. Any character may be used as the
                                                       string delimiter.
.pc c            %            off            -         The page number character is set to c, or removed. The
                                                       page-number register remains %.
.lt ±N           6.5 in       previous       E,m       Length of title set to ±N. The line-length and the title-length
                                                       are independent. Indents do not apply to titles; page-offsets
                                                       do.
15. Output Line Numbering.
     Automatic sequence numbering of output lines may be requested with nm. When in effect, a three-digit,
     arabic number plus a digit-space is prepended to output text lines. The text lines are thus offset by four
   3 digit-spaces, and otherwise retain their line length; a reduction in line length may be desired to keep the
     right margin aligned with an earlier margin. Blank lines, other vertical spaces, and lines generated by tl are
     not numbered. Numbering can be temporarily suspended with nn, or with an .nm followed by a later
   6 .nm +0. In addition, a line number indent I, and the number-text separation S may be speciﬁed in digit-
     spaces. Further, it can be speciﬁed that only those line numbers that are multiples of some number M are to
     be printed (the others will appear as blank number ﬁelds).
R eq ue st
Re qu es t       I ni ti al
                 In it ia l   If No
                              If No
Fo rm
F or m           V al ue
                 Va lu e      Ar gu me nt
                              A rg um en t   N ot es
                                             No te s   E xp la na ti on
                                                       Ex pl an at io n
.nm ±N M S I                  off            E         Line number mode. If ±N is given, line numbering is turned
                                                       on, and the next output line numbered is numbered ±N.
                                                       Default values are M= 1, S= 1, and I= 0. Parameters
                                                       corresponding to missing arguments are unaffected; a non-
                                                       numeric argument is considered missing. In the absence of all
                                                       arguments, numbering is turned off; the next line number is
                                                       preserved for possible further use in number register ln.
.nn N            -            N=1            E         The next N text output lines are not numbered.
  9 As an example, the paragraph portions of this section are numbered with M= 3: .nm 1 3 was placed at the
    beginning; .nm was placed at the end of the ﬁrst paragraph; and .nm +0 was placed in front of this para-
    graph; and .nm ﬁnally placed at the end. Line lengths were also changed (by \w´0000´u) to keep the right
 12 side aligned. Another example is .nm +5 5 x 3 which turns on numbering with the line number of the next
    line to be 5 greater than the last numbered line, with M= 5, with spacing S untouched, and with the indent I


                                                           - 22 -
NROFF/TROFF User’s Manual
October 11, 1976


      set to 3.
16. Conditional Acceptance of Input
In the following, c is a one-character, built-in condition name, ! signiﬁes not, N is a numerical expression,
string1 and string2 are strings delimited by any non-blank, non-numeric character not in the strings, and anything
represents what is conditionally accepted.
R eq ue st
Re qu es t        I ni ti al
                  In it ia l    If No
                                If No
Fo rm
F or m            V al ue
                  Va lu e       Ar gu me nt
                                A rg um en t     N ot es
                                                 No te s   E xp la na ti on
                                                           Ex pl an at io n
.if c anything                  -                -         If condition c true, accept anything as input; in multi-line case
                                                           use \{anything \}.
.if !c anything                 -                -         If condition c false, accept anything.
.if N anything-                 u                If expression N > 0, accept anything.
.if !N anything                 -                u         If expression N ≤ 0, accept anything.
.if ´string1 ´string2 ´ anything                 -         If string1 identical to string2, accept anything.
.if ! ´string1 ´string2 ´ anything               -         If string1 not identical to string2, accept anything.
.ie c anything -                u                If portion of if-else; all above forms (like if).
.el anything                    -                -         Else portion of if-else.
The built-in condition names are:
                                          _____________________________________
                                           Condition                              
                                           Name                                   
                                          _____________________________________
                                                     
                                                                   True If
                                              o       Current page number is odd 
                                              e       Current page number is even 
                                              t       Formatter is TROFF          
                                          ____________________________________
                                                       Formatter is NROFF
                                          _
                                              n                                   

If the condition c is true, or if the number N is greater than zero, or if the strings compare identically (including
motions and character size and font), anything is accepted as input. If a ! precedes the condition, number, or
string comparison, the sense of the acceptance is reversed.
Any spaces between the condition and the beginning of anything are skipped over. The anything can be either a
single input line (text, macro, or whatever) or a number of input lines. In the multi-line case, the ﬁrst line must
begin with a left delimiter \{ and the last line must end with a right delimiter \}.
The request ie (if-else) is identical to if except that the acceptance state is remembered. A subsequent and
matching el (else) request then uses the reverse sense of that state. ie - el pairs may be nested.
Some examples are:
             .if e .tl ´ Even Page %´´´
which outputs a title if the page number is even; and
             .ie \n%>1 \{\
             ´sp 0.5i
             .tl ´ Page %´´´
             ´sp  1.2i \}
             .el .sp  2.5i
which treats page 1 differently from other pages.
17. Environment Switching.
A number of the parameters that control the text processing are gathered together into an environment, which can
be switched by the user. The environment parameters are those associated with requests noting E in their Notes
column; in addition, partially collected lines and words are in the environment. Everything else is global;


                                                               - 23 -
NROFF/TROFF User’s Manual
October 11, 1976


examples are page-oriented parameters, diversion-oriented parameters, number registers, and macro and string
deﬁnitions. All environments are initialized with default parameter values.
R eq ue st
Re qu es t    I ni ti al
              In it ia l   If No
                           If No
Fo rm
F or m        V al ue
              Va lu e      Ar gu me nt
                           A rg um en t   N ot es
                                          No te s   E xp la na ti on
                                                    Ex pl an at io n
.ev N         N=0          previous       -         Environment switched to environment 0≤N≤2. Switching is
                                                    done in push-down fashion so that restoring a previous
                                                    environment must be done with .ev rather than speciﬁc refer-
                                                    ence.
18. Insertions from the Standard Input
The input can be temporarily switched to the system standard input with rd, which will switch back when two
newlines in a row are found (the extra blank line is not used). This mechanism is intended for insertions in
form-letter-like documentation. On UNIX, the standard input can be the user’s keyboard, a pipe, or a ﬁle.
R eq ue st
Re qu es t    I ni ti al
              In it ia l   If No
                           If No
Fo rm
F or m        V al ue
              Va lu e      Ar gu me nt
                           A rg um en t   N ot es
                                          No te s   E xp la na ti on
                                                    Ex pl an at io n
.rd prompt    -            prompt=BEL -             Read insertion from the standard input until two newlines in a
                                                    row are found. If the standard input is the user’s keyboard,
                                                    prompt (or a BEL) is written onto the user’s terminal. rd
                                                    behaves like a macro, and arguments may be placed after
                                                    prompt.
.ex           -            -              -         Exit from NROFF⁄TROFF. Text processing is terminated
                                                    exactly as if all input had ended.
If insertions are to be taken from the terminal keyboard while output is being printed on the terminal, the com-
mand line option – q will turn off the echoing of keyboard input and prompt only with BEL. The regular input
and insertion input cannot simultaneously come from the standard input.
As an example, multiple copies of a form letter may be prepared by entering the insertions for all the copies in
one ﬁle to be used as the standard input, and causing the ﬁle containing the letter to reinvoke itself using nx
(§19); the process would ultimately be ended by an ex in the insertion ﬁle.
19. Input⁄Output File Switching
R eq ue st
Re qu es t    I ni ti al
              In it ia l   If No
                           If No
Fo rm
F or m        V al ue
              Va lu e      Ar gu me nt
                           A rg um en t   N ot es
                                          No te s   E xp la na ti on
                                                    Ex pl an at io n
.so ﬁlename                -              -         Switch source ﬁle. The top input (ﬁle reading) level is
                                                    switched to ﬁlename. The effect of an so encountered in a
                                                    macro is not felt until the input level returns to the ﬁle level.
                                                    When the new ﬁle ends, input is again taken from the original
                                                    ﬁle. so’s may be nested.
.nx ﬁlename                end-of-ﬁle     -         Next ﬁle is ﬁlename. The current ﬁle is considered ended, and
                                                    the input is immediately switched to ﬁlename.
.pi program                -              -         Pipe output to program (NROFF only). This request must
                                                    occur before any printing occurs. No arguments are transmit-
                                                    ted to program.
20. Miscellaneous

R eq ue st
Re qu es t    I ni ti al
              In it ia l   If No
                           If No
Fo rm
F or m        V al ue
              Va lu e      Ar gu me nt
                           A rg um en t   N ot es
                                          No te s   E xp la na ti on
                                                    Ex pl an at io n
.mc c N       -            off            E,m       Speciﬁes that a margin character c appear a distance N to the       
                                                    right of the right margin after each non-empty text line (except    
                                                    those produced by tl). If the output line is too-long (as can       
                                                    happen in noﬁll mode) the character will be appended to the         


                                                        - 24 -
NROFF/TROFF User’s Manual
October 11, 1976


                                                    line. If N is not given, the previous N is used; the initial N is 
                                                    0.2 inches in NROFF and 1 em in TROFF. The margin charac- 
                                                    ter used with this paragraph was a 12-point box-rule.             
.tm string    -             newline        -        After skipping initial blanks, string (rest of the line) is read in
                                                    copy mode and written on the user’s terminal.
.ig yy        -             .yy=..         -        Ignore input lines. ig behaves exactly like de (§7) except that
                                                    the input is discarded. The input is read in copy mode, and
                                                    any auto-incremented registers will be affected.
.pm t         -             all            -        Print macros. The names and sizes of all of the deﬁned mac-
                                                    ros and strings are printed on the user’s terminal; if t is given,
                                                    only the total of the sizes is printed. The sizes is given in
                                                    blocks of 128 characters.
.fl           -             -              B        Flush output buffer. Used in interactive debugging to force
                                                    output.
21. Output and Error Messages.
The output from tm, pm, and the prompt from rd, as well as various error messages are written onto UNIX’s
standard message output. The latter is different from the standard output, where NROFF formatted output goes.
By default, both are written onto the user’s terminal, but they can be independently redirected.
Various error conditions may occur during the operation of NROFF and TROFF. Certain less serious errors hav-
ing only local impact do not cause processing to terminate. Two examples are word overﬂow, caused by a word
that is too large to ﬁt into the word buffer (in ﬁll mode), and line overﬂow, caused by an output line that grew
too large to ﬁt in the line buffer; in both cases, a message is printed, the offending excess is discarded, and the
affected word or line is marked at the point of truncation with a ∗ in NROFF and a       in TROFF. The philosophy
is to continue processing, if possible, on the grounds that output useful for debugging may be produced. If a
serious error occurs, processing terminates, and an appropriate message is printed. Examples are the inability to
create, read, or write ﬁles, and the exceeding of certain internal limits that make future output unlikely to be use-
ful.




                                                       - 25 -
NROFF/TROFF User’s Manual
October 11, 1976




                                                TUTORIAL EXAMPLES


T1. Introduction                                                     because some part or whole word didn’t ﬁt on it. If
Although NROFF and TROFF have by design a syntax                     anything in the footer and header that follows causes
reminiscent of earlier text processors* with the intent              a break, that word or part word will be forced out. In
of easing their use, it is almost always necessary to                this and other examples, requests like bp and sp that
prepare at least a small set of macro deﬁnitions to                  normally cause breaks are invoked using the no-break
describe most documents. Such common formatting                      control character ´ to avoid this. When the
needs as page margins and footnotes are deliberately                 header⁄footer design contains material requiring
not built into NROFF and TROFF. Instead, the macro                   independent text processing, the environment may be
and string deﬁnition, number register, diversion,                    switched, avoiding most interaction with the running
environment switching, page-position trap, and condi-                text.
tional input mechanisms provide the basis for user-                  A more realistic example would be
deﬁned implementations.                                                 .de hd                \"header
The examples to be discussed are intended to be use-                    .if t .tl ´ \(rn´´\(rn´ \"troff cut mark
ful and somewhat realistic, but won’t necessarily                       .if \\n%>1 \{\
cover all relevant contingencies. Explicit numerical                    ´sp  0.5i– 1         \"tl base at 0.5i
parameters are used in the examples to make them                        .tl ´´– % – ´´        \"centered page number
easier to read and to illustrate typical values. In                     .ps                   \"restore size
many cases, number registers would really be used to                    .ft                   \"restore font
reduce the number of places where numerical infor-                      .vs \}                \"restore vs
mation is kept, and to concentrate conditional parame-                  ´sp  1.0i            \"space to 1.0i
ter initialization like that which depends on whether                   .ns                   \"turn on no-space mode
TROFF or NROFF is being used.                                           ..
T2. Page Margins                                                        .de fo                \"footer
                                                                        .ps 10                \"set footer⁄header size
As discussed in §3, header and footer macros are                        .ft R                 \"set font
usually deﬁned to describe the top and bottom page                      .vs 12p               \"set base-line spacing
margin areas respectively. A trap is planted at page                    .if \\n%=1 \{\
position 0 for the header, and at – N (N from the page                  ´sp  \\n(.pu– 0.5i– 1 \"tl base 0.5i up
bottom) for the footer. The simplest such deﬁnitions                    .tl ´´– % – ´´ \} \"ﬁrst page number
might be                                                                ´bp
   .de hd              \"deﬁne header                                   ..
   ´sp 1i                                                               .wh 0 hd
   ..                  \"end deﬁnition                                  .wh – 1i fo
   .de fo              \"deﬁne footer                                which sets the size, font, and base-line spacing for the
   ´bp                                                               header⁄footer material, and ultimately restores them.
   ..                  \"end deﬁnition                               The material in this case is a page number at the bot-
   .wh 0 hd                                                          tom of the ﬁrst page and at the top of the remaining
   .wh – 1i fo                                                       pages. If TROFF is used, a cut mark is drawn in the
which provide blank 1 inch top and bottom margins.                   form of root-en’s at each margin. The sp’s refer to
The header will occur on the ﬁrst page, only if the                  absolute positions to avoid dependence on the base-
deﬁnition and trap exist prior to the initial pseudo-                line spacing. Another reason for this in the footer is
page transition (§3). In ﬁll mode, the output line that              that the footer is invoked by printing a line whose
springs the footer trap was typically forced out                     vertical spacing swept past the trap position by possi-
__________________                                                   bly as much as the base-line spacing. The no-space
*For example: P. A. Crisman, Ed., The Compatible Time-Sharing        mode is turned on at the end of hd to render ineffec-
System, MIT Press, 1965, Section AH9.01 (Description of              tive accidental occurrences of sp at the top of the run-
RUNOFF program on MIT’s CTSS system).                                ning text.


                                                            - 26 -
NROFF/TROFF User’s Manual
October 11, 1976


The above method of restoring size, font, etc. presup-       A macro to automatically number section headings
poses that such requests (that set previous value) are       might look like:
not used in the running text. A better scheme is save            .de sc              \"section
and restore both the current and previous values as              . ---               \"force font, etc.
shown for size in the following:                                 .sp 0.4             \"prespace
   .de fo                                                        .ne 2.4+\\n(.Vu   \"want 2.4+ lines
   .nr s1 \\n(.s      \"current size                             .fi
   .ps                                                           \\n+S.
   .nr s2 \\n(.s      \"previous size                            ..
   . ---              \"rest of footer                           .nr S 0 1          \"init S
   ..                                                        The usage is .sc, followed by the section heading text,
   .de hd                                                    followed by .pg. The ne test value includes one line
   . ---              \"header stuff                         of heading, 0.4 line in the following pg, and one line
   .ps \\n(s2         \"restore previous size                of the paragraph text. A word consisting of the next
   .ps \\n(s1         \"restore current size                 section number and a period is produced to begin the
   ..                                                        heading line. The format of the number may be set
Page numbers may be printed in the bottom margin             by af (§8).
by a separate macro triggered during the footer’s page       Another common form is the labeled, indented para-
ejection:                                                    graph, where the label protrudes left into the indent
   .de bn           \"bottom number                          space.
   .tl ´´– % – ´´   \"centered page number                       .de lp             \"labeled paragraph
   ..                                                            .pg
   .wh – 0.5i– 1v bn \"tl base 0.5i up                           .in 0.5i           \"paragraph indent
T3. Paragraphs and Headings                                      .ta 0.2i 0.5i      \"label, paragraph
                                                                 .ti 0
The housekeeping associated with starting a new                  \t\\$1\t\c         \"ﬂow into paragraph
paragraph should be collected in a paragraph macro               ..
that, for example, does the desired preparagraph spac-
ing, forces the correct font, size, base-line spacing,       The intended usage is ".lp label "; label will begin at
and indent, checks that enough space remains for             0.2 inch, and cannot exceed a length of 0.3 inch
more than one line, and requests a temporary indent.         without intruding into the paragraph. The label could
                                                             be right adjusted against 0.4 inch by setting the tabs
   .de pg             \"paragraph                            instead with .ta 0.4iR 0.5i. The last line of lp ends
   .br                \"break                                with \c so that it will become a part of the ﬁrst line
   .ft R              \"force font,                          of the text that follows.
   .ps 10             \"size,
   .vs 12p            \"spacing,                             T4. Multiple Column Output
   .in 0              \"and indent                           The production of multiple column pages requires the
   .sp 0.4            \"prespace                             footer macro to decide whether it was invoked by
   .ne 1+\\n(.Vu      \"want more than 1 line                other than the last column, so that it will begin a new
   .ti 0.2i           \"temp indent                          column rather than produce the bottom margin. The
   ..                                                        header can initialize a column register that the footer
The ﬁrst break in pg will force out any previous par-        will increment and test. The following is arranged
tial lines, and must occur before the vs. The forcing        for two columns, but is easily modiﬁed for more.
of font, etc. is partly a defense against prior error and        .de hd            \"header
partly to permit things like section heading macros to           . ---
set parameters only once. The prespacing parameter               .nr cl 0 1        \"init column count
is suitable for TROFF; a larger space, at least as big           .mk               \"mark top of text
as the output device vertical resolution, would be               ..
more suitable in NROFF. The choice of remaining                  .de fo            \"footer
space to test for in the ne is the smallest amount               .ie \\n+(cl<2 \{\
greater than one line (the .V is the available vertical          .po +3.4i         \"next column; 3.1+0.3
resolution).                                                     .rt               \"back to mark


                                                        - 27 -
NROFF/TROFF User’s Manual
October 11, 1976


   .ns \}                \"no-space mode                          .fi                \"fill mode
   .el \{\                                                        ..
   .po \\nMu             \"restore left margin                    .de ef              \"end footnote
   . ---                                                          .br                 \"ﬁnish output
   ´bp \}                                                         .nr z \\n(.v        \"save spacing
   ..                                                             .ev                 \"pop ev
   .ll 3.1i              \"column width                           .di                 \"end diversion
   .nr M \\n(.o          \"save left margin                       .nr y – \\n(dn      \"new footer position,
Typically a portion of the top of the ﬁrst page con-              .if \\nx=1 .nr y  – (\\n(.v– \\nz) \
tains full width text; the request for the narrower line                              \"uncertainty correction
length, as well as another .mk would be made where                .ch fo \\nyu        \"y is negative
the two column output was to begin.                               .if ( \\n(nl+1v)>( \\n(.p+\\ny) \
                                                                  .ch fo \\n(nlu+1v \"it didn’t ﬁt
T5. Footnote Processing                                           ..
The footnote mechanism to be described is used by                 .de fs              \"separator
imbedding the footnotes in the input text at the point            \l´ 1i´             \"1 inch rule
of reference, demarcated by an initial .fn and a termi-           .br
nal .ef:                                                          ..
                                                                  .de fz              \"get leftover footnote
   .fn                                                            .fn
   Footnote text and control lines...                             .nf                 \"retain vertical size
   .ef                                                            .fy                 \"where fx put it
In the following, footnotes are processed in a separate           .ef
environment and diverted for later printing in the                ..
space immediately prior to the bottom margin. There               .nr b 1.0i          \"bottom margin size
is provision for the case where the last collected foot-          .wh 0 hd            \"header trap
note doesn’t completely ﬁt in the available space.                .wh 12i fo          \"footer trap, temp position
   .de hd                \"header                                 .wh – \\nbu fx \"fx at footer position
   . ---                                                          .ch fo – \\nbu      \"conceal fx with fo
   .nr x 0 1             \"init footnote count                The header hd initializes a footnote count register x,
   .nr y 0– \\nb         \"current footer place               and sets both the current footer trap position register
   .ch fo – \\nbu        \"reset footer trap                  y and the footer trap itself to a nominal position
   .if \\n(dn .fz        \"leftover footnote                  speciﬁed in register b. In addition, if the register dn
   ..                                                         indicates a leftover footnote, fz is invoked to repro-
   .de fo                \"footer                             cess it. The footnote start macro fn begins a diver-
   .nr dn 0              \"zero last diversion size           sion (append) in environment 1, and increments the
   .if \\nx \{\                                               count x; if the count is one, the footnote separator fs
   .ev 1                 \"expand footnotes in ev1            is interpolated. The separator is kept in a separate
   .nf                   \"retain vertical size               macro to permit user redeﬁnition. The footnote end
   .FN                   \"footnotes                          macro ef restores the previous environment and ends
   .rm FN                \"delete it                          the diversion after saving the spacing size in register
   .if "\\n(.z"fy" .di    \"end overﬂow diversion             z. y is then decremented by the size of the footnote,
   .nr x 0               \"disable fx                         available in dn; then on the ﬁrst footnote, y is further
   .ev \}                \"pop environment                    decremented by the difference in vertical base-line
   . ---                                                      spacings of the two environments, to prevent the late
   ´bp                                                        triggering the footer trap from causing the last line of
   ..                                                         the combined footnotes to overﬂow. The footer trap
   .de fx                \"process footnote overﬂow           is then set to the lower (on the page) of y or the
   .if \\nx .di fy       \"divert overﬂow                     current page position (nl) plus one line, to allow for
   ..                                                         printing the reference line. If indicated by x, the
   .de fn                \"start footnote                     footer fo rereads the footnotes from FN in noﬁll
   .da FN                \"divert (append) footnote           mode in environment 1, and deletes FN. If the foot-
   .ev 1                 \"in environment 1                   notes were too large to ﬁt, the macro fx will be trap-
   .if \\n+x=1 .fs        \"if ﬁrst, include separator        invoked to redivert the overﬂow into fy, and the


                                                         - 28 -
NROFF/TROFF User’s Manual
October 11, 1976


register dn will later indicate to the header whether fy
is empty. Both fo and fx are planted in the nominal
footer trap position in an order that causes fx to be
concealed unless the fo trap is moved. The footer
then terminates the overﬂow diversion, if necessary,
and zeros x to disable fx, because the uncertainty
correction together with a not-too-late triggering of
the footer can result in the footnote rereading ﬁnish-
ing before reaching the fx trap.
A good exercise for the student is to combine the
multiple-column and footnote mechanisms.
T6. The Last Page
After the last input ﬁle has ended, NROFF and TROFF
invoke the end macro (§7), if any, and when it
ﬁnishes, eject the remainder of the page. During the
eject, any traps encountered are processed normally.
At the end of this last page, processing terminates
unless a partial line, word, or partial word remains.
If it is desired that another page be started, the end-
macro
   .de en            \"end-macro
   \c
   ´bp
   ..
   .em en
will deposit a null partial word, and effect another
last page.




                                                       - 29 -
NROFF/TROFF User’s Manual
October 11, 1976


                                                    Table I

                                           Font Style Examples



The following fonts are printed in 12-point, with a vertical spacing of 14-point, and with non-alphanumeric char-
acters separated by 1⁄4 em space. The Special Mathematical Font was specially prepared for Bell Laboratories by
Graphic Systems, Inc. of Hudson, New Hampshire. The Times Roman, Italic, and Bold are among the many
standard fonts available from that company.




Times Roman
abcdefghijklmnopqrstuvwxyz
ABCDEFGHIJKLMNOPQRSTUVWXYZ
1234567890
!$%&()‘’*+– .,/:;=?[]
• — - _ 1⁄4 1⁄2 3⁄4 ﬁ ﬂ ff ffi ffl ˚ † ′ ¢ ® ©

Times Italic
abcdefghijklmnopqrstuvwxyz
ABCDEFGHIJKLMNOPQRSTUVWXYZ
1234567890
!$%&()‘’*+– .,/:;=?[]
• — - _ 1⁄4 1⁄2 3⁄4 ﬁ ﬂ ff ffi ffl ˚ † ′ ¢ ® ©

Times Bold
abcdefghijklmnopqrstuvwxyz
ABCDEFGHIJKLMNOPQRSTUVWXYZ
1234567890
!$%&()‘’*+– .,/:;=?[]
• — - _ 1⁄4 1⁄2 3⁄4 ﬁ ﬂ ff ffi ffl ˚ † ′ ¢ ® ©

Special Mathematical Font
"´\ˆ_`˜⁄<>{}#@+−=∗
αβγδεζηθικλµνξοπρσςτυφχψω
Γ∆ΘΛΞΠΣΥΦΨΩ
√≥≤≡∼−≠→←↑↓×÷±∪∩⊂⊃⊆⊇∞∂
        ∼
§∇¬∫ ∝∅∈‡      |   




                                                     - 30 -
NROFF/TROFF User’s Manual
October 11, 1976


                                                     Table II

                                   Input Naming Conventions for ´, `,and –
                                    and for Non-ASCII Special Characters



Non-ASCII characters and m in us on the standard fonts.
                         mi nu s

           I np ut
           In pu t   C ha ra ct er
                     Ch ar ac te r                               I np ut
                                                                 In pu t   C ha ra ct er
                                                                           Ch ar ac te r
  C ha r
  Ch ar    N am e
           Na me     N am e
                     Na me                              C ha r
                                                        Ch ar    N am e
                                                                 Na me     N am e
                                                                           Na me
    ’      ´         close quote                          ﬁ      \(ﬁ       ﬁ
    ‘      `         open quote                           ﬂ      \(ﬂ       ﬂ
   —       \(em      3⁄4 Em dash                          ff     \(ff      ff
    -      –         hyphen or                           ffi     \(Fi      fﬁ
    -      \(hy      hyphen                              ffl     \(Fl      fﬂ
    –      \–        current font minus                   ˚      \(de      degree
    •      \(bu      bullet                               †      \(dg      dagger
           \(sq      square                                ′     \(fm      foot mark
    _      \(ru      rule                                 ¢      \(ct      cent sign
    1
      ⁄4   \(14      1⁄4                                 ®       \(rg      registered
    1
      ⁄2   \(12      1⁄2                                 ©       \(co      copyright
    3
      ⁄4   \(34      3⁄4


Non-ASCII characters and ´, `, _ , +, −, =, and ∗ on the special font.
The ASCII characters @, #, ", ´, `, <, >, \, {, }, ˜, ˆ, and _ exist only on the special font and are printed as a 1-
em space if that font is not mounted. The following characters exist only on the special font except for the upper
case Greek letter names followed by † which are mapped into upper case English letters in whatever font is
mounted on font position one (default Times Roman). The special math plus, minus, and equals are provided to
insulate the appearance of equations from the choice of standard fonts.

           I np ut
           In pu t   C ha ra ct er
                     Ch ar ac te r                               I np ut
                                                                 In pu t   C ha ra ct er
                                                                           Ch ar ac te r
 C ha r
 Ch ar     N am e
           Na me     N am e
                     Na me                             C ha r
                                                       Ch ar     N am e
                                                                 Na me     N am e
                                                                           Na me
   +       \(pl      math plus                           λ       \(*l      lambda
   −       \(mi      math minus                          µ       \(*m      mu
   =       \(eq      math equals                         ν       \(*n      nu
   ∗       \(**      math star                           ξ       \(*c      xi
   §       \(sc      section                             ο       \(*o      omicron
   ´       \(aa      acute accent                        π       \(*p      pi
   `       \(ga      grave accent                        ρ       \(*r      rho
   _       \(ul      underrule                           σ       \(*s      sigma
    ⁄      \(sl      slash (matching backslash)          ς       \(ts      terminal sigma
   α       \(*a      alpha                               τ       \(*t      tau
   β       \(*b      beta                                υ       \(*u      upsilon
   γ       \(*g      gamma                               φ       \(*f      phi
   δ       \(*d      delta                               χ       \(*x      chi
   ε       \(*e      epsilon                             ψ       \(*q      psi
   ζ       \(*z      zeta                                ω       \(*w      omega
   η       \(*y      eta                                 Α       \(*A      Alpha†
   θ       \(*h      theta                               Β       \(*B      Beta†
   ι       \(*i      iota                                Γ       \(*G      Gamma
   κ       \(*k      kappa                               ∆       \(*D      Delta



                                                       - 31 -
NROFF/TROFF User’s Manual
October 11, 1976


          I np ut
          In pu t   C ha ra ct er
                    Ch ar ac te r               I np ut
                                                In pu t   C ha ra ct er
                                                          Ch ar ac te r
 Ch ar
 C ha r   N am e
          Na me     Na me
                    N am e               C ha r N am e
                                         Ch ar Na me      N am e
                                                          Na me
   Ε      \(*E      Epsilon†                    \(rh      right hand
   Ζ      \(*Z      Zeta†                       \(lh      left hand
   Η      \(*Y      Eta†                        \(bs      Bell System logo
   Θ      \(*H      Theta                   |   \(or      or
   Ι      \(*I      Iota†                       \(ci      circle
   Κ      \(*K      Kappa†                     \(lt      left top of big curly bracket
   Λ      \(*L      Lambda                     \(lb      left bottom
  Μ       \(*M      Mu†                        \(rt      right top
   Ν      \(*N      Nu†                        \(rb      right bot
   Ξ      \(*C      Xi                         \(lk      left center of big curly bracket
   Ο      \(*O      Omicron†                   \(rk      right center of big curly bracket
  Π       \(*P      Pi                         \(bv      bold vertical
   Ρ      \(*R      Rho†                       \(lf      left floor (left bottom of big
   Σ      \(*S      Sigma                                 square bracket)
   Τ      \(*T      Tau†                         \(rf    right floor (right bottom)
   Υ      \(*U      Upsilon                      \(lc    left ceiling (left top)
  Φ       \(*F      Phi                          \(rc    right ceiling (right top)
   Χ      \(*X      Chi†
  Ψ       \(*Q      Psi
  Ω       \(*W      Omega
   √      \(sr      square root
         \(rn      root en extender
   ≥      \(>=      >=
   ≤      \(<=      <=
   ≡      \(==      identically equal
   ∼
   −      \(˜=      approx =
   ∼      \(ap      approximates
   ≠      \(!=      not equal
  →       \(−>      right arrow
  ←       \(<−      left arrow
   ↑      \(ua      up arrow
   ↓      \(da      down arrow
   ×      \(mu      multiply
   ÷      \(di      divide
   ±      \(+−      plus-minus
  ∪       \(cu      cup (union)
  ∩       \(ca      cap (intersection)
   ⊂      \(sb      subset of
   ⊃      \(sp      superset of
   ⊆      \(ib      improper subset
   ⊇      \(ip      improper superset
   ∞      \(if      infinity
   ∂      \(pd      partial derivative
   ∇      \(gr      gradient
   ¬      \(no      not
   ∫      \(is      integral sign
   ∝      \(pt      proportional to
  ∅       \(es      empty set
   ∈      \(mo      member of
         \(br      box vertical rule
   ‡      \(dd      double dagger




                                         - 32 -
May 15, 1977



                    Summary of Changes to N/TROFF Since October 1976 Manual

Options

-h             (Nroff only) Output tabs used during horizontal spacing to speed output as well as reduce out-
               put byte count. Device tab settings assumed to be every 8 nominal character widths. The
               default settings of input (logical) tabs is also initialized to every 8 nominal character widths.

-z             Efﬁciently suppresses formatted output. Only message output will occur (from "tm"s and diag-
               nostics).

Old Requests

.ad c          The adjustment type indicator "c" may now also be a number previously obtained from the ".j"
               register (see below).

.so name       The contents of ﬁle "name" will be interpolated at the point the "so" is encountered. Previ-
               ously, the interpolation was done upon return to the ﬁle-reading input level.

New Request

.ab text       Prints "text" on the message output and terminates without further processing. If "text" is miss-
               ing, "User Abort." is printed. Does not cause a break. The output buffer is ﬂushed.

.fz F N                _                   _e
               forces f ont "F" to be in siz N. N may have the form N, +N, or -N. For example,
                    .fz 3 -2
               will cause an implicit \s-2 every time font 3 is entered, and a corresponding \s+2 when it is left.
               Special font characters occurring during the reign of font F will have the same size
               modiﬁcation. If special characters are to be treated differently,
                    .fz S F N
               may be used to specify the size treatment of special characters during font F. For example,
                    .fz 3 -3
                    .fz S 3 -0
               will cause automatic reduction of font 3 by 3 points while the special characters would not be
               affected. Any ‘‘.fp’’ request specifying a font on some position must precede ‘‘.fz’’ requests
               relating to that position.

New Predeﬁned Number Registers.

.k             Read-only. Contains the horizontal size of the text portion (without indent) of the current par-
               tially collected output line, if any, in the current environment.

.j             Read-only. A number representing the current adjustment mode and type. Can be saved and
               later given to the "ad" request to restore a previous mode.

.P             Read-only. 1 if the current page is being printed, and zero otherwise.

.L             Read-only. Contains the current line-spacing parameter ("ls").

c.             General register access to the input line-number in the current input ﬁle. Contains the same
               value as the read-only ".c" register.
                                                A TROFF Tutorial

                                                  Brian W. Kernighan
                                                   Bell Laboratories
                                             Murray Hill, New Jersey 07974



                                                      ABSTRACT

                troff is a text-formatting program for driving the Graphic Systems photo-
          typesetter on the UNIX† and GCOS operating systems. This device is capable of pro-
          ducing high quality text; this paper is an example of troff output.
                 The phototypesetter itself normally runs with four fonts, containing roman, italic
          and bold letters (as on this page), a full greek alphabet, and a substantial number of
          special characters and mathematical symbols. Characters can be printed in a range of
          sizes, and placed anywhere on the page.
                troff allows the user full control over fonts, sizes, and character positions, as
          well as the usual features of a formatter — right-margin justiﬁcation, automatic hyphe-
          nation, page titling and numbering, and so on. It also provides macros, arithmetic vari-
          ables and operations, and conditional testing, for complicated formatting tasks.
                This document is an introduction to the most basic use of troff. It presents just
          enough information to enable the user to do simple formatting tasks like making view-
          graphs, and to make incremental changes to existing packages of troff commands. In
          most respects, the UNIX formatter nroff is identical to troff, so this document also
          serves as a tutorial on nroff.



August 4, 1978




_
______________
†UNIX is a Trademark of Bell Laboratories.
                                              A TROFF Tutorial

                                                Brian W. Kernighan
                                               Bell Laboratories
                                         Murray Hill, New Jersey 07974



1. Introduction                                             case, there is no attempt to be complete. Rather, the
       troff [1] is a text-formatting program, written      emphasis is on showing how to do simple things, and
by J. F. Ossanna, for producing high-quality printed        how to make incremental changes to what already
output from the phototypesetter on the UNIX and             exists. The contents of the remaining sections are:
GCOS operating systems. This document is an exam-
ple of troff output.                                          2.     Point sizes and line spacing
                                                              3.     Fonts and special characters
       The single most important rule of using troff is       4.     Indents and line length
not to use it directly, but through some intermediary.        5.     Tabs
In many ways, troff resembles an assembly language            6.     Local motions: Drawing lines and characters
— a remarkably powerful and ﬂexible one — but                 7.     Strings
nonetheless such that many operations must be                 8.     Introduction to macros
speciﬁed at a level of detail and in a form that is too       9.     Titles, pages and numbering
hard for most people to use effectively.                     10.     Number registers and arithmetic
      For two special applications, there are pro-           11.     Macros with arguments
grams that provide an interface to troff for the major-      12.     Conditionals
ity of users. eqn [2] provides an easy to learn              13.     Environments
language for typesetting mathematics; the eqn user           14.     Diversions
need know no troff whatsoever to typeset mathemat-                   Appendix: Typesetter character set
ics. tbl [3] provides the same convenience for pro-
ducing tables of arbitrary complexity.                      The troff described here is the C-language version
       For producing straight text (which may well          running on UNIX at Murray Hill, as documented in
contain mathematics or tables), there are a number of       [1].
‘macro packages’ that deﬁne formatting rules and
operations for speciﬁc styles of documents, and                     To use troff you have to prepare not only the
reduce the amount of direct contact with troff. In          actual text you want printed, but some information
particular, the ‘– ms’ [4] and PWB/MM [5] packages          that tells how you want it printed. (Readers who use
for Bell Labs internal memoranda and external papers        roff will ﬁnd the approach familiar.) For troff the
provide most of the facilities needed for a wide range      text and the formatting information are often
of document preparation. (This memo was prepared            intertwined quite intimately. Most commands to troff
with ‘– ms’.) There are also packages for viewgraphs,       are placed on a line separate from the text itself,
for simulating the older roff formatters on UNIX and        beginning with a period (one command per line). For
GCOS, and for other special applications. Typically         example,
you will ﬁnd these packages easier to use than troff
                                                                   Some text.
once you get beyond the most trivial operations; you
                                                                   .ps 14
should always consider them ﬁrst.
                                                                   Some more text.
       In the few cases where existing packages don’t
do the whole job, the solution is not to write an           will change the ‘point size’, that is, the size of the
entirely new set of troff instructions from scratch, but    letters being printed, to ‘14 point’ (one point is 1/72
to make small changes to adapt packages that already        inch) like this:
exist.                                                             Some text.   Some more text.
        In accordance with this philosophy of letting              Occasionally, though, something special occurs
someone else do the work, the part of troff described       in the middle of a line — to produce
here is only a small part of the whole, although it
tries to concentrate on the more useful parts. In any
                                                               -2-


                                                                            The other parameter that determines what the
        Area = πr 2
                                                                     type looks like is the spacing between lines, which is
you have to type                                                     set independently of the point size. Vertical spacing
                                                                     is measured from the bottom of one line to the bot-
        Area = \(∗p\fIr\fR\ \s8\u2\d\s0
                                                                     tom of the next. The command to control vertical
(which we will explain shortly). The backslash char-                 spacing is .vs For running text, it is usually best to
                                                                                 .vs.
acter \ is used to introduce troff commands and spe-                 set the vertical spacing about 20% bigger than the
cial characters within a line of text.                               character size. For example, so far in this document,
                                                                     we have used ‘‘9 on 11’’, that is,
2. Point Sizes; Line Spacing
                                                                             .ps 9
       As mentioned above, the command .ps sets the                          .vs 11p
point size. One point is 1/72 inch, so 6-point charac-
ters are at most 1/12 inch high, and 36-point charac-                If we changed to
ters are 1⁄2 inch. There are 15 point sizes, listed                          .ps 9
below.                                                                       .vs 9p
 6 point: Pack my box with ﬁve dozen liquor jugs.                    the running text would look like this. After a few
 7 point: Pack my box with ﬁve dozen liquor jugs.                    lines, you will agree it looks a little cramped. The
 8 point: Pack my box with ﬁve dozen liquor jugs.                    right vertical spacing is partly a matter of taste,
 9 point: Pack my box with ﬁve dozen liquor jugs.                    depending on how much text you want to squeeze
 10 point: Pack my box with ﬁve dozen liquor                         into a given space, and partly a matter of traditional
                                                                     printing style. By default, troff uses 10 on 12.
 11 point: Pack my box with ﬁve dozen
 12 point: Pack my box with ﬁve dozen                                     Point size and vertical spacing
 14 point: Pack my box with ﬁve                                      make a substantial difference in the
                                                                     amount of text per square inch. This is
 16 point 18 point                                  20 point         12 on 14.
                                                                              Point size and vertical spacing make a substantial difference in the
                                                                     amount of text per square inch. For example, 10 on 12 uses about twice as much


 22 24                   28              36                          space as 7 on 8. This is 6 on 7, which is even smaller. It packs a lot more
                                                                     words per line, but you can go blind trying to read it.

                                                                             When used without arguments, .ps and .vs
                                                                     revert to the previous size and vertical spacing respec-
        If the number after .ps is not one of these legal
sizes, it is rounded up to the next valid value, with a              tively.
maximum of 36. If no number follows .ps troff  .ps,
reverts to the previous size, whatever it was. troff                        The command .sp is used to get extra vertical
begins with point size 10, which is usually ﬁne. This                space. Unadorned, it gives you one extra blank line
document is in 9 point.                                              (one .vs whatever that has been set to). Typically,
                                                                           .vs,
       The point size can also be changed in the mid-                that’s more or less than you want, so .sp can be fol-
dle of a line or even a word with the in-line com-                   lowed by information about how much space you
mand \s To produce
      \s.                                                            want —

        UNIX     runs on a PDP-11/45                                         .sp 2i

type                                                                 means ‘two inches of vertical space’.

        \s8UNIX\s10 runs on a \s8PDP-\s1011/45                               .sp 2p

As above, \s should be followed by a legal point size,               means ‘two points of vertical space’; and
except that \s0 causes the size to revert to its previous                    .sp 2
value. Notice that \s1011 can be understood correctly
as ‘size 10, followed by an 11’, if the size is legal,               means ‘two vertical spaces’ — two of whatever .vs is
but not otherwise. Be cautious with similar construc-                set to (this can also be made explicit with .sp 2v
                                                                                                                     2v);
tions.                                                               troff also understands decimal fractions in most
                                                                     places, so
        Relative size changes are also legal and useful:
                                                                             .sp 1.5i
        \s– 2UNIX\s+2
                                                                     is a space of 1.5 inches. These same scale factors
temporarily decreases the size, whatever it is, by two
                                                                     can be used after .vs to deﬁne line spacing, and in
points, then restores it. Relative size changes have
                                                                     fact after most commands that deal with physical
the advantage that the size difference is independent
                                                                     dimensions.
of the starting size of the document. The amount of
the relative change is restricted to a single digit.
                                                           -3-


       It should be noted that all size numbers are
                                                                       .fp 3 H
converted internally to ‘machine units’, which are
1/432 inch (1/6 point). For most purposes, this is               says that the Helvetica font is mounted on position 3.
enough resolution that you don’t have to worry about             (For a complete list of fonts and what they look like,
the accuracy of the representation. The situation is             see the troff manual.) Appropriate .fp commands
not quite so good vertically, where resolution is 1/144          should appear at the beginning of your document if
inch (1/2 point).                                                you do not use the standard fonts.
                                                                        It is possible to make a document relatively
3. Fonts and Special Characters                                  independent of the actual fonts used to print it by
       troff and the typesetter allow four different             using font numbers instead of names; for example, \f3
fonts at any one time. Normally three fonts (Times               and .ft˜3 mean ‘whatever font is mounted at position
roman, italic and bold) and one collection of special            3’, and thus work for any setting. Normal settings
characters are permanently mounted.                              are roman font on 1, italic on 2, bold on 3, and spe-
                                                                 cial on 4.
  abcdefghijklmnopqrstuvwxyz 0123456789
  ABCDEFGHIJKLMNOPQRSTUVWXYZ                                             There is also a way to get ‘synthetic’ bold
  abcdefghijklmnopqrstuvwxyz 0123456789                          fonts by overstriking letters with a slight offset. Look
  ABCDEFGHIJKLMNOPQRSTUVWXYZ                                     at the .bd command in [1].
  abcdefghijklmnopqrstuvwxyz 0123456789
  ABCDEFGHIJKLMNOPQRSTUVWXYZ                                           Special characters have four-character names
The greek, mathematical symbols and miscellany of                beginning with \( and they may be inserted any-
                                                                                \(,
the special font are listed in Appendix A.                       where. For example,

      troff prints in roman unless told otherwise. To
                                                                       1
                                                                           ⁄4 + 1⁄2 = 3⁄4
switch into bold, use the .ft command                            is produced by
      .ft B                                                            \(14 + \(12 = \(34
and for italics,                                                 In particular, greek letters are all of the form \(∗– ,
      .ft I                                                      where – is an upper or lower case roman letter rem-
                                                                 iniscent of the greek. Thus to get
To return to roman, use .ft R to return to the previ-
                            R;
ous font, whatever it was, use either .ft P or just .ft
                                                    .ft.               Σ(α×β) → ∞
The ‘underline’ command                                          in bare troff we have to type
      .ul                                                              \(∗S(\(∗a\(mu\(∗b) \(−> \(if
causes the next input line to print in italics. .ul can          That line is unscrambled as follows:
be followed by a count to indicate that more than one
line is to be italicized.                                              \(∗S                 Σ
                                                                       (                    (
      Fonts can also be changed within a line or
                                                                       \(∗a                 α
word with the in-line command \f
                              \f:
                                                                       \(mu                 ×
      boldface text                                                    \(∗b                 β
                                                                       )                    )
is produced by
                                                                       \(−>                 →
      \fBbold\fIface\fR text                                           \(if                 ∞
If you want to do this so the previous font, whatever            A complete list of these special names occurs in
it was, is left undisturbed, insert extra \fP commands,          Appendix A.
like this:                                                              In eqn [2] the same effect can be achieved
      \fBbold\fP\fIface\fP\fR text\fP                            with the input

Because only the immediately previous font is                          SIGMA ( alpha times beta ) – > inf
remembered, you have to restore the previous font                which is less concise, but clearer to the uninitiated.
after each change or you can lose it. The same is
true of .ps and .vs when used without an argument.                       Notice that each four-character name is a sin-
                                                                 gle character as far as troff is concerned — the
       There are other fonts available besides the               ‘translate’ command
standard set, although you can still use only four at
any given time. The command .fp tells troff what                       .tr \(mi\(em
fonts are physically mounted on the typesetter:                  is perfectly clear, meaning
                                                             -4-



      .tr −—                                                             .ti 3
that is, to translate − into —.                                    Three of what? The default unit for .ti as for most
                                                                                                              .ti,
       Some characters are automatically translated                horizontally oriented commands (.ll .in .po is ems;
                                                                                                       .ll, .in, .po),
into others: grave ` and acute ´ accents (apos-                    an em is roughly the width of the letter ‘m’ in the
trophes) become open and close single quotes ‘˜’; the              current point size. (Precisely, a em in size p is p
combination of ‘‘...’’ is generally preferable to the              points.) Although inches are usually clearer than ems
double quotes "...". Similarly a typed minus sign                  to people who don’t set type for a living, ems have a
becomes a hyphen -. To print an explicit – sign, use               place: they are a measure of size that is proportional
\- To get a backslash printed, use \e
\-.                                \e.                             to the current point size. If you want to make text
                                                                   that keeps its proportions regardless of point size, you
4. Indents and Line Lengths                                        should use ems for all dimensions. Ems can be
                                                                   speciﬁed as scale factors directly, as in .ti 2.5m
                                                                                                                   2.5m.
        troff starts with a line length of 6.5 inches, too
wide for 81⁄2 ×11 paper. To reset the line length, use                    Lines can also be indented negatively if the
the .ll command, as in                                             indent is already positive:

      .ll 6i                                                             .ti −0.3i

As with .sp the actual length can be speciﬁed in
         .sp,                                                      causes the next line to be moved back three tenths of
several ways; inches are probably the most intuitive.              an inch. Thus to make a decorative initial capital, we
                                                                   indent the whole paragraph, then move the letter ‘P’
       The maximum line length provided by the                     back with a .ti command:
typesetter is 7.5 inches, by the way. To use the full
width, you will have to reset the default physical left                        ater noster qui est in caelis
margin (‘‘page offset’’), which is normally slightly
less than one inch from the left edge of the paper.
This is done by the .po command.
                                                                         P     sanctiﬁcetur nomen tuum; adveniat
                                                                               regnum tuum; ﬁat voluntas tua, sicut
                                                                         in caelo, et in terra. ... Amen.

      .po 0                                                        Of course, there is also some trickery to make the ‘P’
                                                                   bigger (just a ‘\s36P\s0’), and to move it down from
sets the offset as far to the left as it will go.                  its normal position (see the section on local motions).

       The indent command .in causes the left margin               5. Tabs
to be indented by some speciﬁed amount from the                           Tabs (the ASCII ‘horizontal tab’ character) can
page offset. If we use .in to move the left margin in,             be used to produce output in columns, or to set the
and .ll to move the right margin to the left, we can               horizontal position of output. Typically tabs are used
make offset blocks of text:                                        only in unﬁlled text. Tab stops are set by default
      .in 0.3i                                                     every half inch from the current indent, but can be
      .ll −0.3i                                                    changed by the .ta command. To set stops every
      text to be set into a block                                  inch, for example,
      .ll +0.3i                                                          .ta 1i 2i 3i 4i 5i 6i
      .in −0.3i
will create a block that looks like this:                                 Unfortunately the stops are left-justiﬁed only
                                                                   (as on a typewriter), so lining up columns of right-
      Pater noster qui est in caelis sanctiﬁcetur                  justiﬁed numbers can be painful. If you have many
      nomen tuum; adveniat regnum tuum; ﬁat                        numbers, or if you need more complicated table lay-
      voluntas tua, sicut in caelo, et in terra. ...               out, don’t use troff directly; use the tbl program
      Amen.                                                        described in [3].
Notice the use of ‘+’ and ‘−’ to specify the amount of                     For a handful of numeric columns, you can do
change. These change the previous setting by the                   it this way: Precede every number by enough blanks
speciﬁed amount, rather than just overriding it. The               to make it line up when typed.
distinction is quite important: .ll +1i makes lines one
                                                                         .nf
inch longer; .ll 1i makes them one inch long.
                                                                         .ta 1i 2i 3i
       With .in .ll and .po the previous value is used
            .in,        .po,                                                1 tab     2 tab 3
if no argument is speciﬁed.                                                40 tab 50 tab 60
       To indent a single line, use the ‘temporary                       700 tab 800 tab 900
indent’ command .ti For example, all paragraphs in
                  .ti.                                                   .ﬁ
this memo effectively begin with the command                       Then change each leading blank into the string \0      \0.
                                                                   This is a character that does not print, but that has the
                                                             -5-


same width as a digit. When printed, this will pro-
                                                                     .in +0.6i           (move paragraph in)
duce
                                                                     .ll – 0.3i          (shorten lines)
        1                    2                   3                   .ti – 0.3i          (move P back)
       40                   50                  60                   \v´2´\s36P\s0\v´– 2´ater noster qui est
      700                  800                 900                   in caelis ...

       It is also possible to ﬁll up tabbed-over space             A minus sign causes upward motion, while no sign or
with some character other than blanks by setting the               a plus sign means down the page. Thus \v′– 2′ causes
‘tab replacement character’ with the .tc command:                  an upward vertical motion of two line spaces.
                                                                        There are many other ways to specify the
      .ta 1.5i 2.5i
                                                                   amount of motion —
      .tc \(ru      (\(ru is "_")
      Name tab Age tab                                                   \v´0.1i´
                                                                         \v´3p´
produces
                                                                         \v´– 0.5m´
   Name ___________________ Age ___________
                                                                   and so on are all legal. Notice that the scale speciﬁer
To reset the tab replacement character to a blank, use             i or p or m goes inside the quotes. Any character can
.tc with no argument. (Lines can also be drawn with                be used in place of the quotes; this is also true of all
the \l command, described in Section 6.)                           other troff commands described in this section.
       troff also provides a very general mechanism                        Since troff does not take within-the-line verti-
called ‘ﬁelds’ for setting up complicated columns.                 cal motions into account when ﬁguring out where it is
(This is used by tbl). We will not go into it in this              on the page, output lines can have unexpected posi-
paper.                                                             tions if the left and right ends aren’t at the same vert-
                                                                   ical position. Thus \v like \u and \d should always
                                                                                          \v,             \d,
6. Local Motions: Drawing lines and characters                     balance upward vertical motion in a line with the
     Remember ‘Area = πr2’ and the big ‘P’ in the                  same amount in the downward direction.
Paternoster. How are they done? troff provides a                          Arbitrary horizontal motions are also available
host of commands for placing characters of any size                — \h is quite analogous to \v except that the default
                                                                                               \v,
at any place. You can use them to draw special char-               scale factor is ems instead of line spaces. As an
acters or to tune your output for a particular appear-             example,
ance. Most of these commands are straightforward,
                                                                         \h´– 0.1i´
but messy to read and tough to type correctly.
        If you won’t use eqn, subscripts and super-                causes a backwards motion of a tenth of an inch. As
scripts are most easily done with the half-line local              a practical matter, consider printing the mathematical
motions \u and \d To go back up the page half a
                  \d.                                              symbol ‘>>’. The default spacing is too wide, so eqn
point-size, insert a \u at the desired place; to go                replaces this by
down, insert a \d (\u and \d should always be used in
                \d. \u                                                   >\h´– 0.3m´>
pairs, as explained below.) Thus
                                                                   to produce >
                                                                              >.
      Area = \(∗pr\u2\d
                                                                          Frequently \h is used with the ‘width function’
produces                                                           \w to generate motions equal to the width of some
                                                                   character string. The construction
      Area = πr2
                                                                         \w´thing´
                                                  2...\s0.
To make the ‘2’ smaller, bracket it with \s– 2...\s0
Since \u and \d refer to the current point size, be sure           is a number equal to the width of ‘thing’ in machine
to put them either both inside or both outside the size            units (1/432 inch). All troff computations are ulti-
changes, or you will get an unbalanced vertical                    mately done in these units. To move horizontally the
motion.                                                            width of an ‘x’, we can say
        Sometimes the space given by \u and \d isn’t                     \h´\w´x´u´
the right amount. The \v command can be used to
request an arbitrary amount of vertical motion. The                As we mentioned above, the default scale factor for
in-line command                                                    all horizontal dimensions is m ems, so here we must
                                                                                                m,
                                                                   have the u for machine units, or the motion produced
      \v´(amount)´                                                 will be far too large. troff is quite happy with the
causes motion up or down the page by the amount                    nested quotes, by the way, so long as you don’t leave
speciﬁed in ‘(amount)’. For example, to move the ‘P’               any out.
down, we used                                                             As a live example of this kind of construction,
                                                                   all of the command names in the text, like .sp were
                                                                                                               .sp,
                                                           -6-


done by overstriking with a slight offset. The com-
                                                                        \s+6\z,\v´−0.25m´.\v´0.25m´\s0
mands for .sp are
                                                                 ‘0.25m’ is an empirical constant.
      .sp\h´– \w´.sp´u´\h´1u´.sp
                                                                         A more ornate overstrike is given by the brack-
That is, put out ‘.sp’, move left by the width of ‘.sp’,         eting function \b which piles up characters vertically,
                                                                                \b,
move right 1 unit, and print ‘.sp’ again. (Of course             centered on the current baseline. Thus we can get big
there is a way to avoid typing that much input for               brackets, constructing them with piled-up smaller
each command name, which we will discuss in Sec-                 pieces:
tion 11.)
                                                                         
                                                                         x
        There are also several special-purpose troff                        
commands for local motion. We have already seen
\0 which is an unpaddable white space of the same
\0,                                                              by typing in only this:
width as a digit. ‘Unpaddable’ means that it will
                                                                 .sp
never be widened or split across a line by line
                                                                 \b′\(lt\(lk\(lb′ \b′\(lc\(lf′ x \b′\(rc\(rf′ \b′\(rt\(rk\(rb′
justiﬁcation and ﬁlling. There is also \
                                       \(blank), which
is an unpaddable character the width of a space, \ ,                   troff also provides a convenient facility for
which is half that width, \ˆ which is one quarter of
                          \ˆ,                                    drawing horizontal and vertical lines of arbitrary
the width of a space, and \& which has zero width.
                           \&,                                   length with arbitrary characters. \l′1i′ draws a line
(This last one is useful, for example, in entering a             one inch long, like this: ________________ . The
text line which would otherwise begin with a ‘.’.)               length can be followed by the character to use if the _
      The command \o used like
                  \o,                                            isn’t appropriate; \l′0.5i.′ draws a half-inch line of
                                                                 dots: ................ The construction \L is entirely
      \o´set of characters´
                                                                 analogous, except that it draws a vertical line instead
causes (up to 9) characters to be overstruck, centered           of horizontal.
on the widest. This is nice for accents, as in
                                                                 7. Strings
  syst\o"e\(ga"me t\o"e\(aa"l\o"e\(aa"phonique
                                                                        Obviously if a paper contains a large number
which makes                                                      of occurrences of an acute accent over a letter ‘e’,
      systeme telephonique
          `    ´´                                                typing \o"e\´" for each e would be a great nuisance.
                                                                                         ´

The accents are \(ga and \(aa or \` and \´ remember
                           \(aa,          \´;                           Fortunately, troff provides a way in which you
that each is just one character to troff.                        can store an arbitrary collection of text in a ‘string’,
                                                                 and thereafter use the string name as a shorthand for
       You can make your own overstrikes with                    its contents. Strings are one of several troff mechan-
another special convention, \z the zero-motion com-
                             \z,                                 isms whose judicious use lets you type a document
mand. \zx suppresses the normal horizontal motion                with less effort and organize it so that extensive for-
after printing the single character x so another char-
                                    x,                           mat changes can be made with few editing changes.
acter can be laid on top of it. Although sizes can be
changed within \o it centers the characters on the
                  \o,                                                   A reference to a string is replaced by whatever
widest, and there can be no horizontal or vertical               text the string was deﬁned as. Strings are deﬁned
motions, so \z may be the only way to get what you               with the command .ds The line
                                                                                    .ds.
want:                                                                   .ds e \o"e\´"
                                                                 deﬁnes the string e to have the value \o"e\´"
                                                                        String names may be either one or two charac-
                                                                 ters long, and are referred to by \∗x for one character
is produced by                                                   names or \∗(xy for two character names. Thus to get
                                                                 telephone, given the deﬁnition of the string e as
                                                                  ´´
      .sp 2
                                                                 above, we can say t\∗el\∗ephone.
      \s8\z\(sq\s14\z\(sq\s22\z\(sq\s36\(sq
                                                                         If a string must begin with blanks, deﬁne it as
The .sp is needed to leave room for the result.
                                                                        .ds xx "        text
       As another example, an extra-heavy semicolon
that looks like                                                  The double quote signals the beginning of the
      .
      ,   instead of ; or     ;                                  deﬁnition. There is no trailing quote; the end of the
                                                                 line terminates the string.
can be constructed with a big comma and a big                          A string may actually be several lines long; if
period above it:                                                 troff encounters a \ at the end of any line, it is
                                                                 thrown away and the next line added to the current
                                                           -7-


one. So you can make a long string simply by end-
                                                                        .de PP          \" paragraph macro
ing each line but the last with a backslash:
                                                                        .sp 2p
      .ds xx this \                                                     .ti +3m
      is a very \                                                       .ft R
      long string                                                       ..

       Strings may be deﬁned in terms of other                   and the change takes effect everywhere we used .PP
                                                                                                                .PP.
strings, or even in terms of themselves; we will dis-                   \" is a troff command that causes the rest of
cuss some of these possibilities later.                          the line to be ignored. We use it here to add com-
                                                                 ments to the macro deﬁnition (a wise idea once
8. Introduction to Macros                                        deﬁnitions get complicated).
       Before we can go much further in troff, we                        As another example of macros, consider these
need to learn a bit about the macro facility. In its             two which start and end a block of offset, unﬁlled
simplest form, a macro is just a shorthand notation              text, like most of the examples in this paper:
quite similar to a string. Suppose we want every
                                                                        .de BS          \" start indented block
paragraph to start in exactly the same way — with a
                                                                        .sp
space and a temporary indent of two ems:
                                                                        .nf
      .sp                                                               .in +0.3i
      .ti +2m                                                           ..
                                                                        .de BE          \" end indented block
Then to save typing, we would like to collapse these
                                                                        .sp
into one shorthand line, a troff ‘command’ like
                                                                        .ﬁ
      .PP                                                               .in −0.3i
                                                                        ..
that would be treated by troff exactly as
                                                                 Now we can surround text like
      .sp
      .ti +2m                                                           Copy to
                                                                        John Doe
.PP is called a macro. The way we tell troff what
                                                                        Richard Roberts
.PP means is to deﬁne it with the .de command:
                                                                        Stanley Smith
      .de PP
                                                                 by the commands .BS and .BE and it will come out
                                                                                            .BE,
      .sp
                                                                 as it did above. Notice that we indented by .in +0.3i
      .ti +2m
                                                                 instead of .in 0.3i This way we can nest our uses of
                                                                                0.3i.
      ..
                                                                 .BS and BE to get blocks within blocks.
The ﬁrst line names the macro (we used ‘.PP for
                                            .PP’                        If later on we decide that the indent should be
‘paragraph’, and upper case so it wouldn’t conﬂict               0.5i, then it is only necessary to change the
with any name that troff might already know about).              deﬁnitions of .BS and .BE not the whole paper.
                                                                                        .BE,
The last line .. marks the end of the deﬁnition. In
between is the text, which is simply inserted when-              9. Titles, Pages and Numbering
ever troff sees the ‘command’ or macro call
                                                                        This is an area where things get tougher,
      .PP                                                        because nothing is done for you automatically. Of
A macro can contain any mixture of text and format-              necessity, some of this section is a cookbook, to be
ting commands.                                                   copied literally until you get some experience.

        The deﬁnition of .PP has to precede its ﬁrst                    Suppose you want a title at the top of each
use; undeﬁned macros are simply ignored. Names are               page, saying just
restricted to one or two characters.                             ˜˜˜˜left top             center top            right top˜˜˜˜
       Using macros for commonly occurring                       In roff, one can say
sequences of commands is critically important. Not                 .he ´left top´center top´right top´
only does it save typing, but it makes later changes               .fo ´left bottom´center bottom´right bottom´
much easier. Suppose we decide that the paragraph
indent is too small, the vertical space is much too big,         to get headers and footers automatically on every
and roman font should be forced. Instead of chang-               page. Alas, this doesn’t work in troff, a serious hard-
ing the whole document, we need only change the                  ship for the novice. Instead you have to do a lot of
deﬁnition of .PP to something like                               speciﬁcation.
                                                                       You have to say what the actual title is (easy);
                                                                 when to print it (easy enough); and what to do at and
                                                            -8-


around the title line (harder). Taking these in reverse           the output line currently being ﬁlled should not be
order, ﬁrst we deﬁne a macro .NP (for ‘new page’) to              forced out before the space or new page.
process titles and the like at the end of one page and                   The list of commands that cause a break is
the beginning of the next:                                        short and natural:
      .de NP                                                            .bp   .br   .ce   .ﬁ   .nf   .sp   .in   .ti
      ′bp
      ′sp 0.5i                                                    All others cause no break, regardless of whether you
      .tl ´left top´center top´right top´                         use a . or a ′ If you really need a break, add a .br
                                                                               ′.
      ′sp 0.3i                                                    command at the appropriate place.
      ..                                                                  One other thing to beware of — if you’re
To make sure we’re at the top of a page, we issue a               changing fonts or point sizes a lot, you may ﬁnd that
‘begin page’ command ′bp which causes a skip to
                         ′bp,                                     if you cross a page boundary in an unexpected font or
top-of-page (we’ll explain the ′ shortly). Then we                size, your titles come out in that size and font instead
space down half an inch, print the title (the use of .tl          of what you intended. Furthermore, the length of a
should be self explanatory; later we will discuss                 title is independent of the current line length, so titles
parameterizing the titles), space another 0.3 inches,             will come out at the default length of 6.5 inches
and we’re done.                                                   unless you change it, which is done with the .lt com-
                                                                  mand.
       To ask for .NP at the bottom of each page, we
have to say something like ‘when the text is within an                   There are several ways to ﬁx the problems of
inch of the bottom of the page, start the processing              point sizes and fonts in titles. For the simplest appli-
for a new page.’ This is done with a ‘when’ com-                  cations, we can change .NP to set the proper size and
mand .wh
      .wh:                                                        font for the title, then restore the previous values, like
                                                                  this:
      .wh – 1i NP
                                                                    .de NP
(No ‘.’ is used before NP; this is simply the name of               ′bp
a macro, not a macro call.) The minus sign means                    ′sp 0.5i
‘measure up from the bottom of the page’, so ‘– 1i’                 .ft R              \" set title font to roman
means ‘one inch from the bottom’.                                   .ps 10             \" and size to 10 point
      The .wh command appears in the input outside                  .lt 6i             \" and length to 6 inches
the deﬁnition of .NP typically the input would be
                 .NP;                                               .tl ´left´center´right´
                                                                    .ps                \" revert to previous size
      .de NP                                                        .ft P              \" and to previous font
      ...                                                           ′sp 0.3i
      ..                                                            ..
      .wh – 1i NP
                                                                         This version of .NP does not work if the ﬁelds
       Now what happens? As text is actually being                in the .tl command contain size or font changes. To
output, troff keeps track of its vertical position on the         cope with that requires troff’s ‘environment’ mechan-
page, and after a line is printed within one inch from            ism, which we will discuss in Section 13.
the bottom, the .NP macro is activated. (In the jar-
gon, the .wh command sets a trap at the speciﬁed                          To get a footer at the bottom of a page, you
place, which is ‘sprung’ when that point is passed.)              can modify .NP so it does some processing before the
.NP causes a skip to the top of the next page (that’s             ′bp command, or split the job into a footer macro
what the ′bp was for), then prints the title with the             invoked at the bottom margin and a header macro
appropriate margins.                                              invoked at the top of the page. These variations are
                                                                  left as exercises.
       Why ′bp and ′sp instead of .bp and .sp The
                                               .sp?
answer is that .sp and .bp like several other com-
                          .bp,
mands, cause a break to take place. That is, all the                     Output page numbers are computed automati-
input text collected but not yet printed is ﬂushed out            cally as each page is produced (starting at 1), but no
as soon as possible, and the next input line is                   numbers are printed unless you ask for them expli-
guaranteed to start a new line of output. If we had               citly. To get page numbers printed, include the char-
used .sp or .bp in the .NP macro, this would cause a              acter % in the .tl line at the position where you want
break in the middle of the current output line when a             the number to appear. For example
new page is started. The effect would be to print the                   .tl ´´- % -´´
left-over part of that line at the top of the page, fol-
lowed by the next input line on a new output line.                centers the page number inside hyphens, as on this
This is not what we want. Using ′ instead of . for a              page. You can set the page number at any time with
command tells troff that no break is to take place —              either .bp n which immediately starts a new page
                                                                             n,
                                                            -9-


numbered n or with .pn n which sets the page
           n,                n,                                          Protecting by an extra layer of backslashes is
number for the next page but doesn’t cause a skip to              only needed for \n \∗ \$ (which we haven’t come to
                                                                                     \n, \∗,
the new page. Again, .bp +n sets the page number to               yet), and \ itself. Things like \s \f \h \v and so on
                                                                                                  \s, \f, \h, \v,
n more than its current value; .bp means .bp +1
                                             +1.                  do not need an extra backslash, since they are con-
                                                                  verted by troff to an internal code immediately upon
10. Number Registers and Arithmetic                               being seen.
       troff has a facility for doing arithmetic, and for
deﬁning and using variables with numeric values,                         Arithmetic expressions can appear anywhere
called number registers. Number registers, like                   that a number is expected. As a trivial example,
strings and macros, can be useful in setting up a
                                                                        .nr PS \\n(PS– 2
document so it is easy to change later. And of course
they serve for any sort of arithmetic computation.                decrements PS by 2. Expressions can use the arith-
       Like strings, number registers have one or two             metic operators +, – , ∗, /, % (mod), the relational
character names. They are set by the .nr command,                 operators >, >=, <, <=, =, and != (not equal), and
and are referenced anywhere by \nx (one character                 parentheses.
name) or \n(xy (two character name).                                     Although the arithmetic we have done so far
        There are quite a few pre-deﬁned number                   has been straightforward, more complicated things are
registers maintained by troff, among them % for the               somewhat tricky. First, number registers hold only
current page number; nl for the current vertical posi-            integers. troff arithmetic uses truncating integer divi-
tion on the page; dy mo and yr for the current day,
                   dy,                                            sion, just like Fortran. Second, in the absence of
month and year; and .s and .f for the current size and            parentheses, evaluation is done left-to-right without
font. (The font is a number from 1 to 4.) Any of                  any operator precedence (including relational opera-
these can be used in computations like any other                  tors). Thus
register, but some, like .s and .f cannot be changed
                                .f,                                     7∗– 4+3/13
with .nr
      .nr.
                                                                  becomes ‘– 1’. Number registers can occur anywhere
        As an example of the use of number registers,             in an expression, and so can scale indicators like p i
                                                                                                                     p, i,
in the – ms macro package [4], most signiﬁcant                    m and so on (but no spaces). Although integer divi-
                                                                  m,
parameters are deﬁned in terms of the values of a                 sion causes truncation, each number and its scale
handful of number registers. These include the point              indicator is converted to machine units (1/432 inch)
size for text, the vertical spacing, and the line and             before any arithmetic is done, so 1i/2u evaluates to
title lengths. To set the point size and vertical spac-           0.5i correctly.
ing for the following paragraphs, for example, a user
may say                                                                   The scale indicator u often has to appear when
                                                                  you wouldn’t expect it — in particular, when arith-
      .nr PS 9                                                    metic is being done in a context that implies horizon-
      .nr VS 11                                                   tal or vertical dimensions. For example,
The paragraph macro .PP is deﬁned (roughly) as fol-                     .ll 7/2i
lows:
                                                                  would seem obvious enough — 31⁄2 inches. Sorry.
      .de PP                                                      Remember that the default units for horizontal param-
      .ps \\n(PS          \"   reset size                         eters like .ll are ems. That’s really ‘7 ems / 2
      .vs \\n(VSp         \"   spacing                            inches’, and when translated into machine units, it
      .ft R               \"   font                               becomes zero. How about
      .sp 0.5v            \"   half a line
      .ti +3m                                                           .ll 7i/2
      ..                                                          Sorry, still no good — the ‘2’ is ‘2 ems’, so ‘7i/2’ is
This sets the font to Roman and the point size and                small, although not zero. You must use
line spacing to whatever values are stored in the                       .ll 7i/2u
number registers PS and VS
                        VS.
                                                                  So again, a safe rule is to attach a scale indicator to
       Why are there two backslashes? This is the                 every number, even constants.
eternal problem of how to quote a quote. When troff
originally reads the macro deﬁnition, it peels off one                   For arithmetic done within a .nr command,
backslash to see what’s coming next. To ensure that               there is no implication of horizontal or vertical
another is left in the deﬁnition when the macro is                dimension, so the default units are ‘units’, and 7i/2
used, we have to put in two backslashes in the                    and 7i/2u mean the same thing. Thus
deﬁnition. If only one backslash is used, point size                    .nr ll 7i/2
and vertical spacing will be frozen at the time the                     .ll \\n(llu
macro is deﬁned, not when it is used.
                                                          - 10 -


does just what you want, so long as you don’t forget               The \h and \w commands need no extra backslash, as
the u on the .ll command.                                          we discussed above. The \& is there in case the
                                                                   argument begins with a period.
11. Macros with arguments
       The next step is to deﬁne macros that can                          Two backslashes are needed with the \\$n com-
change from one use to the next according to parame-               mands, though, to protect one of them when the
ters supplied as arguments. To make this work, we                  macro is being deﬁned. Perhaps a second example
need two things: ﬁrst, when we deﬁne the macro, we                 will make this clearer. Consider a macro called .SH
have to indicate that some parts of it will be provided            which produces section headings rather like those in
as arguments when the macro is called. Then when                   this paper, with the sections numbered automatically,
the macro is called we have to provide actual argu-                and the title in bold in a smaller size. The use is
ments to be plugged into the deﬁnition.
                                                                         .SH "Section title ..."
      Let us illustrate by deﬁning a macro .SM that
will print its argument two points smaller than the                (If the argument to a macro is to contain blanks, then
surrounding text. That is, the macro call                          it must be surrounded by double quotes, unlike a
                                                                   string, where only one leading quote is permitted.)
      .SM TROFF
                                                                         Here is the deﬁnition of the .SH macro:
will produce TROFF.
                                                                         .nr SH 0      \" initialize section number
      The deﬁnition of .SM is                                            .de SH
      .de SM                                                             .sp 0.3i
      \s– 2\\$1\s+2                                                      .ft B
      ..                                                                 .nr SH \\n(SH+1        \" increment number
                                                                         .ps \\n(PS– 1 \" decrease PS
Within a macro deﬁnition, the symbol \\$n refers to                      \\n(SH. \\$1 \" number. title
the n argument that the macro was called with.
     nth                                                                 .ps \\n(PS             \" restore PS
Thus \\$1 is the string to be placed in a smaller point                  .sp 0.3i
size when .SM is called.                                                 .ft R
       As a slightly more complicated version, the                       ..
following deﬁnition of .SM permits optional second                 The section number is kept in number register SH,
and third arguments that will be printed in the normal             which is incremented each time just before it is used.
size:                                                              (A number register may have the same name as a
      .de SM                                                       macro without conﬂict but a string may not.)
      \\$3\s– 2\\$1\s+2\\$2                                                We used \\n(SH instead of \n(SH and \\n(PS
      ..                                                           instead of \n(PS If we had used \n(SH we would get
                                                                              \n(PS.                \n(SH,
Arguments not provided when the macro is called are                the value of the register at the time the macro was
treated as empty, so                                               deﬁned, not at the time it was used. If that’s what
                                                                   you want, ﬁne, but not here. Similarly, by using
      .SM TROFF ),                                                 \\n(PS we get the point size at the time the macro is
                                                                   \\n(PS,
produces TROFF), while                                             called.

      .SM TROFF ). (
                                                                          As an example that does not involve numbers,
produces (TROFF). It is convenient to reverse the                  recall our .NP macro which had a
order of arguments because trailing punctuation is
                                                                         .tl ´left´center´right´
much more common than leading.
      By the way, the number of arguments that a                   We could make these into parameters by using
macro was called with is available in number register              instead
.$
.$.                                                                      .tl ´\\∗(LT´\\∗(CT´\\∗(RT´
      The following macro .BD is the one used to                   so the title comes from three strings called LT, CT
make the ‘bold roman’ we have been using for troff                 and RT. If these are empty, then the title will be a
command names in text. It combines horizontal                      blank line. Normally CT would be set with some-
motions, width computations, and argument rearrange-               thing like
ment.
                                                                         .ds CT - % -
  .de BD
  \&\\$3\f1\\$1\h´– \w´\\$1´u+1u´\\$1\fP\\$2                       to give just the page number between hyphens (as on
  ..                                                               the top of this page), but a user could supply private
                                                                   deﬁnitions for any of the strings.
                                                             - 11 -


12. Conditionals                                                             Finally, string comparisons may be made in an
       Suppose we want the .SH macro to leave two                     .if
                                                                      .if:
extra inches of space just before section 1, but                             .if ´string1´string2´ stuff
nowhere else. The cleanest way to do that is to test
inside the .SH macro whether the section number is                    does ‘stuff’ if string1 is the same as string2. The
1, and add some space if it is. The .if command pro-                  character separating the strings can be anything rea-
vides the conditional test that we can add just before                sonable that is not contained in either string. The
the heading line is output:                                           strings themselves can reference strings with \∗ argu-
                                                                                                                    \∗,
                                                                      ments with \$ and so on.
                                                                                  \$,
     .if \\n(SH=1 .sp 2i              \" ﬁrst section only
                                                                      13. Environments
       The condition after the .if can be any arith-
metic or logical expression. If the condition is logi-                       As we mentioned, there is a potential problem
cally true, or arithmetically greater than zero, the rest             when going across a page boundary: parameters like
of the line is treated as if it were text — here a com-               size and font for a page title may well be different
mand. If the condition is false, or zero or negative,                 from those in effect in the text when the page boun-
the rest of the line is skipped.                                      dary occurs. troff provides a very general way to
                                                                      deal with this and similar situations. There are three
       It is possible to do more than one command if                  ‘environments’, each of which has independently sett-
a condition is true. Suppose several operations are to                able versions of many of the parameters associated
be done before section 1. One possibility is to deﬁne                 with processing, including size, font, line and title
a macro .S1 and invoke it if we are about to do sec-                  lengths, ﬁll/noﬁll mode, tab stops, and even partially
tion 1 (as determined by an .if
                             .if).                                    collected lines. Thus the titling problem may be
      .de S1                                                          readily solved by processing the main text in one
      --- processing for section 1 ---                                environment and titles in a separate one with its own
      ..                                                              suitable parameters.
      .de SH                                                                 The command .ev n shifts to environment n n
                                                                                                                     n;
      ...                                                             must be 0, 1 or 2. The command .ev with no argu-
      .if \\n(SH=1 .S1                                                ment returns to the previous environment. Environ-
      ...                                                             ment names are maintained in a stack, so calls for
      ..                                                              different environments may be nested and unwound
                                                                      consistently.
       An alternate way is to use the extended form
of the .if like this:
       .if,                                                                  Suppose we say that the main text is processed
                                                                      in environment 0, which is where troff begins by
      .if \\n(SH=1 \{--- processing                                   default. Then we can modify the new page macro
      for section 1 ----\}                                            .NP to process titles in environment 1 like this:
The braces \{ and \} must occur in the positions                         .de NP
shown or you will get unexpected extra lines in your                     .ev 1           \" shift to new environment
output. troff also provides an ‘if-else’ construction,                   .lt 6i          \" set parameters here
which we will not go into here.                                          .ft R
       A condition can be negated by preceding it                        .ps 10
with ! we get the same effect as above (but less
      !;                                                                 ... any other processing ...
clearly) by using                                                        .ev             \" return to previous environment
                                                                         ..
      .if !\\n(SH>1 .S1
                                                                      It is also possible to initialize the parameters for an
      There are a handful of other conditions that                    environment outside the .NP macro, but the version
can be tested with .if For example, is the current
                   .if.                                               shown keeps all the processing in one place and is
page even or odd?                                                     thus easier to understand and change.
      .if e .tl ´´even page title´´
                                                                      14. Diversions
      .if o .tl ´´odd page title´´
                                                                              There are numerous occasions in page layout
gives facing pages different titles when used inside an               when it is necessary to store some text for a period of
appropriate new page macro.                                           time without actually printing it. Footnotes are the
     Two other conditions are t and n which tell
                                         n,                           most obvious example: the text of the footnote usu-
you whether the formatter is troff or nroff.                          ally appears in the input well before the place on the
                                                                      page where it is to be printed is reached. In fact, the
      .if t troff stuff ...
                                                                      place where it is output normally depends on how big
      .if n nroff stuff ...
                                                                      it is, which implies that there must be a way to pro-
                                                             - 12 -


cess the footnote at least enough to decide its size                  teach everything about diversions, but to sketch out
without printing it.                                                  enough that you can read existing macro packages
       troff provides a mechanism called a diversion                  with some comprehension.
for doing this processing. Any part of the output may
be diverted into a macro instead of being printed, and                Acknowledgements
then at some convenient time the macro may be put                            I am deeply indebted to J. F. Ossanna, the
back into the input.                                                  author of troff, for his repeated patient explanations
       The command .di xy begins a diversion — all                    of ﬁne points, and for his continuing willingness to
subsequent output is collected into the macro xy until                adapt troff to make other uses easier. I am also
the command .di with no arguments is encountered.                     grateful to Jim Blinn, Ted Dolotta, Doug McIlroy,
This terminates the diversion. The processed text is                  Mike Lesk and Joel Sturman for helpful comments on
available at any time thereafter, simply by giving the                this paper.
command
                                                                      References
      .xy
                                                                      [1]   J. F. Ossanna, NROFF/TROFF User’s Manual,
The vertical size of the last ﬁnished diversion is con-                     Bell Laboratories Computing Science Technical
tained in the built-in number register dn
                                       dn.                                  Report 54, 1976.
       As a simple example, suppose we want to                        [2]   B. W. Kernighan, A System for Typesetting
implement a ‘keep-release’ operation, so that text                          Mathematics — User’s Guide (Second Edition),
between the commands .KS and .KE will not be split                          Bell Laboratories Computing Science Technical
across a page boundary (as for a ﬁgure or table).                           Report 17, 1977.
Clearly, when a .KS is encountered, we have to begin
diverting the output so we can ﬁnd out how big it is.                 [3]   M. E. Lesk, TBL — A Program to Format
Then when a .KE is seen, we decide whether the                              Tables, Bell Laboratories Computing Science
diverted text will ﬁt on the current page, and print it                     Technical Report 49, 1976.
either there if it ﬁts, or at the top of the next page if             [4]   M. E. Lesk, Typing Documents on UNIX, Bell
it doesn’t. So:                                                             Laboratories, 1978.
  .de KS       \"   start keep                                        [5]   J. R. Mashey and D. W. Smith, PWB/MM —
  .br          \"   start fresh line                                        Programmer’s Workbench Memorandum Mac-
  .ev 1        \"   collect in new environment                              ros, Bell Laboratories internal memorandum.
  .ﬁ           \"   make it ﬁlled text
  .di XX       \"   collect in XX
  ..

  .de KE      \" end keep
  .br         \" get last partial line
  .di         \" end diversion
  .if \\n(dn>=\\n(.t .bp \" bp if doesn´t ﬁt
  .nf         \" bring it back in no-ﬁll
  .XX         \" text
  .ev         \" return to normal environment
  ..
Recall that number register nl is the current position
on the output page. Since output was being diverted,
this remains at its value when the diversion started.
dn is the amount of text in the diversion; .t (another
built-in register) is the distance to the next trap,
which we assume is at the bottom margin of the page.
If the diversion is large enough to go past the trap,
the .if is satisﬁed, and a .bp is issued. In either case,
the diverted output is then brought back with .XX It
                                                 .XX.
is essential to bring it back in no-ﬁll mode so troff
will do no further processing on it.
        This is not the most general keep-release, nor
is it robust in the face of all conceivable inputs, but it
would require more space than we have here to write
it in full generality. This section is not intended to
                                                               - 13 -


Appendix A: Phototypesetter Character Set
These characters exist in roman, italic, and bold. To get the one on the left, type the four-character name on the
right.

         ff   \(ff         ﬁ   \(ﬁ           ﬂ \(ﬂ            ffi \(Fi          ffl \(Fl
         _    \(ru         —   \(em          1
                                              ⁄4 \(14         1
                                                                ⁄2 \(12         3
                                                                                 ⁄4 \(34
         ©    \(co         ˚   \(de          † \(dg           ′ \(fm            ¢ \(ct
         ®    \(rg         •   \(bu              \(sq         - \(hy
                                             (In bold, \(sq is .)

The following are special-font characters:

         +      \(pl           −      \(mi            ×       \(mu          ÷       \(di
         =      \(eq           ≡      \(==            ≥       \(>=          ≤       \(<=
         ≠      \(!=           ±      \(+-            ¬       \(no          ⁄       \(sl
         ∼      \(ap           ∼
                               −      \(˜=            ∝       \(pt          ∇       \(gr
         →      \(->           ←      \(<-            ↑       \(ua          ↓       \(da
         ∫      \(is           ∂      \(pd            ∞       \(if          √       \(sr
         ⊂      \(sb           ⊃      \(sp            ∪       \(cu          ∩       \(ca
         ⊆      \(ib           ⊇      \(ip            ∈       \(mo          ∅       \(es
         ´      \(aa           `      \(ga                    \(ci                  \(bs
         §      \(sc           ‡      \(dd                    \(lh                  \(rh
               \(lt                 \(rt                   \(lc                 \(rc
               \(lb                 \(rb                   \(lf                 \(rf
               \(lk                 \(rk                   \(bv          ς       \(ts
               \(br           |      \(or            _       \(ul                 \(rn
         ∗      \(∗∗

These four characters also have two-character names. The ´ is the apostrophe on terminals; the ` is the other quote
mark.

         ´      \´             `      \`              −       \−            _       \_

These characters exist only on the special font, but they do not have four-character names:

         "      {      }   <          >      ˜    ˆ       \        #    @

For greek, precede the roman letter by \(∗ to get the corresponding greek; for example, \(∗a is α.

          a b g d e z y h i k l mn c o p r s t u f x qw
          α β γ δ ε ζ η θ ι κ λ µ ν ξ ο π ρ σ τ υ φ χψω

          A B G D E Z Y H I K L MN C O P R S T U F X QW
          Α Β Γ ∆ Ε Ζ Η Θ Ι Κ ΛΜΝ Ξ Ο Π Ρ Σ Τ Υ Φ Χ ΨΩ
-




                                             C Reference Manual

                                                      Dennis M. Ritchie
                                                 Bell Telephone Laboratories
                                                Murray Hill, New Jersey 07974




    1. Introduction
      C is a computer language based on the earlier language B [1]. The languages and their compilers differ in two
    major ways: C introduces the notion of types, and defines appropriate extra syntax and semantics; also, C on the
    PDP-11 is a true compiler, producing machine code where B produced interpretive code.
       Most of the software for the UNIX time-sharing system [2] is written in C, as is the operating system itself. C is
    also available on the HIS 6070 computer at Murray Hill and and on the IBM System/370 at Holmdel [3]. This paper
    is a manual only for the C language itself as implemented on the PDP-11. However, hints are given occasionally in
    the text of implementation-dependent features.
       The UNIX Programmer’s Manual [4] describes the library routines available to C programs under UNIX, and also
    the procedures for compiling programs under that system. ‘‘The GCOS C Library’’ by Lesk and Barres [5] describes
    routines available under that system as well as compilation procedures. Many of these routines, particularly the ones
    having to do with I/O, are also provided under UNIX. Finally, ‘‘Programming in C− A Tutorial,’’ by B. W. Ker-
    nighan [6], is as useful as promised by its title and the author’s previous introductions to allegedly impenetrable sub-
    jects.

    2. Lexical conventions
       There are six kinds of tokens: identifiers, keywords, constants, strings, expression operators, and other separators.
    In general blanks, tabs, newlines, and comments as described below are ignored except as they serve to separate to-
    kens. At least one of these characters is required to separate otherwise adjacent identifiers, constants, and certain
    operator-pairs.
       If the input stream has been parsed into tokens up to a given character, the next token is taken to include the long-
    est string of characters which could possibly constitute a token.

    2.1 Comments
       The characters /* introduce a comment, which terminates with the characters */.

    2.2 Identifiers (Names)
       An identifier is a sequence of letters and digits; the first character must be alphabetic. The underscore ‘‘_’’ counts
    as alphabetic. Upper and lower case letters are considered different. No more than the first eight characters are sig-
    nificant, and only the first seven for external identifiers.

    2.3 Keywords
       The following identifiers are reserved for use as keywords, and may not be used otherwise:
-



    C Reference Manual - 2


             int                                   break
             char                                  continue
             float                                 if
             double                                else
             struct                                for
             auto                                  do
             extern                                while
             register                              switch
             static                                case
             goto                                  default
             return                                entry
             sizeof
    The entry keyword is not currently implemented by any compiler but is reserved for future use.

    2.3 Constants
       There are several kinds of constants, as follows:

    2.3.1 Integer constants
       An integer constant is a sequence of digits. An integer is taken to be octal if it begins with 0, decimal otherwise.
    The digits 8 and 9 have octal value 10 and 11 respectively.

    2.3.2 Character constants
       A character constant is 1 or 2 characters enclosed in single quotes ‘‘ ´ ’’. Within a character constant a single
    quote must be preceded by a back-slash ‘‘\’’. Certain non-graphic characters, and ‘‘\’’ itself, may be escaped ac-
    cording to the following table:
             BS            \b
             NL            \n
             CR            \r
             HT            \t
             ddd           \ddd
             \             \\
    The escape ‘‘\ddd’’ consists of the backslash followed by 1, 2, or 3 octal digits which are taken to specify the value
    of the desired character. A special case of this construction is ‘‘\0’’ (not followed by a digit) which indicates a null
    character.
       Character constants behave exactly like integers (not, in particular, like objects of character type). In conformity
    with the addressing structure of the PDP-11, a character constant of length 1 has the code for the given character in
    the low-order byte and 0 in the high-order byte; a character constant of length 2 has the code for the first character in
    the low byte and that for the second character in the high-order byte. Character constants with more than one char-
    acter are inherently machine-dependent and should be avoided.

    2.3.3 Floating constants
       A floating constant consists of an integer part, a decimal point, a fraction part, an e, and an optionally signed inte-
    ger exponent. The integer and fraction parts both consist of a sequence of digits. Either the integer part or the frac-
    tion part (not both) may be missing; either the decimal point or the e and the exponent (not both) may be missing.
    Every floating constant is taken to be double-precision.

    2.4 Strings
       A string is a sequence of characters surrounded by double quotes ‘‘ " ’’. A string has the type array-of-characters
    (see below) and refers to an area of storage initialized with the given characters. The compiler places a null byte
    ( \0 ) at the end of each string so that programs which scan the string can find its end. In a string, the character ‘‘ " ’’
    must be preceded by a ‘‘\’’ ; in addition, the same escapes as described for character constants may be used.
-



                                                                                                    C Reference Manual - 3


    3. Syntax notation
       In the syntax notation used in this manual, syntactic categories are indicated by italic type, and literal words and
    characters in gothic. Alternatives are listed on separate lines. An optional terminal or non-terminal symbol is in-
    dicated by the subscript ‘‘opt,’’ so that
             { expressionopt }
    would indicate an optional expression in braces.

    4. What’s in a Name?
       C bases the interpretation of an identifier upon two attributes of the identifier: its storage class and its type. The
    storage class determines the location and lifetime of the storage associated with an identifier; the type determines the
    meaning of the values found in the identifier’s storage.
      There are four declarable storage classes: automatic, static, external, and register. Automatic variables are local to
    each invocation of a function, and are discarded on return; static variables are local to a function, but retain their val-
    ues independently of invocations of the function; external variables are independent of any function. Register vari-
    ables are stored in the fast registers of the machine; like automatic variables they are local to each function and dis-
    appear on return.
      C supports four fundamental types of objects: characters, integers, single-, and double-precision floating-point
    numbers.
             Characters (declared, and hereinafter called, char) are chosen from the ASCII set; they occupy the right-
             most seven bits of an 8-bit byte. It is also possible to interpret chars as signed, 2’s complement 8-bit
             numbers.
             Integers (int) are represented in 16-bit 2’s complement notation.
                                                                                                                      ±38
             Single precision floating point (float) quantities have magnitude in the range approximately 10                or 0;
             their precision is 24 bits or about seven decimal digits.
             Double-precision floating-point (double) quantities have the same range as floats and a precision of 56
             bits or about 17 decimal digits.

      Besides the four fundamental types there is a conceptually infinite class of derived types constructed from the fun-
    damental types in the following ways:
             arrays of objects of most types;
             functions which return objects of a given type;
             pointers to objects of a given type;
             structures containing objects of various types.
    In general these methods of constructing objects can be applied recursively.

    5. Objects and lvalues
       An object is a manipulatable region of storage; an lvalue is an expression referring to an object. An obvious ex-
    ample of an lvalue expression is an identifier. There are operators which yield lvalues: for example, if E is an ex-
    pression of pointer type, then *E is an lvalue expression referring to the object to which E points. The name
    ‘‘lvalue’’ comes from the assignment expression ‘‘E1 = E2’’ in which the left operand E1 must be an lvalue expres-
    sion. The discussion of each operator below indicates whether it expects lvalue operands and whether it yields an
    lvalue.

    6. Conversions
      A number of operators may, depending on their operands, cause conversion of the value of an operand from one
    type to another. This section explains the result to be expected from such conversions.
-



    C Reference Manual - 4


    6.1 Characters and integers
       A char object may be used anywhere an int may be. In all cases the char is converted to an int by propa-
    gating its sign through the upper 8 bits of the resultant integer. This is consistent with the two’s complement repre-
    sentation used for both characters and integers. (However, the sign-propagation feature disappears in other imple-
    mentations.)

    6.2 Float and double
       All floating arithmetic in C is carried out in double-precision; whenever a float appears in an expression it is
    lengthened to double by zero-padding its fraction. When a double must be converted to float, for example by
    an assignment, the double is rounded before truncation to float length.

    6.3 Float and double; integer and character
       All ints and chars may be converted without loss of significance to float or double. Conversion of
    float or double to int or char takes place with truncation towards 0. Erroneous results can be expected if the
    magnitude of the result exceeds 32,767 (for int) or 127 (for char).

    6.4 Pointers and integers
       Integers and pointers may be added and compared; in such a case the int is converted as specified in the discus-
    sion of the addition operator.
      Two pointers to objects of the same type may be subtracted; in this case the result is converted to an integer as
    specified in the discussion of the subtraction operator.

    7. Expressions
       The precedence of expression operators is the same as the order of the major subsections of this section (highest
    precedence first). Thus the expressions referred to as the operands of + (§7.4) are those expressions defined in
    §§7.1_7.3. Within each subsection, the operators have the same precedence. Left- or right-associativity is specified
    in each subsection for the operators discussed therein. The precedence and associativity of all the expression opera-
    tors is summarized in an appendix.
      Otherwise the order of evaluation of expressions is undefined. In particular the compiler considers itself free to
    compute subexpressions in the order it believes most efficient, even if the subexpressions involve side effects.

    7.1 Primary expressions
       Primary expressions involving . , −>, subscripting, and function calls group left to right.

    7.1.1 identifier
       An identifier is a primary expression, provided it has been suitably declared as discussed below. Its type is speci-
    fied by its declaration. However, if the type of the identifier is ‘‘array of . . .’’, then the value of the identifier-
    expression is a pointer to the first object in the array, and the type of the expression is ‘‘pointer to . . .’’. Moreover,
    an array identifier is not an lvalue expression.
       Likewise, an identifier which is declared ‘‘function returning . . .’’, when used except in the function-name posi-
    tion of a call, is converted to ‘‘pointer to function returning . . .’’.

    7.1.2 constant
       A decimal, octal, character, or floating constant is a primary expression. Its type is int in the first three cases,
    double in the last.

    7.1.3 string
       A string is a primary expression. Its type is originally ‘‘array of char’’; but following the same rule as in §7.1.1
    for identifiers, this is modified to ‘‘pointer to char’’ and the result is a pointer to the first character in the string.

    7.1.4 ( expression )
      A parenthesized expression is a primary expression whose type and value are identical to those of the unadorned
    expression. The presence of parentheses does not affect whether the expression is an lvalue.
-



                                                                                                        C Reference Manual - 5


    7.1.5 primary-expression [ expression ]
       A primary expression followed by an expression in square brackets is a primary expression. The intuitive mean-
    ing is that of a subscript. Usually, the primary expression has type ‘‘pointer to . . .’’, the subscript expression is int,
    and the type of the result is ‘‘ . . . ’’. The expression ‘‘E1[E2]’’ is identical (by definition) to ‘‘* ( ( E1 ) + ( E2 ) ) ’’.
    All the clues needed to understand this notation are contained in this section together with the discussions in §§
    7.1.1, 7.2.1, and 7.4.1 on identifiers, *, and + respectively; §14.3 below summarizes the implications.

    7.1.6 primary-expression ( expression-listopt )
       A function call is a primary expression followed by parentheses containing a possibly empty, comma-separated
    list of expressions which constitute the actual arguments to the function. The primary expression must be of type
    ‘‘function returning . . .’’, and the result of the function call is of type ‘‘ . . . ’’. As indicated below, a hitherto unseen
    identifier followed immediately by a left parenthesis is contextually declared to represent a function returning an in-
    teger; thus in the most common case, integer-valued functions need not be declared.
       Any actual arguments of type float are converted to double before the call; any of type char are converted
    to int.
       In preparing for the call to a function, a copy is made of each actual parameter; thus, all argument-passing in C is
    strictly by value. A function may change the values of its formal parameters, but these changes cannot possibly af-
    fect the values of the actual parameters. On the other hand, it is perfectly possible to pass a pointer on the under-
    standing that the function may change the value of the object to which the pointer points.
      Recursive calls to any function are permissible.

    7.1.7 primary-lvalue . member-of-structure
       An lvalue expression followed by a dot followed by the name of a member of a structure is a primary expression.
    The object referred to by the lvalue is assumed to have the same form as the structure containing the structure mem-
    ber. The result of the expression is an lvalue appropriately offset from the origin of the given lvalue whose type is
    that of the named structure member. The given lvalue is not required to have any particular type.
      Structures are discussed in §8.5.

    7.1.8 primary-expression −> member-of-structure
       The primary-expression is assumed to be a pointer which points to an object of the same form as the structure of
    which the member-of-structure is a part. The result is an lvalue appropriately offset from the origin of the pointed-to
    structure whose type is that of the named structure member. The type of the primary-expression need not in fact be
    pointer; it is sufficient that it be a pointer, character, or integer.
      Except for the relaxation of the requirement that E1 be of pointer type, the expression ‘‘E1−>MOS’’ is exactly
    equivalent to ‘‘(*E1).MOS’’.

    7.2 Unary operators
       Expressions with unary operators group right-to-left.

    7.2.1 * expression
        The unary * operator means indirection: the expression must be a pointer, and the result is an lvalue referring to
    the object to which the expression points. If the type of the expression is ‘‘pointer to . . .’’, the type of the result is
    ‘‘ . . . ’’.

    7.2.2 & lvalue-expression
       The result of the unary & operator is a pointer to the object referred to by the lvalue-expression. If the type of the
    lvalue-expression is ‘‘ . . . ’’, the type of the result is ‘‘pointer to . . .’’.

    7.2.3 − expression
       The result is the negative of the expression, and has the same type. The type of the expression must be char,
    int, float, or double.
-



    C Reference Manual - 6


    7.2.4 ! expression
       The result of the logical negation operator ! is 1 if the value of the expression is 0, 0 if the value of the expres-
    sion is non-zero. The type of the result is int. This operator is applicable only to ints or chars.

    7.2.5
           ~ expression
       The operator yields the one’s complement of its operand. The type of the expression must be int or char, and
           ˜
    the result is int.

    7.2.6 ++ lvalue-expression
       The object referred to by the lvalue expression is incremented. The value is the new value of the lvalue expres-
    sion and the type is the type of the lvalue. If the expression is int or char, it is incremented by 1; if it is a pointer
    to an object, it is incremented by the length of the object. ++ is applicable only to these types. (Not, for example, to
    float or double.)

    7.2.7 −− lvalue-expression
       The object referred to by the lvalue expression is decremented analogously to the ++ operator.

    7.2.8 lvalue-expression ++
       The result is the value of the object referred to by the lvalue expression. After the result is noted, the object re-
    ferred to by the lvalue is incremented in the same manner as for the prefix ++ operator: by 1 for an int or char, by
    the length of the pointed-to object for a pointer. The type of the result is the same as the type of the lvalue-
    expression.

    7.2.9 lvalue-expression −−
       The result of the expression is the value of the object referred to by the the lvalue expression. After the result is
    noted, the object referred to by the lvalue expression is decremented in a way analogous to the postfix ++ operator.

    7.2.10 sizeof expression
       The sizeof operator yields the size, in bytes, of its operand. When applied to an array, the result is the total
    number of bytes in the array. The size is determined from the declarations of the objects in the expression. This ex-
    pression is semantically an integer constant and may be used anywhere a constant is required. Its major use is in
    communication with routines like storage allocators and I/O systems.

    7.3 Multiplicative operators
       The multiplicative operators *, /, and % group left-to-right.

    7.3.1 expression * expression
       The binary * operator indicates multiplication. If both operands are int or char, the result is int; if one is
    int or char and one float or double, the former is converted to double, and the result is double; if both
    are float or double, the result is double. No other combinations are allowed.

    7.3.2 expression / expression
      The binary / operator indicates division. The same type considerations as for multiplication apply.

    7.3.3 expression % expression
       The binary % operator yields the remainder from the division of the first expression by the second. Both operands
    must be int or char, and the result is int. In the current implementation, the remainder has the same sign as the
    dividend.

    7.4 Additive operators
       The additive operators + and − group left-to-right.
-



                                                                                                   C Reference Manual - 7


    7.4.1 expression + expression
       The result is the sum of the expressions. If both operands are int or char, the result is int. If both are float
    or double, the result is double. If one is char or int and one is float or double, the former is converted to
    double and the result is double. If an int or char is added to a pointer, the former is converted by multiplying
    it by the length of the object to which the pointer points and the result is a pointer of the same type as the original
    pointer. Thus if P is a pointer to an object, the expression ‘‘P+1’’ is a pointer to another object of the same type as
    the first and immediately following it in storage.
      No other type combinations are allowed.

    7.4.2 expression − expression
       The result is the difference of the operands. If both operands are int, char, float, or double, the same type
    considerations as for + apply. If an int or char is subtracted from a pointer, the former is converted in the same
    way as explained under + above.
       If two pointers to objects of the same type are subtracted, the result is converted (by division by the length of the
    object) to an int representing the number of objects separating the pointed-to objects. This conversion will in gen-
    eral give unexpected results unless the pointers point to objects in the same array, since pointers, even to objects of
    the same type, do not necessarily differ by a multiple of the object-length.

    7.5 Shift operators
       The shift operators << and >> group left-to-right.

    7.5.1 expression << expression
    7.5.2 expression >> expression
       Both operands must be int or char, and the result is int. The second operand should be non-negative. The
    value of ‘‘E1<<E2’’ is E1 (interpreted as a bit pattern 16 bits long) left-shifted E2 bits; vacated bits are 0-filled. The
    value of ‘‘E1>>E2’’ is E1 (interpreted as a two’s complement, 16-bit quantity) arithmetically right-shifted E2 bit po-
    sitions. Vacated bits are filled by a copy of the sign bit of E1. [Note: the use of arithmetic rather than logical shift
    does not survive transportation between machines.]

    7.6 Relational operators
       The relational operators group left-to-right, but this fact is not very useful; ‘‘a<b<c’’ does not mean what it seems
    to.

    7.6.1 expression < expression
    7.6.2 expression > expression
    7.6.3 expression <= expression
    7.6.4 expression >= expression
       The operators < (less than), > (greater than), <= (less than or equal to) and >= (greater than or equal to) all yield 0
    if the specified relation is false and 1 if it is true. Operand conversion is exactly the same as for the + operator ex-
    cept that pointers of any kind may be compared; the result in this case depends on the relative locations in storage of
    the pointed-to objects. It does not seem to be very meaningful to compare pointers with integers other than 0.

    7.7 Equality operators
    7.7.1 expression == expression
    7.7.2 expression != expression
       The == (equal to) and the != (not equal to) operators are exactly analogous to the relational operators except for
    their lower precedence. (Thus ‘‘a<b == c<d’’ is 1 whenever a<b and c<d have the same truth-value).

    7.8 expression & expression
       The & operator groups left-to-right. Both operands must be int or char; the result is an int which is the bit-
    wise logical and function of the operands.
-



    C Reference Manual - 8


    7.9 expression ^ expression
      The ^ operator groups left-to-right. The operands must be int or char; the result is an int which is the bit-
    wise exclusive or function of its operands.

    7.10 expression | expression
       The | operator groups left-to-right. The operands must be int or char; the result is an int which is the bit-wise
    inclusive or of its operands.

    7.11 expression && expression
       The && operator returns 1 if both its operands are non-zero, 0 otherwise. Unlike &, && guarantees left-to-right
    evaluation; moreover the second operand is not evaluated if the first operand is 0.
      The operands need not have the same type, but each must have one of the fundamental types or be a pointer.

    7.12 expression || expression
       The || operator returns 1 if either of its operands is non-zero, and 0 otherwise. Unlike | , || guarantees left-to-right
    evaluation; moreover, the second operand is not evaluated if the value of the first operand is non-zero.
      The operands need not have the same type, but each must have one of the fundamental types or be a pointer.

    7.13 expression ? expression : expression
       Conditional expressions group left-to-right. The first expression is evaluated and if it is non-zero, the result is the
    value of the second expression, otherwise that of third expression. If the types of the second and third operand are
    the same, the result has their common type; otherwise the same conversion rules as for + apply. Only one of the sec-
    ond and third expressions is evaluated.

    7.14 Assignment operators
       There are a number of assignment operators, all of which group right-to-left. All require an lvalue as their left
    operand, and the type of an assignment expression is that of its left operand. The value is the value stored in the left
    operand after the assignment has taken place.

    7.14.1 lvalue = expression
      The value of the expression replaces that of the object referred to by the lvalue. The operands need not have the
    same type, but both must be int, char, float, double, or pointer. If neither operand is a pointer, the assign-
    ment takes place as expected, possibly preceded by conversion of the expression on the right.
       When both operands are int or pointers of any kind, no conversion ever takes place; the value of the expression
    is simply stored into the object referred to by the lvalue. Thus it is possible to generate pointers which will cause ad-
    dressing exceptions when used.

    7.14.2 lvalue =+ expression
    7.14.3 lvalue =− expression
    7.14.4 lvalue =* expression
    7.14.5 lvalue =/ expression
    7.14.6 lvalue =% expression
    7.14.7 lvalue =>> expression
    7.14.8 lvalue =<< expression
    7.14.9 lvalue =& expression
    7.14.10 lvalue =^ expression
    7.14.11 lvalue = | expression
       The behavior of an expression of the form ‘‘E1 =op E2’’ may be inferred by taking it as equivalent to
    ‘‘E1 = E1 op E2’’; however, E1 is evaluated only once. Moreover, expressions like ‘‘i =+ p’’ in which a pointer is
    added to an integer, are forbidden.
-



                                                                                                 C Reference Manual - 9


    7.15 expression , expression
       A pair of expressions separated by a comma is evaluated left-to-right and the value of the left expression is dis-
    carded. The type and value of the result are the type and value of the right operand. This operator groups left-to-
    right. It should be avoided in situations where comma is given a special meaning, for example in actual arguments
    to function calls (§7.1.6) and lists of initializers (§10.2).

    8. Declarations
       Declarations are used within function definitions to specify the interpretation which C gives to each identifier;
    they do not necessarily reserve storage associated with the identifier. Declarations have the form
             declaration:
                      decl-specifiers declarator-listopt ;
    The declarators in the declarator-list contain the identifiers being declared. The decl-specifiers consist of at most
    one type-specifier and at most one storage class specifier.
             decl-specifiers:
                      type-specifier
                      sc-specifier
                      type-specifier sc-specifier
                      sc-specifier type-specifier
    8.1 Storage class specifiers
      The sc-specifiers are:
             sc-specifier:
                      auto
                      static
                      extern
                      register
    The auto, static, and register declarations also serve as definitions in that they cause an appropriate
    amount of storage to be reserved. In the extern case there must be an external definition (see below) for the given
    identifiers somewhere outside the function in which they are declared.
       There are some severe restrictions on register identifiers: there can be at most 3 register identifiers in any
    function, and the type of a register identifier can only be int, char, or pointer (not float, double, struc-
    ture, function, or array). Also the address-of operator & cannot be applied to such identifiers. Except for these re-
    strictions (in return for which one is rewarded with faster, smaller code), register identifiers behave as if they were
    automatic. In fact implementations of C are free to treat register as synonymous with auto.
      If the sc-specifier is missing from a declaration, it is generally taken to be auto.

    8.2 Type specifiers
      The type-specifiers are
             type-specifier:
                      int
                      char
                      float
                      double
                      struct { type-decl-list }
                      struct identifier { type-decl-list }
                      struct identifier
    The struct specifier is discussed in §8.5. If the type-specifier is missing from a declaration, it is generally taken
    to be int.
-



    C Reference Manual - 10


    8.3 Declarators
       The declarator-list appearing in a declaration is a comma-separated sequence of declarators.
               declarator-list:
                        declarator
                        declarator , declarator-list
    The specifiers in the declaration indicate the type and storage class of the objects to which the declarators refer.
    Declarators have the syntax:
               declarator:
                        identifier
                        * declarator
                        declarator ( )
                        declarator [ constant-expressionopt ]
                        ( declarator )
    The grouping in this definition is the same as in expressions.

    8.4 Meaning of declarators
       Each declarator is taken to be an assertion that when a construction of the same form as the declarator appears in
    an expression, it yields an object of the indicated type and storage class. Each declarator contains exactly one identi-
    fier; it is this identifier that is declared.
       If an unadorned identifier appears as a declarator, then it has the type indicated by the specifier heading the decla-
    ration.
         If a declarator has the form

               *D
    for D a declarator, then the contained identifier has the type ‘‘pointer to . . .’’, where ‘‘ . . . ’’ is the type which the
    identifier would have had if the declarator had been simply D.
         If a declarator has the form
               D( )
    then the contained identifier has the type ‘‘function returning ...’’, where ‘‘ . . . ’’ is the type which the identifier
    would have had if the declarator had been simply D.
         A declarator may have the form
               D[constant-expression]
    or
               D[ ]
    In the first case the constant expression is an expression whose value is determinable at compile time, and whose
    type is int. in the second the constant 1 is used. (Constant expressions are defined precisely in §15.) Such a
    declarator makes the contained identifier have type ‘‘array.’’ If the unadorned declarator D would specify a non-
    array of type ‘‘. . .’’, then the declarator ‘‘D[ i ]’’ yields a 1-dimensional array with rank i of objects of type ‘‘. . .’’. If
    the unadorned declarator D would specify an n -dimensional array with rank i1 × i2 × . . . × in, then the declarator
    ‘‘D[ in+1 ]’’ yields an (n +1 ) -dimensional array with rank i1 × i2 × . . . × in × in+1.
       An array may be constructed from one of the basic types, from a pointer, from a structure, or from another array
    (to generate a multi-dimensional array).
      Finally, parentheses in declarators do not alter the type of the contained identifier except insofar as they alter the
    binding of the components of the declarator.
       Not all the possibilities allowed by the syntax above are actually permitted. The restrictions are as follows: func-
    tions may not return arrays, structures or functions, although they may return pointers to such things; there are no ar-
    rays of functions, although there may be arrays of pointers to functions. Likewise a structure may not contain a
    function, but it may contain a pointer to a function.
-



                                                                                                     C Reference Manual - 11


      As an example, the declaration
             int i, *ip, f ( ), *fip( ), (*pfi) ( );
    declares an integer i, a pointer ip to an integer, a function f returning an integer, a function fip returning a pointer to
    an integer, and a pointer pfi to a function which returns an integer. Also
             float fa[17], *afp[17];
    declares an array of float numbers and an array of pointers to float numbers. Finally,
             static int x3d[3][5][7];
    declares a static three-dimensional array of integers, with rank 3×5×7. In complete detail, x3d is an array of three
    items: each item is an array of five arrays; each of the latter arrays is an array of seven integers. Any of the expres-
    sions ‘‘x3d’’, ‘‘x3d[ i ]’’, ‘‘x3d[ i ][ j ]’’, ‘‘x3d[ i ][ j ][ k ]’’ may reasonably appear in an expression. The first three
    have type ‘‘array’’, the last has type int.

    8.5 Structure declarations
       Recall that one of the forms for a structure specifier is
                       struct { type-decl-list }
    The type-decl-list is a sequence of type declarations for the members of the structure:
             type-decl-list:
                      type-declaration
                      type-declaration type-decl-list
    A type declaration is just a declaration which does not mention a storage class (the storage class ‘‘member of struc-
    ture’’ here being understood by context).
             type-declaration:
                      type-specifier declarator-list ;
    Within the structure, the objects declared have addresses which increase as their declarations are read left-to-right.
    Each component of a structure begins on an addressing boundary appropriate to its type. On the PDP-11 the only re-
    quirement is that non-characters begin on a word boundary; therefore, there may be 1-byte, unnamed holes in a
    structure, and all structures have an even length in bytes.
      Another form of structure specifier is
                       struct identifier { type-decl-list }
    This form is the same as the one just discussed, except that the identifier is remembered as the structure tag of the
    structure specified by the list. A subsequent declaration may then be given using the structure tag but without the
    list, as in the third form of structure specifier:
                       struct identifier
    Structure tags allow definition of self-referential structures; they also permit the long part of the declaration to be
    given once and used several times. It is however absurd to declare a structure which contains an instance of itself, as
    distinct from a pointer to an instance of itself.
      A simple example of a structure declaration, taken from §16.2 where its use is illustrated more fully, is
             struct tnode {
                   char tword[20];
                   int count;
                   struct tnode *left;
                   struct tnode *right;
             };
    which contains an array of 20 characters, an integer, and two pointers to similar structures. Once this declaration has
-



    C Reference Manual - 12


    been given, the following declaration makes sense:
             struct tnode s, *sp;
    which declares s to be a structure of the given sort and sp to be a pointer to a structure of the given sort.
       The names of structure members and structure tags may be the same as ordinary variables, since a distinction can
    be made by context. However, names of tags and members must be distinct. The same member name can appear in
    different structures only if the two members are of the same type and if their origin with respect to their structure is
    the same; thus separate structures can share a common initial segment.

    9. Statements
      Except as indicated, statements are executed in sequence.

    9.1 Expression statement
       Most statements are expression statements, which have the form
             expression ;
    Usually expression statements are assignments or function calls.

    9.2 Compound statement
       So that several statements can be used where one is expected, the compound statement is provided:
             compound-statement:
                    { statement-list }

             statement-list:
                     statement
                     statement statement-list
    9.3 Conditional statement
       The two forms of the conditional statement are
             if ( expression ) statement
             if ( expression ) statement else statement
    In both cases the expression is evaluated and if it is non-zero, the first substatement is executed. In the second case
    the second substatement is executed if the expression is 0. As usual the ‘‘else’’ ambiguity is resolved by connecting
    an else with the last encountered elseless if.

    9.4 While statement
       The while statement has the form
             while ( expression ) statement
    The substatement is executed repeatedly so long as the value of the expression remains non-zero. The test takes
    place before each execution of the statement.

    9.5 Do statement
       The do statement has the form
             do statement while ( expression ) ;
    The substatement is executed repeatedly until the value of the expression becomes zero. The test takes place after
    each execution of the statement.
-



                                                                                                 C Reference Manual - 13


    9.6 For statement
       The for statement has the form
             for ( expression-1opt ; expression-2opt ; expression-3opt ) statement
    This statement is equivalent to
             expression-1;
             while ( expression-2 ) {
                      statement
                      expression-3 ;
             }
    Thus the first expression specifies initialization for the loop; the second specifies a test, made before each iteration,
    such that the loop is exited when the expression becomes 0; the third expression typically specifies an incrementa-
    tion which is performed after each iteration.
       Any or all of the expressions may be dropped. A missing expression-2 makes the implied while clause equiva-
    lent to ‘‘while( 1 )’’; other missing expressions are simply dropped from the expansion above.

    9.7 Switch statement
       The switch statement causes control to be transferred to one of several statements depending on the value of an
    expression. It has the form
             switch ( expression ) statement
    The expression must be int or char. The statement is typically compound. Each statement within the statement
    may be labelled with case prefixes as follows:
             case constant-expression :
    where the constant expression must be int or char. No two of the case constants in a switch may have the same
    value. Constant expressions are precisely defined in §15.
      There may also be at most one statement prefix of the form
             default :
    When the switch statement is executed, its expression is evaluated and compared with each case constant in an un-
    defined order. If one of the case constants is equal to the value of the expression, control is passed to the statement
    following the matched case prefix. If no case constant matches the expression, and if there is a default prefix,
    control passes to the prefixed statement. In the absence of a default prefix none of the statements in the switch is
    executed.
      Case or default prefixes in themselves do not alter the flow of control.

    9.8 Break statement
       The statement
             break ;
    causes termination of the smallest enclosing while, do, for, or switch statement; control passes to the state-
    ment following the terminated statement.

    9.9 Continue statement
       The statement
             continue ;
    causes control to pass to the loop-continuation portion of the smallest enclosing while, do, or for statement; that
    is to the end of the loop. More precisely, in each of the statements
-



    C Reference Manual - 14


             while ( . . . ) {                     do {                                  for ( . . . ) {
               ...                                   ...                                   ...
             contin: ;                             contin: ;                             contin: ;
             }                                     } while ( . . . ) ;                   }
    a continue is equivalent to ‘‘goto contin’’.

    9.10 Return statement
       A function returns to its caller by means of the return statement, which has one of the forms
             return ;
             return ( expression ) ;
    In the first case no value is returned. In the second case, the value of the expression is returned to the caller of the
    function. If required, the expression is converted, as if by assignment, to the type of the function in which it appears.
    Flowing off the end of a function is equivalent to a return with no returned value.

    9.11 Goto statement
       Control may be transferred unconditionally by means of the statement
             goto expression ;
    The expression should be a label (§§9.12, 14.4) or an expression of type ‘‘pointer to int’’ which evaluates to a la-
    bel. It is illegal to transfer to a label not located in the current function unless some extra-language provision has
    been made to adjust the stack correctly.

    9.12 Labelled statement
       Any statement may be preceded by label prefixes of the form
             identifier :
    which serve to declare the identifier as a label. More details on the semantics of labels are given in §14.4 below.

    9.13 Null statement
       The null statement has the form
             ;
    A null statement is useful to carry a label just before the ‘‘}’’ of a compound statement or to supply a null body to a
    looping statement such as while.

    10. External definitions
       A C program consists of a sequence of external definitions. External definitions may be given for functions, for
    simple variables, and for arrays. They are used both to declare and to reserve storage for objects. An external defi-
    nition declares an identifier to have storage class extern and a specified type. The type-specifier (§8.2) may be
    empty, in which case the type is taken to be int.

    10.1 External function definitions
      Function definitions have the form
             function-definition:
                      type-specifieropt function-declarator function-body
    A function declarator is similar to a declarator for a ‘‘function returning ...’’ except that it lists the formal parameters
    of the function being defined.
             function-declarator:
                      declarator ( parameter-listopt )

             parameter-list:
-



                                                                                                      C Reference Manual - 15


                       identifier
                       identifier , parameter-list
    The function-body has the form
             function-body:
                      type-decl-list function-statement
    The purpose of the type-decl-list is to give the types of the formal parameters. No other identifiers should be de-
    clared in this list, and formal parameters should be declared only here.
      The function-statement is just a compound statement which may have declarations at the start.
             function-statement:
                      { declaration-listopt statement-list }
    A simple example of a complete function definition is
             int max ( a, b, c)
             int a, b, c;
             {
                   int m;
                   m = ( a > b )? a : b ;
                   return ( m > c? m : c ) ;
             }
    Here ‘‘int’’ is the type-specifier; ‘‘max(a, b, c)’’ is the function-declarator; ‘‘int a, b, c;’’ is the type-decl-list for the
    formal parameters; ‘‘{ . . . }’’ is the function-statement.
        C converts all float actual parameters to double, so formal parameters declared float have their declara-
    tion adjusted to read double. Also, since a reference to an array in any context (in particular as an actual parame-
    ter) is taken to mean a pointer to the first element of the array, declarations of formal parameters declared ‘‘array of
    ...’’ are adjusted to read ‘‘pointer to ...’’. Finally, because neither structures nor functions can be passed to a func-
    tion, it is useless to declare a formal parameter to be a structure or function (pointers to structures or functions are of
    course permitted).
      A free return statement is supplied at the end of each function definition, so running off the end causes control,
    but no value, to be returned to the caller.

    10.2 External data definitions
      An external data definition has the form
             data-definition:
                      externopt type-specifieropt init-declarator-listopt ;
    The optional extern specifier is discussed in § 11.2. If given, the init-declarator-list is a comma-separated list of
    declarators each of which may be followed by an initializer for the declarator.
             init-declarator-list:
                       init-declarator
                       init-declarator , init-declarator-list

             init-declarator:
                       declarator initializeropt
    Each initializer represents the initial value for the corresponding object being defined (and declared).
             initializer:
                       constant
                       { constant-expression-list }
-



    C Reference Manual - 16


             constant-expression-list:
                      constant-expression
                      constant-expression , constant-expression-list
    Thus an initializer consists of a constant-valued expression, or comma-separated list of expressions, inside braces.
    The braces may be dropped when the expression is just a plain constant. The exact meaning of a constant expression
    is discussed in §15. The expression list is used to initialize arrays; see below.
      The type of the identifier being defined should be compatible with the type of the initializer: a double constant
    may initialize a float or double identifier; a non-floating-point expression may initialize an int, char, or
    pointer.
       An initializer for an array may contain a comma-separated list of compile-time expressions. The length of the ar-
    ray is taken to be the maximum of the number of expressions in the list and the square-bracketed constant in the
    array’s declarator. This constant may be missing, in which case 1 is used. The expressions initialize successive
    members of the array starting at the origin (subscript 0) of the array. The acceptable expressions for an array of type
    ‘‘array of ...’’ are the same as those for type ‘‘...’’. As a special case, a single string may be given as the initializer
    for an array of chars; in this case, the characters in the string are taken as the initializing values.
       Structures can be initialized, but this operation is incompletely implemented and machine-dependent. Basically
    the structure is regarded as a sequence of words and the initializers are placed into those words. Structure initializa-
    tion, using a comma-separated list in braces, is safe if all the members of the structure are integers or pointers but is
    otherwise ill-advised.
      The initial value of any externally-defined object not explicitly initialized is guaranteed to be 0.

    11. Scope rules
      A complete C program need not all be compiled at the same time: the source text of the program may be kept in
    several files, and precompiled routines may be loaded from libraries. Communication among the functions of a pro-
    gram may be carried out both through explicit calls and through manipulation of external data.
      Therefore, there are two kinds of scope to consider: first, what may be called the lexical scope of an identifier,
    which is essentially the region of a program during which it may be used without drawing ‘‘undefined identifier’’ di-
    agnostics; and second, the scope associated with external identifiers, which is characterized by the rule that refer-
    ences to the same external identifier are references to the same object.

    11.1 Lexical scope
       C is not a block-structured language; this may fairly be considered a defect. The lexical scope of names declared
    in external definitions extends from their definition through the end of the file in which they appear. The lexical
    scope of names declared at the head of functions (either as formal parameters or in the declarations heading the state-
    ments constituting the function itself) is the body of the function.
       It is an error to redeclare identifiers already declared in the current context, unless the new declaration specifies
    the same type and storage class as already possessed by the identifiers.

    11.2 Scope of externals
       If a function declares an identifier to be extern, then somewhere among the files or libraries constituting the
    complete program there must be an external definition for the identifier. All functions in a given program which re-
    fer to the same external identifier refer to the same object, so care must be taken that the type and extent specified in
    the definition are compatible with those specified by each function which references the data.
       In PDP-11 C, it is explicitly permitted for (compatible) external definitions of the same identifier to be present in
    several of the separately-compiled pieces of a complete program, or even twice within the same program file, with
    the important limitation that the identifier may be initialized in at most one of the definitions. In other operating sys-
    tems, however, the compiler must know in just which file the storage for the identifier is allocated, and in which file
    the identifier is merely being referred to. In the implementations of C for such systems, the appearance of the ex-
    tern keyword before an external definition indicates that storage for the identifiers being declared will be allocated
    in another file. Thus in a multi-file program, an external data definition without the extern specifier must appear
    in exactly one of the files. Any other files which wish to give an external definition for the identifier must include
    the extern in the definition. The identifier can be initialized only in the file where storage is allocated.
      In PDP-11 C none of this nonsense is necessary and the extern specifier is ignored in external definitions.
-



                                                                                                  C Reference Manual - 17


    12. Compiler control lines
       When a line of a C program begins with the character #, it is interpreted not by the compiler itself, but by a pre-
    processor which is capable of replacing instances of given identifiers with arbitrary token-strings and of inserting
    named files into the source program. In order to cause this preprocessor to be invoked, it is necessary that the very
    first line of the program begin with #. Since null lines are ignored by the preprocessor, this line need contain no oth-
    er information.

    12.1 Token replacement
      A compiler-control line of the form
             # define identifier token-string
    (note: no trailing semicolon) causes the preprocessor to replace subsequent instances of the identifier with the given
    string of tokens (except within compiler control lines). The replacement token-string has comments removed from
    it, and it is surrounded with blanks. No rescanning of the replacement string is attempted. This facility is most valu-
    able for definition of ‘‘manifest constants’’, as in
             # define tabsize 100
             ...
             int table[tabsize];

    12.2 File inclusion
       Large C programs often contain many external data definitions. Since the lexical scope of external definitions ex-
    tends to the end of the program file, it is good practice to put all the external definitions for data at the start of the
    program file, so that the functions defined within the file need not repeat tedious and error-prone declarations for
    each external identifier they use. It is also useful to put a heavily used structure definition at the start and use its
    structure tag to declare the auto pointers to the structure used within functions. To further exploit this technique
    when a large C program consists of several files, a compiler control line of the form
             # include "filename "
    results in the replacement of that line by the entire contents of the file filename.


       13. Implicit declarations
       It is not always necessary to specify both the storage class and the type of identifiers in a declaration. Sometimes
    the storage class is supplied by the context: in external definitions, and in declarations of formal parameters and
    structure members. In a declaration inside a function, if a storage class but no type is given, the identifier is assumed
    to be int; if a type but no storage class is indicated, the identifier is assumed to be auto. An exception to the latter
    rule is made for functions, since auto functions are meaningless (C being incapable of compiling code into the
    stack). If the type of an identifier is ‘‘function returning ...’’, it is implicitly declared to be extern.
       In an expression, an identifier followed by ( and not currently declared is contextually declared to be ‘‘function
    returning int’’.
      Undefined identifiers not followed by ( are assumed to be labels which will be defined later in the function.
    (Since a label is not an lvalue, this accounts for the ‘‘Lvalue required’’ error message sometimes noticed when an
    undeclared identifier is used.) Naturally, appearance of an identifier as a label declares it as such.
       For some purposes it is best to consider formal parameters as belonging to their own storage class. In practice, C
    treats parameters as if they were automatic (except that, as mentioned above, formal parameter arrays and floats
    are treated specially).

    14. Types revisited
      This section summarizes the operations which can be performed on objects of certain types.
-



    C Reference Manual - 18


    14.1 Structures
      There are only two things that can be done with a structure: pick out one of its members (by means of the . or
    −> operators); or take its address (by unary &). Other operations, such as assigning from or to it or passing it as a
    parameter, draw an error message. In the future, it is expected that these operations, but not necessarily others, will
    be allowed.

    14.2 Functions
      There are only two things that can be done with a function: call it, or take its address. If the name of a function
    appears in an expression not in the function-name position of a call, a pointer to the function is generated. Thus, to
    pass one function to another, one might say
             int f( );
             ...
             g( f );
    Then the definition of g might read
             g ( funcp )
             int (*funcp) ( );
             {
                    ...
                    (*funcp) ( );
                    ...
             }
    Notice that f was declared explicitly in the calling routine since its first appearance was not followed by ( .

    14.3 Arrays, pointers, and subscripting
       Every time an identifier of array type appears in an expression, it is converted into a pointer to the first member of
    the array. Because of this conversion, arrays are not lvalues. By definition, the subscript operator [ ] is interpreted
    in such a way that ‘‘E1[E2]’’ is identical to ‘‘*( ( E1) + (E2 ) )’’. Because of the conversion rules which apply to +, if
    E1 is an array and E2 an integer, then E1[E2] refers to the E2-th member of E1. Therefore, despite its asymmetric
    appearance, subscripting is a commutative operation.
       A consistent rule is followed in the case of multi-dimensional arrays. If E is an n -dimensional array of rank
    i × j × . . . ×k, then E appearing in an expression is converted to a pointer to an (n−1)-dimensional array with rank
    j × . . . ×k. If the * operator, either explicitly or implicitly as a result of subscripting, is applied to this pointer, the re-
    sult is the pointed-to (n−1)-dimensional array, which itself is immediately converted into a pointer.
      For example, consider
             int x[3][5];
    Here x is a 3×5 array of integers. When x appears in an expression, it is converted to a pointer to (the first of three)
    5-membered arrays of integers. In the expression ‘‘x[ i ]’’, which is equivalent to ‘‘*(x+i)’’, x is first converted to a
    pointer as described; then i is converted to the type of x, which involves multiplying i by the length the object to
    which the pointer points, namely 5 integer objects. The results are added and indirection applied to yield an array
    (of 5 integers) which in turn is converted to a pointer to the first of the integers. If there is another subscript the
    same argument applies again; this time the result is an integer.
       It follows from all this that arrays in C are stored row-wise (last subscript varies fastest) and that the first subscript
    in the declaration helps determine the amount of storage consumed by an array but plays no other part in subscript
    calculations.

    14.4 Labels
       Labels do not have a type of their own; they are treated as having type ‘‘array of int’’. Label variables should be
    declared ‘‘pointer to int’’; before execution of a goto referring to the variable, a label (or an expression deriving
    from a label) should be assigned to the variable.
      Label variables are a bad idea in general; the switch statement makes them almost always unnecessary.
-



                                                                                                C Reference Manual - 19


    15. Constant expressions
       In several places C requires expressions which evaluate to a constant: after case, as array bounds, and in ini-
    tializers. In the first two cases, the expression can involve only integer constants, character constants, and sizeof
    expressions, possibly connected by the binary operators
             + − * / % & | ˆ << >>
    or by the unary operators
             −
                 ˜
    Parentheses can be used for grouping, but not for function calls.
      A bit more latitude is permitted for initializers; besides constant expressions as discussed above, one can also ap-
    ply the unary & operator to external scalars, and to external arrays subscripted with a constant expression. The unary
    & can also be applied implicitly by appearance of unsubscripted external arrays. The rule here is that initializers
    must evaluate either to a constant or to the address of an external identifier plus or minus a constant.

    16. Examples.
      These examples are intended to illustrate some typical C constructions as well as a serviceable style of writing C
    programs.

    16.1 Inner product
      This function returns the inner product of its array arguments.
             double inner ( v1, v2, n )
             double v1 [ ] , v2 [ ] ;
             {
                   double sum ;
                   int i ;
                   sum = 0.0 ;
                   for ( i=0 ; i<n ; i++ )
                           sum =+ v1 [ i ] * v2 [ i ] ;
                   return ( sum ) ;
             }
    The following version is somewhat more efficient, but perhaps a little less clear. It uses the facts that parameter ar-
    rays are really pointers, and that all parameters are passed by value.
             double inner ( v1, v2, n )
             double *v1, *v2 ;
             {
                   double sum ;
                   sum = 0.0 ;
                   while ( n−− )
                          sum =+ *v1++              *   *v2++ ;
                   return ( sum ) ;
             }
    The declarations for the parameters are really exactly the same as in the last example. In the first case array declara-
    tions ‘‘ [ ] ’’ were given to emphasize that the parameters would be referred to as arrays; in the second, pointer dec-
    larations were given because the indirection operator and ++ were used.

    16.2 Tree and character processing
       Here is a complete C program ( courtesy of R. Haight ) which reads a document and produces an alphabetized list
    of words found therein together with the number of occurrences of each word. The method keeps a binary tree of
    words such that the left descendant tree for each word has all the words lexicographically smaller than the given
    word, and the right descendant has all the larger words. Both the insertion and the printing routine are recursive.
      The program calls the library routines getchar to pick up characters and exit to terminate execution. Printf is
-



    C Reference Manual - 20


    called to print the results according to a format string. A version of printf is given below ( §16.3 ) .
       Because all the external definitions for data are given at the top, no extern declarations are necessary within the
    functions. To stay within the rules, a type declaration is given for each non-integer function when the function is
    used before it is defined. However, since all such functions return pointers which are simply assigned to other point-
    ers, no actual harm would result from leaving out the declarations; the supposedly int function values would be as-
    signed without error or complaint.
             # define nwords 100                                      /* number of different words */
             # define wsize 20                                        /* max chars per word */
             struct tnode {                                           /* the basic structure */
                   char tword [ wsize ] ;
                   int count ;
                   struct tnode *left ;
                   struct tnode *right ;
             };
             struct tnode space [ nwords ] ;       /* the words themselves */
             int nnodes nwords ;                   /* number of remaining slots */
             struct tnode *spacep space ;          /* next available slot */
             struct tnode *freep ;                 /* free list */
             /*
               * The main routine reads words until end-of-file ( ´\0´ returned from "getchar" )
               * "tree" is called to sort each word into the tree.
               */
             main ( )
             {
                    struct tnode *top, *tree ( ) ;
                    char c, word [ wsize ] ;
                    int i ;
                      i = top = 0 ;
                      while ( c=getchar ( ) )
                            if ( ´a´<=c && c<=´z´ || ´A´<=c && c <=´Z´ ) {
                                     if ( i<wsize−1 )
                                            word [ i++ ] = c ;
                            } else
                                     if ( i ) {
                                            word [ i++ ] = ´\0´ ;
                                            top = tree ( top, word ) ;
                                            i = 0;
                                     }
                      tprint ( top ) ;
             }
             /*
               * The central routine. If the subtree pointer is null, allocate a new node for it.
               * If the new word and the node´s word are the same, increase the node´s count.
               * Otherwise, recursively sort the word into the left or right subtree according
               * as the argument word is less or greater than the node´s word.
               */
             struct tnode *tree ( p, word )
             struct tnode *p ;
             char word [ ] ;
             {
                    struct tnode *alloc ( ) ;
                    int cond ;
                      /* Is pointer null? */
                      if ( p==0 ) {
                            p = alloc ( ) ;
-



                                                             C Reference Manual - 21


                copy ( word, p−>tword ) ;
                p−>count = 1 ;
                p−>right = p−>left = 0 ;
                return ( p ) ;
          }
          /* Is word repeated? */
          if ( ( cond=compar ( p−>tword, word ) ) == 0 ) {
                 p−>count++ ;
                 return ( p ) ;
          }
          /* Sort into left or right */
          if ( cond<0 )
                 p−>left = tree ( p−>left, word ) ;
          else
                 p−>right = tree ( p−>right, word ) ;
          return ( p ) ;
    }
    /*
      * Print the tree by printing the left subtree, the given node, and the right subtree
      */
    tprint ( p )
    struct tnode *p ;
    {
           while ( p ) {
                 tprint ( p−>left ) ;
                 printf ( "%d: %s\n", p−>count, p−>tword ) ;
                 p = p−>right ;
           }
    }
    /*
      * String comparison: return number ( >, =, < ) 0
      * according as s1 ( >, =, < ) s2.
      */
    compar ( s1, s2 )
    char *s1, *s2 ;
    {
           int c1, c2 ;
          while ( ( c1 = *s1++ ) == ( c2 = *s2++ ) )
                 if ( c1==´\0´ )
                        return ( 0 ) ;
          return ( c2−c1 ) ;
    }
    /*
      * String copy: copy s1 into s2 until the null
      * character appears.
      */
    copy ( s1, s2 )
    char *s1, *s2 ;
    {
           while ( *s2++ = *s1++ ) ;
    }
    /*
      * Node allocation: return pointer to a free node.
      * Bomb out when all are gone. Just for fun, there
      * is a mechanism for using nodes that have been
      * freed, even though no one here calls "free."
      */
    struct tnode *alloc ( )
-



    C Reference Manual - 22


            {
                     struct tnode *t ;
                     if ( freep ) {
                            t = freep ;
                            freep = freep−>left ;
                            return ( t ) ;
                     }
                     if ( −−nnodes < 0 ) {
                            printf ( "Out of space\n" ) ;
                            exit ( ) ;
                     }
                     return ( spacep++ ) ;
            }
            /*
              * The uncalled routine which puts a node on the free list.
             */
            free ( p )
            struct tnode *p ;
            {
                   p−>left = freep ;
                   freep = p ;
            }
    To illustrate a slightly different technique of handling the same problem, we will repeat fragments of this example
    with the tree nodes treated explicitly as members of an array. The fundamental change is to deal with the subscript
    of the array member under discussion, instead of a pointer to it. The struct declaration becomes
            struct tnode {
                  char tword [ wsize ] ;
                  int count;
                  int left;
                  int right;
            };
    and alloc becomes
            alloc ( )
            {
                   int t;
                     t = −−nnodes;
                     if ( t<=0 ) {
                           printf ( "Out of space\n" ) ;
                           exit ( ) ;
                     }
                     return ( t ) ;
            }
    The free stuff has disappeared because if we deal with exclusively with subscripts some sort of map has to be kept,
    which is too much trouble.
      Now the tree routine returns a subscript also, and it becomes:
            tree ( p, word )
            char word [ ] ;
            {
                   int cond;
                     if ( p==0 ) {
                           p = alloc ( ) ;
                           copy ( word, space [ p ] .tword ) ;
-



                                                                                                      C Reference Manual - 23


                                 space [ p ] .count = 1;
                                 space [ p ] .right = space [ p ] .left = 0;
                                 return ( p ) ;
                       }
                       if ( ( cond=compar ( space [ p ] .tword, word ) ) == 0 ) {
                              space [ p ] .count++;
                              return ( p ) ;
                       }
                       if ( cond<0 )
                              space [ p ] .left = tree ( space [ p ] .left, word ) ;
                       else
                              space [ p ] .right = tree ( space [ p ] .right, word ) ;
                       return ( p ) ;
             }
    The other routines are changed similarly. It must be pointed out that this version is noticeably less efficient than the
    first because of the multiplications which must be done to compute an offset in space corresponding to the sub-
    scripts.
      The observation that subscripts ( like ‘‘a [ i ] ’’ ) are less efficient than pointer indirection ( like ‘‘*ap’’ ) holds true
    independently of whether or not structures are involved. There are of course many situations where subscripts are
    indispensable, and others where the loss in efficiency is worth a gain in clarity.

    16.3 Formatted output
       Here is a simplified version of the printf routine, which is available in the C library. It accepts a string ( character
    array ) as first argument, and prints subsequent arguments according to specifications contained in this format string.
    Most characters in the string are simply copied to the output; two-character sequences beginning with ‘‘%’’ specify
    that the next argument should be printed in a style as follows:
             %d        decimal number
             %o        octal number
             %c        ASCII character, or 2 characters if upper character is not null
             %s        string ( null-terminated array of characters )
             %f        floating-point number
    The actual parameters for each function call are laid out contiguously in increasing storage locations; therefore, a
    function with a variable number of arguments may take the address of ( say ) its first argument, and access the re-
    maining arguments by use of subscripting ( regarding the arguments as an array ) or by indirection combined with
    pointer incrementation.
       If in such a situation the arguments have mixed types, or if in general one wishes to insist that an lvalue should be
    treated as having a given type, then struct declarations like those illustrated below will be useful. It should be
    evident, though, that such techniques are implementation dependent.
      Printf depends as well on the fact that char and float arguments are widened respectively to int and dou-
    ble, so there are effectively only two sizes of arguments to deal with. Printf calls the library routines putchar to
    write out single characters and ftoa to dispose of floating-point numbers.
             printf ( fmt, args )
             char fmt [ ] ;
             {
                   char *s ;
                   struct { char **charpp ; };
                   struct { double *doublep ; };
                   int *ap, x, c ;
                       ap = &args ;                /* argument pointer */
                       for ( ; ; ) {
                             while ( ( c = *fmt++ ) != ´%´ ) {
                                    if ( c == ´\0´ )
                                           return ;
-



    C Reference Manual - 24


                                    putchar ( c ) ;
                              }
                              switch ( c = *fmt++ ) {
                              /* decimal */
                              case ´d ´:
                                    x = *ap++ ;
                                    if ( x < 0 ) {
                                             x = −x ;
                                             if ( x<0 ) { /* is − infinity */
                                                    printf ( "−32768" ) ;
                                                    continue ;
                                             }
                                             putchar ( ´−´ ) ;
                                    }
                                    printd ( x ) ;
                                    continue ;
                              /* octal */
                              case ´o´:
                                    printo ( *ap++ ) ;
                                    continue ;
                              /* float, double */
                              case ´f ´:
                                    /* let ftoa do the real work */
                                    ftoa ( *ap.doublep++ ) ;
                                    continue ;
                              /* character */
                              case ´c´:
                                    putchar ( *ap++ ) ;
                                    continue ;
                              /* string */
                              case ´s´:
                                    s = *ap.charpp++ ;
                                    while ( c = *s++ )
                                             putchar ( c ) ;
                                    continue ;
                              }
                              putchar ( c ) ;
                  }
           }
           /*
             * Print n in decimal ; n must be non-negative
             */
           printd ( n )
           {
                  int a ;
                  if ( a=n/10 )
                         printd ( a ) ;
                  putchar ( n%10 + ´0´ ) ;
           }
           /*
             * Print n in octal, with exactly 1 leading 0
             */
           printo ( n )
           {
                  if ( n )
                         printo ( ( n>>3 ) &017777 ) ;
                  putchar ( ( n&07 ) +´0´ ) ;
           }
-



                                                                                          C Reference Manual - 25




                                                    REFERENCES

    1.   Johnson, S. C., and Kernighan, B. W. ‘‘The Programming Language B.’’ Comp. Sci. Tech. Rep. #8., Bell Lab-
         oratories, 1972.
    2.   Ritchie, D. M., and Thompson, K. L. ‘‘The UNIX Time-sharing System.’’ C. ACM 7, 17, July, 1974, pp.
         365-375.
    3.   Peterson, T. G., and Lesk, M. E. ‘‘A User’s Guide to the C Language on the IBM 370.’’ Internal Memoran-
         dum, Bell Laboratories, 1974.
    4.   Thompson, K. L., and Ritchie, D. M. UNIX Programmer’s Manual. Bell Laboratories, 1973.
    5.   Lesk, M. E., and Barres, B. A. ‘‘The GCOS C Library.’’ Internal memorandum, Bell Laboratories, 1974.
    6.   Kernighan, B. W. ‘‘Programming in C− A Tutorial.’’ Unpublished internal memorandum, Bell Laboratories,
         1974.
-



    C Reference Manual - 26




                                                            APPENDIX 1
                                                           Syntax Summary

          1. Expressions.

                   expression:
                            primary
                            * expression
                            & expression
                            − expression
                            ! expression
                            ˜ expression
                            ++ lvalue
                            −− lvalue
                            lvalue ++
                            lvalue −−
                            sizeof expression
                            expression binop expression
                            expression ? expression : expression
                            lvalue asgnop expression
                            expression , expression
                   primary:
                                 identifier
                                 constant
                                 string
                                 ( expression )
                                 primary ( expression-listopt )
                                 primary [ expression ]
                                 lvalue . identifier
                                 primary > identifier
                   lvalue:
                                 identifier
                                 primary [ expression ]
                                 lvalue . identifier
                                 primary > identifier
                                 * expression
                                 ( lvalue )
          The primary-expression operators
                   ()     []          .        >
          have highest priority and group left-to-right. The unary operators
                      &      −     !               ++ −− sizeof
                                          ~
          have priority below the primary operators but higher than any binary operator, and group right-to-left. Bi-
          nary operators and the conditional operator all group left-to-right, and have priority decreasing as indicated:
                   binop:
                                 *        /         %
                                 +        −
                                 >>           <<
                                 <        >         <=     >=
                                 ==           !=
                                 &
-



                                                                                         C Reference Manual - 27


                       ^
                       |
                       &&
                       ||
                       ? :
    Assignment operators all have the same priority, and all group right-to-left.
             asgnop:
                       =   =+    =−    =*    =/      =%   =>>   =<<     =&    =^    =|
    The comma operator has the lowest priority, and groups left-to-right.
    2. Declarations.
             declaration:
                      decl-specifiers declarator-listopt ;
             decl-specifiers:
                      type-specifier
                      sc-specifier
                      type-specifier sc-specifier
                      sc-specifier type-specifier
             sc-specifier:
                      auto
                      static
                      extern
                      register
             type-specifier:
                      int
                      char
                      float
                      double
                      struct { type-decl-list }
                      struct identifier { type-decl-list }
                      struct identifier
             declarator-list:
                      declarator
                      declarator , declarator-list
             declarator:
                      identifier
                      * declarator
                      declarator ( )
                      declarator [ constant-expressionopt ]
                      ( declarator )
             type-decl-list:
                      type-declaration
                      type-declaration type-decl-list
             type-declaration:
                      type-specifier declarator-list ;

    3. Statements.
             statement:
                     expression ;
                     { statement-list }
-



    C Reference Manual - 28


                            if ( expression ) statement
                            if ( expression ) statement else statement
                            while ( expression ) statement
                            for ( expressionopt ; expressionopt ; expressionopt ) statement
                            switch ( expression ) statement
                            case constant-expression : statement
                            default : statement
                            break ;
                            continue ;
                            return ;
                            return ( expression ) ;
                            goto expression ;
                            identifier : statement
                            ;
                   statement-list:
                           statement
                           statement statement-list

          4. External definitions.
                   program:
                          external-definition
                          external-definition program
                   external-definition:
                            function-definition
                            data-definition
                   function-definition:
                            type-specifieropt function-declarator function-body
                   function-declarator:
                            declarator ( parameter-listopt )
                   parameter-list:
                           identifier
                           identifier , parameter-list
                   function-body:
                            type-decl-list function-statement
                   function-statement:
                            { declaration-listopt statement-list }
                   data-definition:
                            externopt type-specifieropt init-declarator-listopt ;
                   init-declarator-list:
                             init-declarator
                             init-declarator , init-declarator-list
                   init-declarator:
                             declarator initializeropt
                   initializer:
                             constant
                             { constant-expression-list }
-



                                                                      C Reference Manual - 29


            constant-expression-list:
                     constant-expression
                     constant-expression , constant-expression-list
            constant-expression:
                     expression
    5. Preprocessor
            # define identifier token-string
            # include "filename "
-



    C Reference Manual - 30




                                                       APPENDIX 2
                                                 Implementation Peculiarities


    This Appendix briefly summarizes the differences between the implementations of C on the PDP-11 under UNIX and
    on the HIS 6070 under GCOS; it includes some known bugs in each implementation. Each entry is keyed by an indi-
    cator as follows:

           h       hard to fix
           g       GCOS version should probably be changed
           u       UNIX version should probably be changed
           d       Inherent difference likely to remain

    This list was prepared by M. E. Lesk, S. C. Johnson, E. N. Pinson, and the author.


    A. Bugs or differences from C language specifications

    hg     A.1)           GCOS  does not do type conversions in ‘‘?:’’.
    hg     A.2)           GCOS   has a bug in int and real comparisons; the numbers are compared by subtraction, and
                          the difference must not overflow.
    g      A.3)           When x is a float, the construction ‘‘test ? −x : x’’ is illegal on GCOS.
    hg     A.4)           ‘‘p1−>p2 =+ 2’’ causes a compiler error, where p1 and p2 are pointers.
    u      A.5)           On UNIX, the expression in a return statement is not converted to the type of the function, as
                          promised.
    hug    A.6)           entry statement is not implemented at all.

    B. Implementation differences

    d      B.1)           Sizes of character constants differ; UNIX: 2, GCOS: 4.
    d      B.2)           Table sizes in compilers differ.
    d      B.3)           chars and ints have different sizes; chars are 8 bits on UNIX, 9 on GCOS; words are 16 bits
                          on UNIX and 36 on GCOS. There are corresponding differences in representations of floats
                          and doubles.
    d      B.4)           Character arrays stored left to right in a word in GCOS, right to left in UNIX.
    g      B.5)           Passing of floats and doubles differs; UNIX passes on stack, GCOS passes pointer (hidden to nor-
                          mal user).
    g      B.6)           Structures and strings are aligned on a word boundary in UNIX, not aligned in GCOS.
    g      B.7)           GCOS preprocessor supports #rename, #escape; UNIX has only #define, #include.
    u      B.8)           Preprocessor is not invoked on UNIX unless first character of file is ‘‘#’’.
    u      B.9)           The external definition ‘‘static int . . .’’ is legal on GCOS, but gets a diagnostic on UNIX. (On
                          GCOS it means an identifier global to the routines in the file but invisible to routines compiled
                          separately.)
    g      B.10)          A compound statement on GCOS must contain one ‘‘;’’ but on UNIX may be empty.
    g      B.11)          On GCOS case distinctions in identifiers and keywords are ignored; on UNIX case is significant
                          everywhere, with keywords in lower case.

    C. Syntax Differences

    g      C.1)           UNIX allows broader classes of initialization; on GCOS an initializer must be a constant, name,
                          or string. Similarly, GCOS is much stickier about wanting braces around initializers and in par-
                          ticular they must be present for array initialization.
    g      C.2)           ‘‘int extern’’ illegal on GCOS; must have ‘‘extern int’’ (storage class before type).
    g      C.3)           Externals on GCOS must have a type (not defaulted to int).
    u      C.4)           GCOS allows initialization of internal static (same syntax as for external definitions).
    g      C.5)           integer−>... is not allowed on GCOS.
    g      C.6)           Some operators on pointers are illegal on GCOS (<, >).
-



                                                                                              C Reference Manual - 31


    g     C.7)          register storage class means something on UNIX, but is not accepted on GCOS.
    g     C.8)          Scope holes: ‘‘int x; f ( ) {int x;}’’ is illegal on UNIX but defines two variables on GCOS.
    g     C.9)          When function names are used as arguments on UNIX, either ‘‘fname’’ or ‘‘&fname’’ may be
                        used to get a pointer to the function; on GCOS ‘‘&fname’’ generates a doubly-indirect pointer.
                        (Note that both are wrong since the ‘‘&’’ is supposed to be supplied for free.)

    D. Operating System Dependencies

    d     D.1)          GCOS  allocates external scalars by SYMREF; UNIX allocates external scalars as labelled com-
                        mon; as a result there may be many uninitialized external definitions of the same variable on
                        UNIX but only one on GCOS.
    d     D.2)          External names differ in allowable length and character set; on UNIX, 7 characters and both
                        cases; on GCOS 6 characters and only one case.

    E. Semantic Differences

    hg    E.1)          ‘‘int i, *p; p=i; i=p;’’ does nothing on UNIX, does something on GCOS (destroys right half of i) .
    d     E.2)          ‘‘>>’’ means arithmetic shift on UNIX, logical on GCOS.
    d     E.3)          When a char is converted to integer, the result is always positive on GCOS but can be negative
                        on UNIX.
    d     E.4)          Arguments of subroutines are evaluated left-to-right on GCOS, right-to-left on UNIX.
                                  Lint, a C Program Checker

                                            S. C. Johnson
                                         Bell Laboratories
                                   Murray Hill, New Jersey 07974



                                             ABSTRACT

               Lint is a command which examines C source programs, detecting a number of
        bugs and obscurities. It enforces the type rules of C more strictly than the C com-
        pilers. It may also be used to enforce a number of portability restrictions involved in
        moving programs between different machines and/or operating systems. Another
        option detects a number of wasteful, or error prone, constructions which nevertheless
        are, strictly speaking, legal.
              Lint accepts multiple input ﬁles and library speciﬁcations, and checks them for
        consistency.
              The separation of function between lint and the C compilers has both historical
        and practical rationale. The compilers turn C programs into executable ﬁles rapidly
        and efﬁciently. This is possible in part because the compilers do not do sophisticated
        type checking, especially between separately compiled programs. Lint takes a more
        global, leisurely view of the program, looking much more carefully at the compatibili-
        ties.
               This document discusses the use of lint , gives an overview of the implementa-
        tion, and gives some hints on the writing of machine independent C code.



July 26, 1978
                                   Lint, a C Program Checker

                                              S. C. Johnson
                                           Bell Laboratories
                                     Murray Hill, New Jersey 07974


Introduction and Usage
      Suppose there are two C1 source ﬁles, ﬁle1. c and ﬁle2.c , which are ordinarily compiled and
loaded together. Then the command
        lint ﬁle1.c ﬁle2.c
produces messages describing inconsistencies and inefﬁciencies in the programs. The program enforces
the typing rules of C more strictly than the C compilers (for both historical and practical reasons)
enforce them. The command
        lint – p ﬁle1.c ﬁle2.c
will produce, in addition to the above messages, additional messages which relate to the portability of
the programs to other operating systems and machines. Replacing the – p by – h will produce messages
about various error-prone or wasteful constructions which, strictly speaking, are not bugs. Saying – hp
gets the whole works.
       The next several sections describe the major messages; the document closes with sections discuss-
ing the implementation and giving suggestions for writing portable C. An appendix gives a summary of
the lint options.

A Word About Philosophy
      Many of the facts which lint needs may be impossible to discover. For example, whether a given
function in a program ever gets called may depend on the input data. Deciding whether exit is ever
called is equivalent to solving the famous ‘‘halting problem,’’ known to be recursively undecidable.
      Thus, most of the lint algorithms are a compromise. If a function is never mentioned, it can
never be called. If a function is mentioned, lint assumes it can be called; this is not necessarily so, but
in practice is quite reasonable.
       Lint tries to give information with a high degree of relevance. Messages of the form ‘‘xxx might
be a bug’’ are easy to generate, but are acceptable only in proportion to the fraction of real bugs they
uncover. If this fraction of real bugs is too small, the messages lose their credibility and serve merely to
clutter up the output, obscuring the more important messages.
     Keeping these issues in mind, we now consider in more detail the classes of messages which lint
produces.

Unused Variables and Functions
      As sets of programs evolve and develop, previously used variables and arguments to functions
may become unused; it is not uncommon for external variables, or even entire functions, to become
unnecessary, and yet not be removed from the source. These ‘‘errors of commission’’ rarely cause
working programs to fail, but they are a source of inefﬁciency, and make programs harder to understand
and change. Moreover, information about such unused variables and functions can occasionally serve to
discover bugs; if a function does a necessary job, and is never called, something is wrong!
      Lint complains about variables and functions which are deﬁned but not otherwise mentioned. An
exception is variables which are declared through explicit extern statements but are never referenced;
                                                   -2-


thus the statement
        extern ﬂoat sin( );
will evoke no comment if sin is never used. Note that this agrees with the semantics of the C compiler.
In some cases, these unused external declarations might be of some interest; they can be discovered by
adding the – x ﬂag to the lint invocation.
       Certain styles of programming require many functions to be written with similar interfaces; fre-
quently, some of the arguments may be unused in many of the calls. The – v option is available to
suppress the printing of complaints about unused arguments. When – v is in effect, no messages are
produced about unused arguments except for those arguments which are unused and also declared as
register arguments; this can be considered an active (and preventable) waste of the register resources of
the machine.
      There is one case where information about unused, or undeﬁned, variables is more distracting than
helpful. This is when lint is applied to some, but not all, ﬁles out of a collection which are to be loaded
together. In this case, many of the functions and variables deﬁned may not be used, and, conversely,
many functions and variables deﬁned elsewhere may be used. The – u ﬂag may be used to suppress the
spurious messages which might otherwise appear.

Set/Used Information
      Lint attempts to detect cases where a variable is used before it is set. This is very difﬁcult to do
well; many algorithms take a good deal of time and space, and still produce messages about perfectly
valid programs. Lint detects local variables (automatic and register storage classes) whose ﬁrst use
appears physically earlier in the input ﬁle than the ﬁrst assignment to the variable. It assumes that tak-
ing the address of a variable constitutes a ‘‘use,’’ since the actual use may occur at any later time, in a
data dependent fashion.
      The restriction to the physical appearance of variables in the ﬁle makes the algorithm very simple
and quick to implement, since the true ﬂow of control need not be discovered. It does mean that lint
can complain about some programs which are legal, but these programs would probably be considered
bad on stylistic grounds (e.g. might contain at least two goto’s). Because static and external variables
are initialized to 0, no meaningful information can be discovered about their uses. The algorithm deals
correctly, however, with initialized automatic variables, and variables which are used in the expression
which ﬁrst sets them.
      The set/used information also permits recognition of those local variables which are set and never
used; these form a frequent source of inefﬁciencies, and may also be symptomatic of bugs.

Flow of Control
      Lint attempts to detect unreachable portions of the programs which it processes. It will complain
about unlabeled statements immediately following goto, break, continue, or return statements. An
attempt is made to detect loops which can never be left at the bottom, detecting the special cases while(
1 ) and for(;;) as inﬁnite loops. Lint also complains about loops which cannot be entered at the top;
some valid programs may have such loops, but at best they are bad style, at worst bugs.
       Lint has an important area of blindness in the ﬂow of control algorithm: it has no way of detect-
ing functions which are called and never return. Thus, a call to exit may cause unreachable code which
lint does not detect; the most serious effects of this are in the determination of returned function values
(see the next section).
        One form of unreachable statement is not usually complained about by lint; a break statement
that cannot be reached causes no message. Programs generated by yacc ,2 and especially lex ,3 may have
literally hundreds of unreachable break statements. The – O ﬂag in the C compiler will often eliminate
the resulting object code inefﬁciency. Thus, these unreached statements are of little importance, there is
typically nothing the user can do about them, and the resulting messages would clutter up the lint out-
put. If these messages are desired, lint can be invoked with the – b option.
                                                    -3-


Function Values
      Sometimes functions return values which are never used; sometimes programs incorrectly use
function ‘‘values’’ which have never been returned. Lint addresses this problem in a number of ways.
      Locally, within a function deﬁnition, the appearance of both
         return( expr );
and
         return ;
statements is cause for alarm; lint will give the message
         function name contains return(e) and return
The most serious difﬁculty with this is detecting when a function return is implied by ﬂow of control
reaching the end of the function. This can be seen with a simple example:
         f(a){
                    if ( a ) return ( 3 );
                    g ( );
                    }
Notice that, if a tests false, f will call g and then return with no deﬁned return value; this will trigger a
complaint from lint . If g, like exit, never returns, the message will still be produced when in fact noth-
ing is wrong.
      In practice, some potentially serious bugs have been discovered by this feature; it also accounts for
a substantial fraction of the ‘‘noise’’ messages produced by lint .
      On a global scale, lint detects cases where a function returns a value, but this value is sometimes,
or always, unused. When the value is always unused, it may constitute an inefﬁciency in the function
deﬁnition. When the value is sometimes unused, it may represent bad style (e.g., not testing for error
conditions).
       The dual problem, using a function value when the function does not return one, is also detected.
This is a serious problem. Amazingly, this bug has been observed on a couple of occasions in ‘‘work-
ing’’ programs; the desired function value just happened to have been computed in the function return
register!

Type Checking
       Lint enforces the type checking rules of C more strictly than the compilers do. The additional
checking is in four major areas: across certain binary operators and implied assignments, at the structure
selection operators, between the deﬁnition and uses of functions, and in the use of enumerations.
      There are a number of operators which have an implied balancing between types of the operands.
The assignment, conditional ( ? : ), and relational operators have this property; the argument of a return
statement, and expressions used in initialization also suffer similar conversions. In these operations,
char, short, int, long, unsigned, ﬂoat, and double types may be freely intermixed. The types of
pointers must agree exactly, except that arrays of x’s can, of course, be intermixed with pointers to x’s.
      The type checking rules also require that, in structure references, the left operand of the —> be a
pointer to structure, the left operand of the . be a structure, and the right operand of these operators be a
member of the structure implied by the left operand. Similar checking is done for references to unions.
      Strict rules apply to function argument and return value matching. The types ﬂoat and double
may be freely matched, as may the types char, short, int, and unsigned. Also, pointers can be matched
with the associated arrays. Aside from this, all actual arguments must agree in type with their declared
counterparts.
      With enumerations, checks are made that enumeration variables or members are not mixed with
other types, or other enumerations, and that the only operations applied are =, initialization, ==, !=, and
                                                   -4-


function arguments and return values.

Type Casts
     The type cast feature in C was introduced largely as an aid to producing more portable programs.
Consider the assignment
        p=1;
where p is a character pointer. Lint will quite rightly complain. Now, consider the assignment
        p = (char ∗)1 ;
in which a cast has been used to convert the integer to a character pointer. The programmer obviously
had a strong motivation for doing this, and has clearly signaled his intentions. It seems harsh for lint to
continue to complain about this. On the other hand, if this code is moved to another machine, such
code should be looked at carefully. The – c ﬂag controls the printing of comments about casts. When
– c is in effect, casts are treated as though they were assignments subject to complaint; otherwise, all
legal casts are passed without comment, no matter how strange the type mixing seems to be.

Nonportable Character Use
      On the PDP-11, characters are signed quantities, with a range from – 128 to 127. On most of the
other C implementations, characters take on only positive values. Thus, lint will ﬂag certain comparis-
ons and assignments as being illegal or nonportable. For example, the fragment
        char c;
                  ...
        if( (c = getchar( )) < 0 ) ....
works on the PDP-11, but will fail on machines where characters always take on positive values. The
real solution is to declare c an integer, since getchar is actually returning integer values. In any case,
lint will say ‘‘nonportable character comparison’’.
      A similar issue arises with bitﬁelds; when assignments of constant values are made to bitﬁelds, the
ﬁeld may be too small to hold the value. This is especially true because on some machines bitﬁelds are
considered as signed quantities. While it may seem unintuitive to consider that a two bit ﬁeld declared
of type int cannot hold the value 3, the problem disappears if the bitﬁeld is declared to have type
unsigned.

Assignments of longs to ints
       Bugs may arise from the assignment of long to an int, which loses accuracy. This may happen in
programs which have been incompletely converted to use typedefs. When a typedef variable is changed
from int to long, the program can stop working because some intermediate results may be assigned to
ints, losing accuracy. Since there are a number of legitimate reasons for assigning longs to ints, the
detection of these assignments is enabled by the – a ﬂag.

Strange Constructions
      Several perfectly legal, but somewhat strange, constructions are ﬂagged by lint; the messages
hopefully encourage better code quality, clearer style, and may even point out bugs. The – h ﬂag is used
to enable these checks. For example, in the statement
        ∗p++ ;
the ∗ does nothing; this provokes the message ‘‘null effect’’ from lint . The program fragment
        unsigned x ;
        if( x < 0 ) ...
is clearly somewhat strange; the test will never succeed. Similarly, the test
                                                    -5-


         if( x > 0 ) ...
is equivalent to
         if( x != 0 )
which may not be the intended action. Lint will say ‘‘degenerate unsigned comparison’’ in these cases.
If one says
         if( 1 != 0 ) ....
lint will report ‘‘constant in conditional context’’, since the comparison of 1 with 0 gives a constant
result.
     Another construction detected by lint involves operator precedence. Bugs which arise from
misunderstandings about the precedence of operators can be accentuated by spacing and formatting,
making such bugs extremely hard to ﬁnd. For example, the statements
         if( x&077 == 0 ) ...
or
         x< + 40
          <2
probably do not do what was intended. The best solution is to parenthesize such expressions, and lint
encourages this by an appropriate message.
      Finally, when the – h ﬂag is in force lint complains about variables which are redeclared in inner
blocks in a way that conﬂicts with their use in outer blocks. This is legal, but is considered by many
(including the author) to be bad style, usually unnecessary, and frequently a bug.

Ancient History
      There are several forms of older syntax which are being ofﬁcially discouraged. These fall into
two classes, assignment operators and initialization.
      The older forms of assignment operators (e.g., =+, =– , . . . ) could cause ambiguous expressions,
such as
         a =– 1 ;
which could be taken as either
         a =– 1 ;
or
         a = –1 ;
The situation is especially perplexing if this kind of ambiguity arises as the result of a macro substitu-
tion. The newer, and preferred operators (+=, – =, etc. ) have no such ambiguities. To spur the aban-
donment of the older forms, lint complains about these old fashioned operators.
      A similar issue arises with initialization. The older language allowed
         int x 1 ;
to initialize x to 1. This also caused syntactic difﬁculties: for example,
         int x ( – 1 ) ;
looks somewhat like the beginning of a function declaration:
         int x ( y ) { . . .
and the compiler must read a fair ways past x in order to sure what the declaration really is.. Again, the
problem is even more perplexing when the initializer involves a macro. The current syntax places an
equals sign between the variable and the initializer:
                                                    -6-


        int x = – 1 ;
This is free of any possible syntactic ambiguity.

Pointer Alignment
       Certain pointer assignments may be reasonable on some machines, and illegal on others, due
entirely to alignment restrictions. For example, on the PDP-11, it is reasonable to assign integer
pointers to double pointers, since double precision values may begin on any integer boundary. On the
Honeywell 6000, double precision values must begin on even word boundaries; thus, not all such assign-
ments make sense. Lint tries to detect cases where pointers are assigned to other pointers, and such
alignment problems might arise. The message ‘‘possible pointer alignment problem’’ results from this
situation whenever either the – p or – h ﬂags are in effect.

Multiple Uses and Side Effects
      In complicated expressions, the best order in which to evaluate subexpressions may be highly
machine dependent. For example, on machines (like the PDP-11) in which the stack runs backwards,
function arguments will probably be best evaluated from right-to-left; on machines with a stack running
forward, left-to-right seems most attractive. Function calls embedded as arguments of other functions
may or may not be treated similarly to ordinary arguments. Similar issues arise with other operators
which have side effects, such as the assignment operators and the increment and decrement operators.
      In order that the efﬁciency of C on a particular machine not be unduly compromised, the C
language leaves the order of evaluation of complicated expressions up to the local compiler, and, in fact,
the various C compilers have considerable differences in the order in which they will evaluate compli-
cated expressions. In particular, if any variable is changed by a side effect, and also used elsewhere in
the same expression, the result is explicitly undeﬁned.
       Lint checks for the important special case where a simple scalar variable is affected. For exam-
ple, the statement
        a[i ] = b[i++] ;
will draw the complaint:
        warning: i evaluation order undeﬁned

Implementation
       Lint consists of two programs and a driver. The ﬁrst program is a version of the Portable C Com-
piler45 which is the basis of the IBM 370, Honeywell 6000, and Interdata 8/32 C compilers. This com-
piler does lexical and syntax analysis on the input text, constructs and maintains symbol tables, and
builds trees for expressions. Instead of writing an intermediate ﬁle which is passed to a code generator,
as the other compilers do, lint produces an intermediate ﬁle which consists of lines of ascii text. Each
line contains an external variable name, an encoding of the context in which it was seen (use, deﬁnition,
declaration, etc.), a type speciﬁer, and a source ﬁle name and line number. The information about vari-
ables local to a function or ﬁle is collected by accessing the symbol table, and examining the expression
trees.
       Comments about local problems are produced as detected. The information about external names
is collected onto an intermediate ﬁle. After all the source ﬁles and library descriptions have been col-
lected, the intermediate ﬁle is sorted to bring all information collected about a given external name
together. The second, rather small, program then reads the lines from the intermediate ﬁle and compares
all of the deﬁnitions, declarations, and uses for consistency.
      The driver controls this process, and is also responsible for making the options available to both
passes of lint .
                                                  -7-


Portability
        C on the Honeywell and IBM systems is used, in part, to write system code for the host operating
system. This means that the implementation of C tends to follow local conventions rather than adhere
strictly to UNIX† system conventions. Despite these differences, many C programs have been success-
fully moved to GCOS and the various IBM installations with little effort. This section describes some
of the differences between the implementations, and discusses the lint features which encourage porta-
bility.
     Uninitialized external variables are treated differently in different implementations of C. Suppose
two ﬁles both contain a declaration without initialization, such as
          int a ;
outside of any function. The UNIX loader will resolve these declarations, and cause only a single word
of storage to be set aside for a. Under the GCOS and IBM implementations, this is not feasible (for
various stupid reasons!) so each such declaration causes a word of storage to be set aside and called a.
When loading or library editing takes place, this causes fatal conﬂicts which prevent the proper opera-
tion of the program. If lint is invoked with the – p ﬂag, it will detect such multiple deﬁnitions.
       A related difﬁculty comes from the amount of information retained about external names during
the loading process. On the UNIX system, externally known names have seven signiﬁcant characters,
with the upper/lower case distinction kept. On the IBM systems, there are eight signiﬁcant characters,
but the case distinction is lost. On GCOS, there are only six characters, of a single case. This leads to
situations where programs run on the UNIX system, but encounter loader problems on the IBM or GCOS
systems. Lint – p causes all external symbols to be mapped to one case and truncated to six characters,
providing a worst-case analysis.
       A number of differences arise in the area of character handling: characters in the UNIX system are
eight bit ascii, while they are eight bit ebcdic on the IBM, and nine bit ascii on GCOS. Moreover, char-
acter strings go from high to low bit positions (‘‘left to right’’) on GCOS and IBM, and low to high
(‘‘right to left’’) on the PDP-11. This means that code attempting to construct strings out of character
constants, or attempting to use characters as indices into arrays, must be looked at with great suspicion.
Lint is of little help here, except to ﬂag multi-character character constants.
      Of course, the word sizes are different! This causes less trouble than might be expected, at least
when moving from the UNIX system (16 bit words) to the IBM (32 bits) or GCOS (36 bits). The main
problems are likely to arise in shifting or masking. C now supports a bit-ﬁeld facility, which can be
used to write much of this code in a reasonably portable way. Frequently, portability of such code can
be enhanced by slight rearrangements in coding style. Many of the incompatibilities seem to have the
ﬂavor of writing
          x &= 0177700 ;
to clear the low order six bits of x. This sufﬁces on the PDP-11, but fails badly on GCOS and IBM. If
the bit ﬁeld feature cannot be used, the same effect can be obtained by writing
          x &= ∼ 077 ;
which will work on all these machines.
       The right shift operator is arithmetic shift on the PDP-11, and logical shift on most other
machines. To obtain a logical shift on all machines, the left operand can be typed unsigned. Characters
are considered signed integers on the PDP-11, and unsigned on the other machines. This persistence of
the sign bit may be reasonably considered a bug in the PDP-11 hardware which has inﬁltrated itself into
the C language. If there were a good way to discover the programs which would be affected, C could
be changed; in any case, lint is no help here.
      The above discussion may have made the problem of portability seem bigger than it in fact is.
The issues involved here are rarely subtle or mysterious, at least to the implementor of the program,
__________________
†UNIX is a Trademark of Bell Laboratories.
                                                     -8-


although they can involve some work to straighten out. The most serious bar to the portability of UNIX
system utilities has been the inability to mimic essential UNIX system functions on the other systems.
The inability to seek to a random character position in a text ﬁle, or to establish a pipe between
processes, has involved far more rewriting and debugging than any of the differences in C compilers.
On the other hand, lint has been very helpful in moving the UNIX operating system and associated utility
programs to other machines.

Shutting Lint Up
       There are occasions when the programmer is smarter than lint . There may be valid reasons for
‘‘illegal’’ type casts, functions with a variable number of arguments, etc. Moreover, as speciﬁed above,
the ﬂow of control information produced by lint often has blind spots, causing occasional spurious mes-
sages about perfectly reasonable programs. Thus, some way of communicating with lint , typically to
shut it up, is desirable.
       The form which this mechanism should take is not at all clear. New keywords would require
current and old compilers to recognize these keywords, if only to ignore them. This has both philosoph-
ical and practical problems. New preprocessor syntax suffers from similar problems.
      What was ﬁnally done was to cause a number of words to be recognized by lint when they were
embedded in comments. This required minimal preprocessor changes; the preprocessor just had to agree
to pass comments through to its output, instead of deleting them as had been previously done. Thus,
lint directives are invisible to the compilers, and the effect on systems with the older preprocessors is
merely that the lint directives don’t work.
     The ﬁrst directive is concerned with ﬂow of control information; if a particular place in the pro-
gram cannot be reached, but this is not apparent to lint , this can be asserted by the directive
         /* NOTREACHED */
at the appropriate spot in the program. Similarly, if it is desired to turn off strict type checking for the
next expression, the directive
         /* NOSTRICT */
can be used; the situation reverts to the previous default after the next expression. The – v ﬂag can be
turned on for one function by the directive
         /* ARGSUSED */
Complaints about variable number of arguments in calls to a function can be turned off by the directive
         /* VARARGS */
preceding the function deﬁnition. In some cases, it is desirable to check the ﬁrst several arguments, and
leave the later arguments unchecked. This can be done by following the VARARGS keyword immedi-
ately with a digit giving the number of arguments which should be checked; thus,
         /* VARARGS2 */
will cause the ﬁrst two arguments to be checked, the others unchecked. Finally, the directive
         /* LINTLIBRARY */
at the head of a ﬁle identiﬁes this ﬁle as a library declaration ﬁle; this topic is worth a section by itself.

Library Declaration Files
      Lint accepts certain library directives, such as
         – ly
and tests the source ﬁles for compatibility with these libraries. This is done by accessing library
description ﬁles whose names are constructed from the library directives. These ﬁles all begin with the
directive
                                                   -9-


        /* LINTLIBRARY */
which is followed by a series of dummy function deﬁnitions. The critical parts of these deﬁnitions are
the declaration of the function return type, whether the dummy function returns a value, and the number
and types of arguments to the function. The VARARGS and ARGSUSED directives can be used to
specify features of the library functions.
       Lint library ﬁles are processed almost exactly like ordinary source ﬁles. The only difference is
that functions which are deﬁned on a library ﬁle, but are not used on a source ﬁle, draw no complaints.
Lint does not simulate a full library search algorithm, and complains if the source ﬁles contain a
redeﬁnition of a library routine (this is a feature!).
      By default, lint checks the programs it is given against a standard library ﬁle, which contains
descriptions of the programs which are normally loaded when a C program is run. When the -p ﬂag is
in effect, another ﬁle is checked containing descriptions of the standard I/O library routines which are
expected to be portable across various machines. The -n ﬂag can be used to suppress all library check-
ing.

Bugs, etc.
      Lint was a difﬁcult program to write, partially because it is closely connected with matters of pro-
gramming style, and partially because users usually don’t notice bugs which cause lint to miss errors
which it should have caught. (By contrast, if lint incorrectly complains about something that is correct,
the programmer reports that immediately!)
      A number of areas remain to be further developed. The checking of structures and arrays is rather
inadequate; size incompatibilities go unchecked, and no attempt is made to match up structure and union
declarations across ﬁles. Some stricter checking of the use of the typedef is clearly desirable, but what
checking is appropriate, and how to carry it out, is still to be determined.
      Lint shares the preprocessor with the C compiler. At some point it may be appropriate for a spe-
cial version of the preprocessor to be constructed which checks for things such as unused macro
deﬁnitions, macro arguments which have side effects which are not expanded at all, or are expanded
more than once, etc.
      The central problem with lint is the packaging of the information which it collects. There are
many options which serve only to turn off, or slightly modify, certain features. There are pressures to
add even more of these options.
       In conclusion, it appears that the general notion of having two programs is a good one. The com-
piler concentrates on quickly and accurately turning the program text into bits which can be run; lint
concentrates on issues of portability, style, and efﬁciency. Lint can afford to be wrong, since incorrect-
ness and over-conservatism are merely annoying, not fatal. The compiler can be fast since it knows that
lint will cover its ﬂanks. Finally, the programmer can concentrate at one stage of the programming pro-
cess solely on the algorithms, data structures, and correctness of the program, and then later retroﬁt, with
the aid of lint , the desirable properties of universality and portability.
                                              - 10 -


References
1.   B. W. Kernighan and D. M. Ritchie, The C Programming Language, Prentice-Hall, Englewood
     Cliffs, New Jersey (1978).
2.   S. C. Johnson, ‘‘Yacc — Yet Another Compiler-Compiler,’’ Comp. Sci. Tech. Rep. No. 32, Bell
     Laboratories, Murray Hill, New Jersey (July 1975).
3.   M. E. Lesk, ‘‘Lex — A Lexical Analyzer Generator,’’ Comp. Sci. Tech. Rep. No. 39, Bell
     Laboratories, Murray Hill, New Jersey (October 1975).
4.   S. C. Johnson and D. M. Ritchie, ‘‘UNIX Time-Sharing System: Portability of C Programs and the
     UNIX System,’’ Bell Sys. Tech. J. 57(6), pp.2021-2048 (1978).
5.   S. C. Johnson, ‘‘A Portable Compiler: Theory and Practice,’’ Proc. 5th ACM Symp. on Principles
     of Programming Languages, pp.97-104 (January 1978).
                                                      - 11 -


Appendix: Current Lint Options
     The command currently has the form
        lint [– options ] ﬁles... library-descriptors...
The options are
h    Perform heuristic checks
p    Perform portability checks
v    Don’t report unused arguments
u    Don’t report unused or undeﬁned externals
b    Report unreachable break statements.
x    Report unused external declarations
a    Report assignments of long to int or shorter.
c    Complain about questionable casts
n    No library checking is done
s    Same as h (for historical reasons)
             Make — A Program for Maintaining Computer Programs

                                            S. I. Feldman
                                         Bell Laboratories
                                   Murray Hill, New Jersey 07974



                                             ABSTRACT

             In a programming project, it is easy to lose track of which ﬁles need to be repro-
       cessed or recompiled after a change is made in some part of the source. Make pro-
       vides a simple mechanism for maintaining up-to-date versions of programs that result
       from many operations on a number of ﬁles. It is possible to tell Make the sequence of
       commands that create certain ﬁles, and the list of ﬁles that require other ﬁles to be
       current before the operations can be done. Whenever a change is made in any part of
       the program, the Make command will create the proper ﬁles simply, correctly, and
       with a minimum amount of effort.
             The basic operation of Make is to ﬁnd the name of a needed target in the
       description, ensure that all of the ﬁles on which it depends exist and are up to date,
       and then create the target if it has not been modiﬁed since its generators were. The
       description ﬁle really deﬁnes the graph of dependencies; Make does a depth-ﬁrst
       search of this graph to determine what work is really necessary.
              Make also provides a simple macro substitution facility and the ability to encap-
       sulate commands in a single ﬁle for convenient administration.



August 15, 1978
               Make — A Program for Maintaining Computer Programs

                                              S. I. Feldman
                                           Bell Laboratories
                                     Murray Hill, New Jersey 07974


Introduction
       It is common practice to divide large programs into smaller, more manageable pieces. The pieces
may require quite different treatments: some may need to be run through a macro processor, some may
need to be processed by a sophisticated program generator (e.g., Yacc[1] or Lex[2]). The outputs of
these generators may then have to be compiled with special options and with certain deﬁnitions and
declarations. The code resulting from these transformations may then need to be loaded together with
certain libraries under the control of special options. Related maintenance activities involve running
complicated test scripts and installing validated modules. Unfortunately, it is very easy for a program-
mer to forget which ﬁles depend on which others, which ﬁles have been modiﬁed recently, and the exact
sequence of operations needed to make or exercise a new version of the program. After a long editing
session, one may easily lose track of which ﬁles have been changed and which object modules are still
valid, since a change to a declaration can obsolete a dozen other ﬁles. Forgetting to compile a routine
that has been changed or that uses changed declarations will result in a program that will not work, and
a bug that can be very hard to track down. On the other hand, recompiling everything in sight just to be
safe is very wasteful.
       The program described in this report mechanizes many of the activities of program development
and maintenance. If the information on inter-ﬁle dependences and command sequences is stored in a
ﬁle, the simple command
        make
is frequently sufﬁcient to update the interesting ﬁles, regardless of the number that have been edited
since the last ‘‘make’’. In most cases, the description ﬁle is easy to write and changes infrequently. It
is usually easier to type the make command than to issue even one of the needed operations, so the typi-
cal cycle of program development operations becomes
        think — edit — make — test . . .

      Make is most useful for medium-sized programming projects; it does not solve the problems of
maintaining multiple source versions or of describing huge programs. Make was designed for use on
Unix, but a version runs on GCOS.

Basic Features
     The basic operation of make is to update a target ﬁle by ensuring that all of the ﬁles on which it
depends exist and are up to date, then creating the target if it has not been modiﬁed since its dependents
were. Make does a depth-ﬁrst search of the graph of dependences. The operation of the command
depends on the ability to ﬁnd the date and time that a ﬁle was last modiﬁed.
      To illustrate, let us consider a simple example: A program named prog is made by compiling and
loading three C-language ﬁles x.c, y.c, and z.c with the lS library. By convention, the output of the C
compilations will be found in ﬁles named x.o, y.o, and z.o. Assume that the ﬁles x.c and y.c share
some declarations in a ﬁle named defs, but that z.c does not. That is, x.c and y.c have the line
        #include "defs"
The following text describes the relationships and operations:
                                                  -2-


        prog : x.o y.o z.o
                cc x.o y.o z.o – lS – o prog
        x.o y.o : defs
If this information were stored in a ﬁle named makeﬁle, the command
        make
would perform the operations needed to recreate prog after any changes had been made to any of the
four source ﬁles x.c, y.c, z.c, or defs.
       Make operates using three sources of information: a user-supplied description ﬁle (as above), ﬁle
names and ‘‘last-modiﬁed’’ times from the ﬁle system, and built-in rules to bridge some of the gaps. In
our example, the ﬁrst line says that prog depends on three ‘‘.o’’ ﬁles. Once these object ﬁles are
current, the second line describes how to load them to create prog. The third line says that x.o and y.o
depend on the ﬁle defs. From the ﬁle system, make discovers that there are three ‘‘.c’’ ﬁles correspond-
ing to the needed ‘‘.o’’ ﬁles, and uses built-in information on how to generate an object from a source
ﬁle (i.e., issue a ‘‘cc – c’’ command).
     The following long-winded description ﬁle is equivalent to the one above, but takes no advantage
of make’s innate knowledge:
        prog : x.o y.o z.o
                cc x.o y.o z.o – lS – o prog
        x.o : x.c defs
                  cc – c x.c
        y.o : y.c defs
                  cc – c y.c
        z.o : z.c
                  cc – c z.c

     If none of the source or object ﬁles had changed since the last time prog was made, all of the ﬁles
would be current, and the command
        make
would just announce this fact and stop. If, however, the defs ﬁle had been edited, x.c and y.c (but not
z.c) would be recompiled, and then prog would be created from the new ‘‘.o’’ ﬁles. If only the ﬁle y.c
had changed, only it would be recompiled, but it would still be necessary to reload prog.
       If no target name is given on the make command line, the ﬁrst target mentioned in the description
is created; otherwise the speciﬁed targets are made. The command
        make x.o
would recompile x.o if x.c or defs had changed.
       If the ﬁle exists after the commands are executed, its time of last modiﬁcation is used in further
decisions; otherwise the current time is used. It is often quite useful to include rules with mnemonic
names and commands that do not actually produce a ﬁle with that name. These entries can take advan-
tage of make’s ability to generate ﬁles and substitute macros. Thus, an entry ‘‘save’’ might be included
to copy a certain set of ﬁles, or an entry ‘‘cleanup’’ might be used to throw away unneeded intermediate
ﬁles. In other cases one may maintain a zero-length ﬁle purely to keep track of the time at which cer-
tain actions were performed. This technique is useful for maintaining remote archives and listings.
      Make has a simple macro mechanism for substituting in dependency lines and command strings.
Macros are deﬁned by command arguments or description ﬁle lines with embedded equal signs. A
macro is invoked by preceding the name by a dollar sign; macro names longer than one character must
be parenthesized. The name of the macro is either the single character after the dollar sign or a name
inside parentheses. The following are valid macro invocations:
                                                       -3-


          $(CFLAGS)
          $2
          $(xy)
          $Z
          $(Z)
The last two invocations are identical. $$ is a dollar sign. All of these macros are assigned values dur-
ing input, as shown below. Four special macros change values during the execution of the command:
$∗, $@, $?, and $<. They will be discussed later. The following fragment shows the use:
          OBJECTS = x.o y.o z.o
          LIBES = – lS
          prog: $(OBJECTS)
                  cc $(OBJECTS) $(LIBES) – o prog
           ...
The command
          make
loads the three object ﬁles with the lS library. The command
          make "LIBES= – ll – lS"
loads them with both the Lex (‘‘– ll’’) and the Standard (‘‘– lS’’) libraries, since macro deﬁnitions on the
command line override deﬁnitions in the description. (It is necessary to quote arguments with embedded
blanks in UNIX† commands.)
      The following sections detail the form of description ﬁles and the command line, and discuss
options and built-in rules in more detail.

Description Files and Substitutions
      A description ﬁle contains three types of information: macro deﬁnitions, dependency information,
and executable commands. There is also a comment convention: all characters after a sharp (#) are
ignored, as is the sharp itself. Blank lines and lines beginning with a sharp are totally ignored. If a
non-comment line is too long, it can be continued using a backslash. If the last character of a line is a
backslash, the backslash, newline, and following blanks and tabs are replaced by a single blank.
       A macro deﬁnition is a line containing an equal sign not preceded by a colon or a tab. The name
(string of letters and digits) to the left of the equal sign (trailing blanks and tabs are stripped) is assigned
the string of characters following the equal sign (leading blanks and tabs are stripped.) The following
are valid macro deﬁnitions:
          2 = xyz
          abc = – ll – ly – lS
          LIBES =
The last deﬁnition assigns LIBES the null string. A macro that is never explicitly deﬁned has the null
string as value. Macro deﬁnitions may also appear on the make command line (see below).
       Other lines give information about target ﬁles. The general form of an entry is:
          target1 [target2 . . .] :[:] [dependent1 . . .] [; commands] [# . . .]
          [(tab) commands] [# . . .]
           ...
Items inside brackets may be omitted. Targets and dependents are strings of letters, digits, periods, and
slashes. (Shell metacharacters ‘‘∗’’ and ‘‘?’’ are expanded.) A command is any string of characters not
including a sharp (except in quotes) or newline. Commands may appear either after a semicolon on a
__________________
†UNIX is a Trademark of Bell Laboratories.
                                                   -4-


dependency line or on lines beginning with a tab immediately following a dependency line.
     A dependency line may have either a single or a double colon. A target name may appear on
more than one dependency line, but all of those lines must be of the same (single or double colon) type.
1.    For the usual single-colon case, at most one of these dependency lines may have a command
      sequence associated with it. If the target is out of date with any of the dependents on any of the
      lines, and a command sequence is speciﬁed (even a null one following a semicolon or tab), it is
      executed; otherwise a default creation rule may be invoked.
2.    In the double-colon case, a command sequence may be associated with each dependency line; if
      the target is out of date with any of the ﬁles on a particular line, the associated commands are
      executed. A built-in rule may also be executed. This detailed form is of particular value in updat-
      ing archive-type ﬁles.
       If a target must be created, the sequence of commands is executed. Normally, each command line
is printed and then passed to a separate invocation of the Shell after substituting for macros. (The print-
ing is suppressed in silent mode or if the command line begins with an @ sign). Make normally stops
if any command signals an error by returning a non-zero error code. (Errors are ignored if the ‘‘– i’’
ﬂags has been speciﬁed on the make command line, if the fake target name ‘‘.IGNORE’’ appears in the
description ﬁle, or if the command string in the description ﬁle begins with a hyphen. Some UNIX com-
mands return meaningless status). Because each command line is passed to a separate invocation of the
Shell, care must be taken with certain commands (e.g., cd and Shell control commands) that have mean-
ing only within a single Shell process; the results are forgotten before the next line is executed.
      Before issuing any command, certain macros are set. $@ is set to the name of the ﬁle to be
‘‘made’’. $? is set to the string of names that were found to be younger than the target. If the com-
mand was generated by an implicit rule (see below), $< is the name of the related ﬁle that caused the
action, and $∗ is the preﬁx shared by the current and the dependent ﬁle names.
       If a ﬁle must be made but there are no explicit commands or relevant built-in rules, the commands
associated with the name ‘‘.DEFAULT’’ are used. If there is no such name, make prints a message and
stops.

Command Usage
     The make command takes four kinds of arguments: macro deﬁnitions, ﬂags, description ﬁle
names, and target ﬁle names.
        make [ ﬂags ] [ macro deﬁnitions ] [ targets ]
The following summary of the operation of the command explains how these arguments are interpreted.
      First, all macro deﬁnition arguments (arguments with embedded equal signs) are analyzed and the
assignments made. Command-line macros override corresponding deﬁnitions found in the description
ﬁles.
      Next, the ﬂag arguments are examined. The permissible ﬂags are
–i    Ignore error codes returned by invoked commands. This mode is entered if the fake target name
      ‘‘.IGNORE’’ appears in the description ﬁle.
–s    Silent mode. Do not print command lines before executing. This mode is also entered if the fake
      target name ‘‘.SILENT’’ appears in the description ﬁle.
–r    Do not use the built-in rules.
–n    No execute mode. Print commands, but do not execute them. Even lines beginning with an ‘‘@’’
      sign are printed.
–t    Touch the target ﬁles (causing them to be up to date) rather than issue the usual commands.
–q    Question. The make command returns a zero or non-zero status code depending on whether the
      target ﬁle is or is not up to date.
                                                       -5-


–p    Print out the complete set of macro deﬁnitions and target descriptions
–d    Debug mode. Print out detailed information on ﬁles and times examined.
–f    Description ﬁle name. The next argument is assumed to be the name of a description ﬁle. A ﬁle
      name of ‘‘– ’’ denotes the standard input. If there are no ‘‘– f ’’ arguments, the ﬁle named
      makeﬁle or Makeﬁle in the current directory is read. The contents of the description ﬁles override
      the built-in rules if they are present).
      Finally, the remaining arguments are assumed to be the names of targets to be made; they are
done in left to right order. If there are no such arguments, the ﬁrst name in the description ﬁles that
does not begin with a period is ‘‘made’’.

Implicit Rules
      The make program uses a table of interesting sufﬁxes and a set of transformation rules to supply
default dependency information and implied commands. (The Appendix describes these tables and
means of overriding them.) The default sufﬁx list is:

        .o                        Object ﬁle
        .c                        C source ﬁle
        .e                        Eﬂ source ﬁle
        .r                        Ratfor source ﬁle
        .f                        Fortran source ﬁle
        .s                        Assembler source ﬁle
        .y                        Yacc-C source grammar
        .yr                       Yacc-Ratfor source grammar
        .ye                       Yacc-Eﬂ source grammar
        .l                        Lex source grammar

The following diagram summarizes the default transformation paths. If there are two paths connecting a
pair of sufﬁxes, the longer one is used only if the intermediate ﬁle exists or is named in the description.


                                                         .o


                        .c           .r          .e            .f   .s   .y .yr .ye .l   .d

                   .l        .y     .yr         .ye



      If the ﬁle x.o were needed and there were an x.c in the description or directory, it would be com-
piled. If there were also an x.l, that grammar would be run through Lex before compiling the result.
However, if there were no x.c but there were an x.l, make would discard the intermediate C-language
ﬁle and use the direct link in the graph above.
     It is possible to change the names of some of the compilers used in the default, or the ﬂag argu-
ments with which they are invoked by knowing the macro names used. The compiler names are the
macros AS, CC, RC, EC, YACC, YACCR, YACCE, and LEX. The command
        make CC=newcc
will cause the ‘‘newcc’’ command to be used instead of the usual C compiler. The macros CFLAGS,
RFLAGS, EFLAGS, YFLAGS, and LFLAGS may be set to cause these commands to be issued with
optional ﬂags. Thus,
                                                   -6-


        make "CFLAGS= −O"
causes the optimizing C compiler to be used.

Example
     As an example of the use of make, we will present the description ﬁle used to maintain the make
command itself. The code for make is spread over a number of C source ﬁles and a Yacc grammar.
The description ﬁle contains:
        # Description ﬁle for the Make command
        P = und – 3  opr – r2   # send to GCOS to be printed
        FILES = Makeﬁle version.c defs main.c doname.c misc.c ﬁles.c dosys.cgram.y lex.c gcos.c
        OBJECTS = version.o main.o doname.o misc.o ﬁles.o dosys.o gram.o
        LIBES= – lS
        LINT = lint – p
        CFLAGS = – O
        make: $(OBJECTS)
               cc $(CFLAGS) $(OBJECTS) $(LIBES) – o make
               size make
        $(OBJECTS): defs
        gram.o: lex.c
        cleanup:
                   -rm *.o gram.c
                   -du
        install:
                   @size make /usr/bin/make
                   cp make /usr/bin/make ; rm make
        print: $(FILES)             # print recently changed ﬁles
                 pr $?  $P
                 touch print
        test:
                   make – dp  grep – v TIME >1zap
                   /usr/bin/make – dp  grep – v TIME >2zap
                   diff 1zap 2zap
                   rm 1zap 2zap
        lint : dosys.c doname.c ﬁles.c main.c misc.c version.c gram.c
                 $(LINT) dosys.c doname.c ﬁles.c main.c misc.c version.c gram.c
                 rm gram.c
        arch:
                   ar uv /sys/source/s2/make.a $(FILES)
Make usually prints out each command before issuing it. The following output results from typing the
simple command
        make
in a directory containing only the source and description ﬁle:
                                                   -7-


         cc – c version.c
         cc – c main.c
         cc – c doname.c
         cc – c misc.c
         cc – c ﬁles.c
         cc – c dosys.c
         yacc gram.y
         mv y.tab.c gram.c
         cc – c gram.c
         cc version.o main.o doname.o misc.o ﬁles.o dosys.o gram.o – lS – o make
         13188+3348+3044 = 19580b = 046174b
Although none of the source ﬁles or grammars were mentioned by name in the description ﬁle, make
found them using its sufﬁx rules and issued the needed commands. The string of digits results from the
‘‘size make’’ command; the printing of the command line itself was suppressed by an @ sign. The @
sign on the size command in the description ﬁle suppressed the printing of the command, so only the
sizes are written.
       The last few entries in the description ﬁle are useful maintenance sequences. The ‘‘print’’ entry
prints only the ﬁles that have been changed since the last ‘‘make print’’ command. A zero-length ﬁle
print is maintained to keep track of the time of the printing; the $? macro in the command line then
picks up only the names of the ﬁles changed since print was touched. The printed output can be sent to
a different printer or to a ﬁle by changing the deﬁnition of the P macro:
        make print "P = opr – sp"
                or
        make print "P= cat >zap"


Suggestions and Warnings
      The most common difﬁculties arise from make’s speciﬁc meaning of dependency. If ﬁle x.c has a
‘‘#include "defs"’’ line, then the object ﬁle x.o depends on defs; the source ﬁle x.c does not. (If defs is
changed, it is not necessary to do anything to the ﬁle x.c, while it is necessary to recreate x.o.)
      To discover what make would do, the ‘‘– n’’ option is very useful. The command
        make – n
orders make to print out the commands it would issue without actually taking the time to execute them.
If a change to a ﬁle is absolutely certain to be benign (e.g., adding a new deﬁnition to an include ﬁle),
the ‘‘– t’’ (touch) option can save a lot of time: instead of issuing a large number of superﬂuous recom-
pilations, make updates the modiﬁcation times on the affected ﬁle. Thus, the command
        make – ts
(‘‘touch silently’’) causes the relevant ﬁles to appear up to date. Obvious care is necessary, since this
mode of operation subverts the intention of make and destroys all memory of the previous relationships.
      The debugging ﬂag (‘‘– d’’) causes make to print out a very detailed description of what it is
doing, including the ﬁle times. The output is verbose, and recommended only as a last resort.

Acknowledgments
     I would like to thank S. C. Johnson for suggesting this approach to program maintenance control.
I would like to thank S. C. Johnson and H. Gajewska for being the prime guinea pigs during develop-
ment of make.
                                              -8-


References
1.   S. C. Johnson, ‘‘Yacc — Yet Another Compiler-Compiler’’, Bell Laboratories Computing Science
     Technical Report #32, July 1978.
2.   M. E. Lesk, ‘‘Lex — A Lexical Analyzer Generator’’, Computing Science Technical Report #39,
     October 1975.
                                                    -9-


Appendix. Sufﬁxes and Transformation Rules
       The make program itself does not know what ﬁle name sufﬁxes are interesting or how to
transform a ﬁle with one sufﬁx into a ﬁle with another sufﬁx. This information is stored in an internal
table that has the form of a description ﬁle. If the ‘‘– r’’ ﬂag is used, this table is not used.
      The list of sufﬁxes is actually the dependency list for the name ‘‘.SUFFIXES’’; make looks for a
ﬁle with any of the sufﬁxes on the list. If such a ﬁle exists, and if there is a transformation rule for that
combination, make acts as described earlier. The transformation rule names are the concatenation of the
two sufﬁxes. The name of the rule to transform a ‘‘.r’’ ﬁle to a ‘‘.o’’ ﬁle is thus ‘‘.r.o’’. If the rule is
present and no explicit command sequence has been given in the user’s description ﬁles, the command
sequence for the rule ‘‘.r.o’’ is used. If a command is generated by using one of these sufﬁxing rules,
the macro $∗ is given the value of the stem (everything but the sufﬁx) of the name of the ﬁle to be
made, and the macro $< is the name of the dependent that caused the action.
       The order of the sufﬁx list is signiﬁcant, since it is scanned from left to right, and the ﬁrst name
that is formed that has both a ﬁle and a rule associated with it is used. If new names are to be
appended, the user can just add an entry for ‘‘.SUFFIXES’’ in his own description ﬁle; the dependents
will be added to the usual list. A ‘‘.SUFFIXES’’ line without any dependents deletes the current list.
(It is necessary to clear the current list if the order of names is to be changed).
      The following is an excerpt from the default rules ﬁle:
         .SUFFIXES : .o .c .e .r .f .y .yr .ye .l .s
         YACC=yacc
         YACCR=yacc – r
         YACCE=yacc – e
         YFLAGS=
         LEX=lex
         LFLAGS=
         CC=cc
         AS=as –
         CFLAGS=
         RC=ec
         RFLAGS=
         EC=ec
         EFLAGS=
         FFLAGS=
         .c.o :
                   $(CC) $(CFLAGS) – c $<
         .e.o .r.o .f.o :
                   $(EC) $(RFLAGS) $(EFLAGS) $(FFLAGS) – c $<
         .s.o :
                   $(AS) – o $@ $<
         .y.o :
                   $(YACC) $(YFLAGS) $<
                   $(CC) $(CFLAGS) – c y.tab.c
                   rm y.tab.c
                   mv y.tab.o $@
         .y.c :
                   $(YACC) $(YFLAGS) $<
                   mv y.tab.c $@
                                  UNIX Programming — Second Edition

                                                  Brian W. Kernighan
                                                   Dennis M. Ritchie
                                                   Bell Laboratories
                                             Murray Hill, New Jersey 07974



                                                      ABSTRACT

              This paper is an introduction to programming on the UNIX† system. The emphasis
          is on how to write programs that interface to the operating system, either directly or
          through the standard I/O library. The topics discussed include
            • handling command arguments
            • rudimentary I/O; the standard input and output
            • the standard I/O library; ﬁle system access
            • low-level I/O: open, read, write, close, seek
            • processes: exec, fork, pipes
            • signals — interrupts, etc.
               There is also an appendix which describes the standard I/O library in detail.



December 3, 1998




______________
_
†UNIX is a Trademark of Bell Laboratories.
                                   UNIX Programming — Second Edition

                                                     Brian W. Kernighan
                                                      Dennis M. Ritchie
                                                   Bell Laboratories
                                             Murray Hill, New Jersey 07974


1 . I NT RO DU CT IO N
    IN TR OD UC TI ON
    This paper describes how to write programs that interface with the UNIX operating system in a
non-trivial way. This includes programs that use ﬁles by name, that use pipes, that invoke other com-
mands as they run, or that attempt to catch interrupts and other signals during execution.
     The document collects material which is scattered throughout several sections of The UNIX
Programmer’s Manual [1] for Version 7 UNIX. There is no attempt to be complete; only generally use-
ful material is dealt with. It is assumed that you will be programming in C, so you must be able to read
the language roughly up to the level of The C Programming Language [2]. Some of the material in sec-
tions 2 through 4 is based on topics covered more carefully there. You should also be familiar with
UNIX itself at least to the level of UNIX for Beginners [3].

2 . B AS IC S
    BA SI CS

2 . 1 . P ro gr am A rg um en ts
        Pr og ra m Ar gu me nt s
     When a C program is run as a command, the arguments on the command line are made available to
the function m a i n as an argument count a r g c and an array a r g v of pointers to character strings
that contain the arguments. By convention, a r g v [ 0 ] is the command name itself, so a r g c is
always greater than 0.
    The following program illustrates the mechanism: it simply echoes its arguments back to the termi-
nal. (This is essentially the e c h o command.)
          mai n(a rgc , arg v)           / * ech o arg ume nts * /
          int arg c;
          cha r * arg v[] ;
          {
              int i;

               for (i = 1; i < arg c; i++ )
                  pri ntf ("% s%c ", arg v[i ], (i< arg c-1 ) ? ’ ’ : ’ \ n’) ;
          }

ar gv is a pointer to an array whose individual elements are pointers to arrays of characters; each is ter-
minated by \ 0, so they can be treated as strings. The program starts by printing ar gv [1 ] and loops
until it has printed them all.
    The argument count and the arguments are parameters to ma in. If you want to keep them around
so other routines can get at them, you must copy them to external variables.

2. 2. T he ‘ ‘S ta nd ar d I np ut ’’ a nd ‘ ‘S ta nd ar d O ut pu t’ ’
      Th e ‘‘ St an da rd In pu t’ ’ an d ‘‘ St an da rd Ou tp ut ’’
     The simplest input mechanism is to read the ‘‘standard input,’’ which is generally the user’s termi-
nal. The function ge tc ha r returns the next input character each time it is called. A ﬁle may be sub-
stituted for the terminal by using the < convention: if pr og uses ge tc ha r, then the command line
                                                    -2-


           pro g <fi le

causes pr og to read fi le instead of the terminal. pr og itself need know nothing about where its
input is coming from. This is also true if the input comes from another program via the pipe mechan-
ism:
           oth erp rog | pro g

provides the standard input for pr og from the standard output of ot he rp ro g.
     ge tc ha r returns the value EO F when it encounters the end of ﬁle (or an error) on whatever you
are reading. The value of EO F is normally deﬁned to be -1, but it is unwise to take any advantage of
that knowledge. As will become clear shortly, this value is automatically deﬁned for you when you
compile a program, and need not be of any concern.
     Similarly, pu tc ha r( c) puts the character c on the ‘‘standard output,’’ which is also by default
the terminal. The output can be captured on a ﬁle by using >: if pr og uses pu tc ha r,
           pro g >ou tfi le
writes the standard output on ou tf il e instead of the terminal. ou tf il e is created if it doesn’t exist;
if it already exists, its previous contents are overwritten. And a pipe can be used:
           pro g | oth erp rog

puts the standard output of pr og into the standard input of ot he rp ro g.
    The function pr in tf, which formats output in various ways, uses the same mechanism as
pu tc ha r does, so calls to pr in tf and pu tc ha r may be intermixed in any order; the output will
appear in the order of the calls.
    Similarly, the function sc an f provides for formatted input conversion; it will read the standard
input and break it up into strings, numbers, etc., as desired. sc an f uses the same mechanism as
ge tc ha r, so calls to them may also be intermixed.
      Many programs read only one input and write one output; for such programs I/O with ge tc ha r,
pu tc ha r, sc an f, and pr in tf may be entirely adequate, and it is almost always enough to get
started. This is particularly true if the UNIX pipe facility is used to connect the output of one program
to the input of the next. For example, the following program strips out all ascii control characters from
its input (except for newline and tab).
           #in clu de <st dio .h>

           mai n()     / * ccs tri p: str ip non -gr aph ic cha rac ter s * /
           {
               int c;
               whi le ((c = get cha r() ) ! = EOF )
                   if ((c >= ’ ’ && c < 017 7) | | c == ’ \ t’ | | c == ’ \ n’)
                       put cha r(c );
               exi t(0 );
           }

The line
           #in clu de <st dio .h>

should appear at the beginning of each source ﬁle. It causes the C compiler to read a ﬁle
(/usr/include/stdio.h) of standard routines and symbols that includes the deﬁnition of EO F.
    If it is necessary to treat multiple ﬁles, you can use ca t to collect the ﬁles for you:
           cat fil e1 fil e2 ... | ccs tri p >ou tpu t

and thus avoid learning how to access ﬁles from a program. By the way, the call to ex it at the end is
not necessary to make the program work properly, but it assures that any caller of the program will see
a normal termination status (conventionally 0) from the program when it completes. Section 6 discusses
                                                   -3-


status returns in more detail.

3. T HE S TA ND AR D I /O L IB RA RY
   TH E ST AN DA RD I/ O LI BR AR Y
    The ‘‘Standard I/O Library’’ is a collection of routines intended to provide efﬁcient and portable I/O
services for most C programs. The standard I/O library is available on each system that supports C, so
programs that conﬁne their system interactions to its facilities can be transported from one system to
another essentially without change.
   In this section, we will discuss the basics of the standard I/O library. The appendix contains a more
complete description of its capabilities.

3. 1. F il e A cc es s
      Fi le Ac ce ss
     The programs written so far have all read the standard input and written the standard output, which
we have assumed are magically pre-deﬁned. The next step is to write a program that accesses a ﬁle that
is not already connected to the program. One simple example is wc, which counts the lines, words and
characters in a set of ﬁles. For instance, the command
         wc x.c y.c

prints the number of lines, words and characters in x. c and y. c and the totals.
    The question is how to arrange for the named ﬁles to be read — that is, how to connect the ﬁle sys-
tem names to the I/O statements which actually read the data.
     The rules are simple. Before it can be read or written a ﬁle has to be opened by the standard
library function fo pe n. fo pe n takes an external name (like x. c or y. c), does some housekeeping
and negotiation with the operating system, and returns an internal name which must be used in subse-
quent reads or writes of the ﬁle.
     This internal name is actually a pointer, called a ﬁle pointer, to a structure which contains informa-
tion about the ﬁle, such as the location of a buffer, the current character position in the buffer, whether
the ﬁle is being read or written, and the like. Users don’t need to know the details, because part of the
standard I/O deﬁnitions obtained by including st di o. h is a structure deﬁnition called FI LE. The
only declaration needed for a ﬁle pointer is exempliﬁed by
         FIL E    * fp, * fop en( );

This says that fp is a pointer to a FI LE, and fo pe n returns a pointer to a FI LE. (FI LE is a type
name, like in t, not a structure tag.
    The actual call to fo pe n in a program is
         fp = fop en( nam e, mod e);

The ﬁrst argument of fo pe n is the name of the ﬁle, as a character string. The second argument is the
mode, also as a character string, which indicates how you intend to use the ﬁle. The only allowable
modes are read ("r "), write ("w "), or append ("a ").
     If a ﬁle that you open for writing or appending does not exist, it is created (if possible). Opening
an existing ﬁle for writing causes the old contents to be discarded. Trying to read a ﬁle that does not
exist is an error, and there may be other causes of error as well (like trying to read a ﬁle when you don’t
have permission). If there is any error, fo pe n will return the null pointer value NU LL (which is
deﬁned as zero in st di o. h).
     The next thing needed is a way to read or write the ﬁle once it is open. There are several possibili-
ties, of which ge tc and pu tc are the simplest. ge tc returns the next character from a ﬁle; it needs
the ﬁle pointer to tell it what ﬁle. Thus
         c = get c(f p)

places in c the next character from the ﬁle referred to by fp; it returns EO F when it reaches end of ﬁle.
pu tc is the inverse of ge tc:
                                                 -4-


        put c(c , fp)

puts the character c on the ﬁle fp and returns c. ge tc and pu tc return EO F on error.
    When a program is started, three ﬁles are opened automatically, and ﬁle pointers are provided for
them. These ﬁles are the standard input, the standard output, and the standard error output; the
corresponding ﬁle pointers are called st di n, st do ut, and st de rr. Normally these are all con-
nected to the terminal, but may be redirected to ﬁles or pipes as described in Section 2.2. st di n,
st do ut and st de rr are pre-deﬁned in the I/O library as the standard input, output and error ﬁles;
they may be used anywhere an object of type FI LE * can be. They are constants, however, not vari-
ables, so don’t try to assign to them.
     With some of the preliminaries out of the way, we can now write wc. The basic design is one that
has been found convenient for many programs: if there are command-line arguments, they are processed
in order. If there are no arguments, the standard input is processed. This way the program can be used
stand-alone or as part of a larger process.
        #in clu de <st dio .h>

        mai n(a rgc , arg v) / * wc: cou nt lin es, wor ds, cha rs * /
        int arg c;
        cha r * arg v[] ;
        {
            int c, i, inw ord ;
            FIL E * fp, * fop en( );
            lon g lin ect , wor dct , cha rct ;
            lon g tli nec t = 0, two rdc t = 0, tch arc t = 0;

            i = 1;
            fp = std in;
            do {
                if (ar gc > 1 && (fp =fo pen (ar gv[ i], "r" )) == NUL L) {
                    fpr int f(s tde rr, "wc : can ’t ope n %s \ n", arg v[i ]);
                    con tin ue;
                }
                lin ect = wor dct = cha rct = inw ord = 0;
                whi le ((c = get c(f p)) ! = EOF ) {
                    cha rct ++;
                    if (c == ’ \ n’)
                        lin ect ++;
                    if (c == ’ ’ | | c == ’ \ t’ | | c == ’ \ n’)
                        inw ord = 0;
                    els e if (in wor d == 0) {
                        inw ord = 1;
                        wor dct ++;
                    }
                }
                pri ntf ("% 7ld %7l d %7l d", lin ect , wor dct , cha rct );
                pri ntf (ar gc > 1 ? " %s \ n" : " \ n", arg v[i ]);
                fcl ose (fp );
                tli nec t += lin ect ;
                two rdc t += wor dct ;
                tch arc t += cha rct ;
            } whi le (++ i < arg c);
            if (ar gc > 2)
                pri ntf ("% 7ld %7l d %7l d tot al \ n", tli nec t, two rdc t, tch arc t);
            exi t(0 );
        }

The function fp ri nt f is identical to pr in tf, save that the ﬁrst argument is a ﬁle pointer that
                                                     -5-


speciﬁes the ﬁle to be written.
     The function fc lo se is the inverse of fo pe n; it breaks the connection between the ﬁle pointer
and the external name that was established by fo pe n, freeing the ﬁle pointer for another ﬁle. Since
there is a limit on the number of ﬁles that a program may have open simultaneously, it’s a good idea to
free things when they are no longer needed. There is also another reason to call fc lo se on an output
ﬁle — it ﬂushes the buffer in which pu tc is collecting output. (fc lo se is called automatically for
each open ﬁle when a program terminates normally.)

3. 2. E rr or H an dl in g — S td er r a nd E xi t
      Er ro r Ha nd li ng    St de rr an d Ex it
     st de rr is assigned to a program in the same way that st di n and st do ut are. Output written
on st de rr appears on the user’s terminal even if the standard output is redirected. wc writes its diag-
nostics on st de rr instead of st do ut so that if one of the ﬁles can’t be accessed for some reason, the
message ﬁnds its way to the user’s terminal instead of disappearing down a pipeline or into an output
ﬁle.
    The program actually signals errors in another way, using the function ex it to terminate program
execution. The argument of ex it is available to whatever process called it (see Section 6), so the suc-
cess or failure of the program can be tested by another program that uses this one as a sub-process. By
convention, a return value of 0 signals that all is well; non-zero values signal abnormal situations.
     ex it itself calls fc lo se for each open output ﬁle, to ﬂush out any buffered output, then calls a
routine named —e xi t. The function —e xi t causes immediate termination without any buffer ﬂushing;
it may be called directly if desired.

3. 3. M is ce ll an eo us I /O F un ct io ns
      Mi sc el la ne ou s I/ O Fu nc ti on s
    The standard I/O library provides several other I/O functions besides those we have illustrated
above.
    Normally output with pu tc, etc., is buffered (except to st de rr); to force it out immediately, use
ff lu sh (f p).
     fs ca nf is identical to sc an f, except that its ﬁrst argument is a ﬁle pointer (as with fp ri nt f)
that speciﬁes the ﬁle from which the input comes; it returns EO F at end of ﬁle.
     The functions ss ca nf and sp ri nt f are identical to fs ca nf and fp ri nt f, except that the
ﬁrst argument names a character string instead of a ﬁle pointer. The conversion is done from the string
for ss ca nf and into it for sp ri nt f.
    fg et s( bu f, si ze , fp ) copies the next line from fp, up to and including a newline, into
bu f; at most si ze -1 characters are copied; it returns NU LL at end of ﬁle. fp ut s( bu f, fp )
writes the string in bu f onto ﬁle fp.
     The function un ge tc (c , fp ) ‘‘pushes back’’ the character c onto the input stream fp; a subse-
quent call to ge tc, fs ca nf, etc., will encounter c. Only one character of pushback per ﬁle is permit-
ted.

4. L OW -L EV EL I /O
   LO W- LE VE L I/ O
   This section describes the bottom level of I/O on the UNIX system. The lowest level of I/O in
UNIX provides no buffering or any other services; it is in fact a direct entry into the operating system.
You are entirely on your own, but on the other hand, you have the most control over what happens.
And since the calls and usage are quite simple, this isn’t as bad as it sounds.

4. 1. F il e D es cr ip to rs
      Fi le De sc ri pt or s
    In the UNIX operating system, all input and output is done by reading or writing ﬁles, because all
peripheral devices, even the user’s terminal, are ﬁles in the ﬁle system. This means that a single, homo-
geneous interface handles all communication between a program and peripheral devices.
    In the most general case, before reading or writing a ﬁle, it is necessary to inform the system of
your intent to do so, a process called ‘‘opening’’ the ﬁle. If you are going to write on a ﬁle, it may also
                                                    -6-


be necessary to create it. The system checks your right to do so (Does the ﬁle exist? Do you have per-
mission to access it?), and if all is well, returns a small positive integer called a ﬁle descriptor. When-
ever I/O is to be done on the ﬁle, the ﬁle descriptor is used instead of the name to identify the ﬁle.
(This is roughly analogous to the use of READ(5,...) and WRITE(6,...) in Fortran.) All information about
an open ﬁle is maintained by the system; the user program refers to the ﬁle only by the ﬁle descriptor.
    The ﬁle pointers discussed in section 3 are similar in spirit to ﬁle descriptors, but ﬁle descriptors are
more fundamental. A ﬁle pointer is a pointer to a structure that contains, among other things, the ﬁle
descriptor for the ﬁle in question.
    Since input and output involving the user’s terminal are so common, special arrangements exist to
make this convenient. When the command interpreter (the ‘‘shell’’) runs a program, it opens three ﬁles,
with ﬁle descriptors 0, 1, and 2, called the standard input, the standard output, and the standard error
output. All of these are normally connected to the terminal, so if a program reads ﬁle descriptor 0 and
writes ﬁle descriptors 1 and 2, it can do terminal I/O without worrying about opening the ﬁles.
    If I/O is redirected to and from ﬁles with < and >, as in
         pro g <in fil e >ou tfi le

the shell changes the default assignments for ﬁle descriptors 0 and 1 from the terminal to the named
ﬁles. Similar observations hold if the input or output is associated with a pipe. Normally ﬁle descriptor
2 remains attached to the terminal, so error messages can go there. In all cases, the ﬁle assignments are
changed by the shell, not by the program. The program does not need to know where its input comes
from nor where its output goes, so long as it uses ﬁle 0 for input and 1 and 2 for output.

4. 2. R ea d a nd W ri te
      Re ad an d Wr it e
    All input and output is done by two functions called re ad and wr it e. For both, the ﬁrst argu-
ment is a ﬁle descriptor. The second argument is a buffer in your program where the data is to come
from or go to. The third argument is the number of bytes to be transferred. The calls are
         n—r ead = rea d(f d, buf , n);

         n—w rit ten = wri te( fd, buf , n);

Each call returns a byte count which is the number of bytes actually transferred. On reading, the
number of bytes returned may be less than the number asked for, because fewer than n bytes remained
to be read. (When the ﬁle is a terminal, re ad normally reads only up to the next newline, which is
generally less than what was requested.) A return value of zero bytes implies end of ﬁle, and -1 indi-
cates an error of some sort. For writing, the returned value is the number of bytes actually written; it is
generally an error if this isn’t equal to the number supposed to be written.
     The number of bytes to be read or written is quite arbitrary. The two most common values are 1,
which means one character at a time (‘‘unbuffered’’), and 512, which corresponds to a physical block-
size on many peripheral devices. This latter size will be most efﬁcient, but even character at a time I/O
is not inordinately expensive.
     Putting these facts together, we can write a simple program to copy its input to its output. This
program will copy anything to anything, since the input and output can be redirected to any ﬁle or dev-
ice.
                                                         -7-


          #de fin e     BUF SIZ E      512       / * bes t siz e for PDP -11 UNI X * /

          mai n()       / * cop y inp ut to out put * /
          {
              cha r     buf [BU FSI ZE] ;
              int       n;

               whi le ((n = rea d(0 , buf , BUF SIZ E)) > 0)
                   wri te( 1, buf , n);
               exi t(0 );
          }

If the ﬁle size is not a multiple of BU FS IZ E, some re ad will return a smaller number of bytes to be
written by wr it e; the next call to re ad after that will return zero.
    It is instructive to see how re ad and wr it e can be used to construct higher level routines like
ge tc ha r, pu tc ha r, etc. For example, here is a version of ge tc ha r which does unbuffered input.
          #de fin e     CMA SK 037 7          / * for mak ing cha r’s > 0 * /

          get cha r()        / * unb uff ere d sin gle cha rac ter inp ut * /
          {
              cha r c;

               ret urn ((r ead (0, &c, 1) > 0) ? c & CMA SK : EOF );
          }

c must be declared ch ar, because re ad accepts a character pointer. The character being returned
must be masked with 03 77 to ensure that it is positive; otherwise sign extension may make it negative.
(The constant 03 77 is appropriate for the PDP-11 but not necessarily for other machines.)
    The second version of ge tc ha r does input in big chunks, and hands out the characters one at a
time.
          #de fin e     CMA SK 037 7 / * for mak ing cha r’s > 0 * /
          #de fin e     BUF SIZ E 512

          get cha r()   / * buf fer ed ver sio n * /
          {
              sta tic cha r buf [BU FSI ZE] ;
              sta tic cha r * buf p = buf ;
              sta tic int n = 0;

               if (n == 0) { / * buf fer is emp ty * /
                   n = rea d(0 , buf , BUF SIZ E);
                   buf p = buf ;
               }
               ret urn ((- -n >= 0) ? * buf p++ & CMA SK : EOF );
          }


4. 3. O pe n, C re at , C lo se , U nl in k
      Op en , Cr ea t, Cl os e, Un li nk
     Other than the default standard input, output and error ﬁles, you must explicitly open ﬁles in order
to read or write them. There are two system entry points for this, op en and cr ea t [sic].
    op en is rather like the fo pe n discussed in the previous section, except that instead of returning a
ﬁle pointer, it returns a ﬁle descriptor, which is just an in t.
          int fd;

          fd = ope n(n ame , rwm ode );
                                                  -8-


As with fo pe n, the na me argument is a character string corresponding to the external ﬁle name. The
access mode argument is different, however: rw mo de is 0 for read, 1 for write, and 2 for read and
write access. op en returns -1 if any error occurs; otherwise it returns a valid ﬁle descriptor.
   It is an error to try to op en a ﬁle that does not exist. The entry point cr ea t is provided to create
new ﬁles, or to re-write old ones.
        fd = cre at( nam e, pmo de) ;

returns a ﬁle descriptor if it was able to create the ﬁle called na me, and -1 if not. If the ﬁle already
exists, cr ea t will truncate it to zero length; it is not an error to cr ea t a ﬁle that already exists.
     If the ﬁle is brand new, cr ea t creates it with the protection mode speciﬁed by the pm od e argu-
ment. In the UNIX ﬁle system, there are nine bits of protection information associated with a ﬁle, con-
trolling read, write and execute permission for the owner of the ﬁle, for the owner’s group, and for all
others. Thus a three-digit octal number is most convenient for specifying the permissions. For example,
0755 speciﬁes read, write and execute permission for the owner, and read and execute permission for the
group and everyone else.
    To illustrate, here is a simpliﬁed version of the UNIX utility cp, a program which copies one ﬁle to
another. (The main simpliﬁcation is that our version copies only one ﬁle, and does not permit the
second argument to be a directory.)
        #de fin e NUL L 0
        #de fin e BUF SIZ E 512
        #de fin e PMO DE 064 4 / * RW for own er, R for gro up, oth ers * /

        mai n(a rgc , arg v) / * cp: cop y f1 to f2 * /
        int arg c;
        cha r * arg v[] ;
        {
            int     f1, f2, n;
            cha r buf [BU FSI ZE] ;

            if (ar gc ! = 3)
               err or( "Us age : cp fro m to" , NUL L);
            if ((f 1 = ope n(a rgv [1] , 0)) == -1)
               err or( "cp : can ’t ope n %s" , arg v[1 ]);
            if ((f 2 = cre at( arg v[2 ], PMO DE) ) == -1)
               err or( "cp : can ’t cre ate %s" , arg v[2 ]);

            whi le ((n = rea d(f 1, buf , BUF SIZ E)) > 0)
                if (wr ite (f2 , buf , n) ! = n)
                    err or( "cp : wri te err or" , NUL L);
            exi t(0 );
        }

        err or( s1, s2) / * pri nt err or mes sag e and die * /
        cha r * s1, * s2;
        {
            pri ntf (s1 , s2) ;
            pri ntf (" \ n") ;
            exi t(1 );
        }

    As we said earlier, there is a limit (typically 15-25) on the number of ﬁles which a program may
have open simultaneously. Accordingly, any program which intends to process many ﬁles must be
prepared to re-use ﬁle descriptors. The routine cl os e breaks the connection between a ﬁle descriptor
and an open ﬁle, and frees the ﬁle descriptor for use with some other ﬁle. Termination of a program via
ex it or return from the main program closes all open ﬁles.
                                                    -9-


     The function un li nk (f il en am e) removes the ﬁle fi le na me from the ﬁle system.

4. 4. R an do m A cc es s — S ee k a nd L se ek
      Ra nd om Ac ce ss     Se ek an d Ls ee k
     File I/O is normally sequential: each re ad or wr it e takes place at a position in the ﬁle right
after the previous one. When necessary, however, a ﬁle can be read or written in any arbitrary order.
The system call ls ee k provides a way to move around in a ﬁle without actually reading or writing:
          lse ek( fd, off set , ori gin );

forces the current position in the ﬁle whose descriptor is fd to move to position of fs et, which is
taken relative to the location speciﬁed by or ig in. Subsequent reading or writing will begin at that
position. of fs et is a lo ng; fd and or ig in are in t’s. or ig in can be 0, 1, or 2 to specify that
of fs et is to be measured from the beginning, from the current position, or from the end of the ﬁle
respectively. For example, to append to a ﬁle, seek to the end before writing:
          lse ek( fd, 0L, 2);

To get back to the beginning (‘‘rewind’’),
          lse ek( fd, 0L, 0);

Notice the 0L argument; it could also be written as (l on g) 0.
    With ls ee k, it is possible to treat ﬁles more or less like large arrays, at the price of slower access.
For example, the following simple function reads any number of bytes from any arbitrary place in a ﬁle.
          get (fd , pos , buf , n) / * rea d n byt es fro m pos iti on pos * /
          int fd, n;
          lon g pos ;
          cha r * buf ;
          {
              lse ek( fd, pos , 0);     / * get to pos * /
              ret urn (re ad( fd, buf , n)) ;
          }

     In pre-version 7 UNIX, the basic entry point to the I/O system is called se ek. se ek is identical to
ls ee k, except that its of fs et argument is an in t rather than a lo ng. Accordingly, since PDP-11
integers have only 16 bits, the of fs et speciﬁed for se ek is limited to 65,535; for this reason,
or ig in values of 3, 4, 5 cause se ek to multiply the given offset by 512 (the number of bytes in one
physical block) and then interpret or ig in as if it were 0, 1, or 2 respectively. Thus to get to an arbi-
trary place in a large ﬁle requires two seeks, ﬁrst one which selects the block, then one which has
or ig in equal to 1 and moves to the desired byte within the block.

4. 5. E rr or P ro ce ss in g
      Er ro r Pr oc es si ng
     The routines discussed in this section, and in fact all the routines which are direct entries into the
system can incur errors. Usually they indicate an error by returning a value of – 1. Sometimes it is nice
to know what sort of error occurred; for this purpose all these routines, when appropriate, leave an error
number in the external cell er rn o. The meanings of the various error numbers are listed in the intro-
duction to Section II of the UNIX Programmer’s Manual, so your program can, for example, determine
if an attempt to open a ﬁle failed because it did not exist or because the user lacked permission to read
it. Perhaps more commonly, you may want to print out the reason for failure. The routine pe rr or
will print a message associated with the value of er rn o; more generally, sy s— er rn o is an array of
character strings which can be indexed by er rn o and printed by your program.

5. P RO CE SS ES
   PR OC ES SE S
    It is often easier to use a program written by someone else than to invent one’s own. This section
describes how to execute a program from within another.
                                                       - 10 -


5. 1. T he ‘ ‘S ys te m’ ’ F un ct io n
      Th e ‘‘ Sy st em ’’ Fu nc ti on
     The easiest way to execute a program from another is to use the standard library routine sy st em.
sy st em takes one argument, a command string exactly as typed at the terminal (except for the newline
at the end) and executes it. For instance, to time-stamp the output of a program,
          mai n()
          {
              sys tem ("d ate ");
              / * res t of pro ces sin g * /
          }

If the command string has to be built from pieces, the in-memory formatting capabilities of sp ri nt f
may be useful.
    Remember than ge tc and pu tc normally buffer their input; terminal I/O will not be properly syn-
chronized unless this buffering is defeated. For output, use ff lu sh; for input, see se tb uf in the
appendix.

5. 2. L ow -L ev el P ro ce ss C re at io n — E xe cl a nd E xe cv
      Lo w- Le ve l Pr oc es s Cr ea ti on    Ex ec l an d Ex ec v
    If you’re not using the standard library, or if you need ﬁner control over what happens, you will
have to construct calls to other programs using the more primitive routines that the standard library’s
sy st em routine is based on.
    The most basic operation is to execute another program without returning, by using the routine
ex ec l. To print the date as the last action of a running program, use
          exe cl( " / bin / dat e", "da te" , NUL L);

The ﬁrst argument to ex ec l is the ﬁle name of the command; you have to know where it is found in
the ﬁle system. The second argument is conventionally the program name (that is, the last component
of the ﬁle name), but this is seldom used except as a place-holder. If the command takes arguments,
they are strung out after this; the end of the list is marked by a NU LL argument.
     The ex ec l call overlays the existing program with the new one, runs that, then exits. There is no
return to the original program.
    More realistically, a program might fall into two or more phases that communicate only through
temporary ﬁles. Here it is natural to make the second pass simply an ex ec l call from the ﬁrst.
    The one exception to the rule that the original program never gets control back occurs when there is
an error, for example if the ﬁle can’t be found or is not executable. If you don’t know where da te is
located, say
          exe cl( " / bin / dat e", "da te" , NUL L);
          exe cl( " / usr / bin / dat e", "da te" , NUL L);
          fpr int f(s tde rr, "So meo ne sto le ’da te’ \ n") ;

   A variant of ex ec l called ex ec v is useful when you don’t know in advance how many argu-
ments there are going to be. The call is
          exe cv( fil ena me, arg p);

where ar gp is an array of pointers to the arguments; the last pointer in the array must be NU LL so
ex ec v can tell where the list ends. As with ex ec l, fi le na me is the ﬁle in which the program is
found, and ar gp [0 ] is the name of the program. (This arrangement is identical to the ar gv array for
program arguments.)
    Neither of these routines provides the niceties of normal command execution. There is no
automatic search of multiple directories — you have to know precisely where the command is located.
Nor do you get the expansion of metacharacters like <, >, * , ? , and [] in the argument list. If you
want these, use ex ec l to invoke the shell sh, which then does all the work. Construct a string
co mm an dl in e that contains the complete command as it would have been typed at the terminal, then
say
                                                          - 11 -


         exe cl( " / bin / sh" , "sh ", "-c ", com man dli ne, NUL L);

The shell is assumed to be at a ﬁxed place, / bi n / sh. Its argument -c says to treat the next argument
as a whole command line, so it does just what you want. The only problem is in constructing the right
information in co mm an dl in e.

5. 3. C on tr ol o f P ro ce ss es — F or k a nd W ai t
      Co nt ro l of Pr oc es se s    Fo rk an d Wa it
    So far what we’ve talked about isn’t really all that useful by itself. Now we will show how to
regain control after running a program with ex ec l or ex ec v. Since these routines simply overlay the
new program on the old one, to save the old one requires that it ﬁrst be split into two copies; one of
these can be overlaid, while the other waits for the new, overlaying program to ﬁnish. The splitting is
done by a routine called fo rk:
         pro c—i d = for k() ;

splits the program into two copies, both of which continue to run. The only difference between the two
is the value of pr oc —i d, the ‘‘process id.’’ In one of these processes (the ‘‘child’’), pr oc —i d is
zero. In the other (the ‘‘parent’’), pr oc —i d is non-zero; it is the process number of the child. Thus
the basic way to call, and return from, another program is
         if (fo rk( ) == 0)
            exe cl( " / bin / sh" , "sh ", "-c ", cmd , NUL L); / * in chi ld * /

And in fact, except for handling errors, this is sufﬁcient. The fo rk makes two copies of the program.
In the child, the value returned by fo rk is zero, so it calls ex ec l which does the co mm an d and then
dies. In the parent, fo rk returns non-zero so it skips the ex ec l. (If there is any error, fo rk returns
-1).
    More often, the parent wants to wait for the child to terminate before continuing itself. This can be
done with the function wa it:
         int sta tus ;

         if (fo rk( ) == 0)
             exe cl( ... );
         wai t(& sta tus );

This still doesn’t handle any abnormal conditions, such as a failure of the ex ec l or fo rk, or the pos-
sibility that there might be more than one child running simultaneously. (The wa it returns the process
id of the terminated child, if you want to check it against the value returned by fo rk.) Finally, this
fragment doesn’t deal with any funny behavior on the part of the child (which is reported in st at us).
Still, these three lines are the heart of the standard library’s sy st em routine, which we’ll show in a
moment.
    The st at us returned by wa it encodes in its low-order eight bits the system’s idea of the child’s
termination status; it is 0 for normal termination and non-zero to indicate various kinds of problems.
The next higher eight bits are taken from the argument of the call to ex it which caused a normal ter-
mination of the child process. It is good coding practice for all programs to return meaningful status.
    When a program is called by the shell, the three ﬁle descriptors 0, 1, and 2 are set up pointing at
the right ﬁles, and all other possible ﬁle descriptors are available for use. When this program calls
another one, correct etiquette suggests making sure the same conditions hold. Neither fo rk nor the
ex ec calls affects open ﬁles in any way. If the parent is buffering output that must come out before
output from the child, the parent must ﬂush its buffers before the ex ec l. Conversely, if a caller
buffers an input stream, the called program will lose any information that has been read by the caller.
                                                  - 12 -


5. 4. P ip es
      Pi pe s
     A pipe is an I/O channel intended for use between two cooperating processes: one process writes
into the pipe, while the other reads. The system looks after buffering the data and synchronizing the
two processes. Most pipes are created by the shell, as in
        ls | pr

which connects the standard output of ls to the standard input of pr. Sometimes, however, it is most
convenient for a process to set up its own plumbing; in this section, we will illustrate how the pipe con-
nection is established and used.
    The system call pi pe creates a pipe. Since a pipe is used for both reading and writing, two ﬁle
descriptors are returned; the actual usage is like this:
        int      fd[ 2];

        sta t = pip e(f d);
        if (st at == -1)
            / * the re was an err or ... * /

fd is an array of two ﬁle descriptors, where fd [0 ] is the read side of the pipe and fd [1 ] is for writ-
ing. These may be used in re ad, wr it e and cl os e calls just like any other ﬁle descriptors.
    If a process reads a pipe which is empty, it will wait until data arrives; if a process writes into a
pipe which is too full, it will wait until the pipe empties somewhat. If the write side of the pipe is
closed, a subsequent re ad will encounter end of ﬁle.
     To illustrate the use of pipes in a realistic setting, let us write a function called
po pe n( cm d, mo de ), which creates a process cm d (just as sy st em does), and returns a ﬁle descrip-
tor that will either read or write that process, according to mo de. That is, the call
        fou t = pop en( "pr ", WRI TE) ;

creates a process that executes the pr command; subsequent wr it e calls using the ﬁle descriptor
fo ut will send their data to that process through the pipe.
     po pe n ﬁrst creates the the pipe with a pi pe system call; it then fo rks to create two copies of
itself. The child decides whether it is supposed to read or write, closes the other side of the pipe, then
calls the shell (via ex ec l) to run the desired process. The parent likewise closes the end of the pipe it
does not use. These closes are necessary to make end-of-ﬁle tests work properly. For example, if a
child that intends to read fails to close the write end of the pipe, it will never see the end of the pipe
ﬁle, just because there is one writer potentially active.
                                                   - 13 -


         #in clu de <st dio .h>

         #de fin e   REA D 0
         #de fin e   WRI TE 1
         #de fin e   tst (a, b)     (mo de == REA D ? (b) : (a) )
         sta tic     int    pop en— pid ;

         pop en( cmd , mod e)
         cha r * cmd ;
         int     mod e;
         {
             int p[2 ];

             if (pi pe( p) < 0)
                 ret urn (NU LL) ;
             if ((p ope n—p id = for k() ) == 0) {
                 clo se( tst (p[ WRI TE] , p[R EAD ])) ;
                 clo se( tst (0, 1)) ;
                 dup (ts t(p [RE AD] , p[W RIT E]) );
                 clo se( tst (p[ REA D], p[W RIT E]) );
                 exe cl( " / bin / sh" , "sh ", "-c ", cmd , 0);
                 —ex it( 1);       / * dis ast er has occ urr ed if we get her e * /
             }
             if (po pen —pi d == -1)
                 ret urn (NU LL) ;
             clo se( tst (p[ REA D], p[W RIT E]) );
             ret urn (ts t(p [WR ITE ], p[R EAD ])) ;
         }

The sequence of cl os es in the child is a bit tricky. Suppose that the task is to create a child process
that will read data from the parent. Then the ﬁrst cl os e closes the write side of the pipe, leaving the
read side open. The lines
         clo se( tst (0, 1)) ;
         dup (ts t(p [RE AD] , p[W RIT E]) );

are the conventional way to associate the pipe descriptor with the standard input of the child. The
cl os e closes ﬁle descriptor 0, that is, the standard input. du p is a system call that returns a duplicate
of an already open ﬁle descriptor. File descriptors are assigned in increasing order and the ﬁrst available
one is returned, so the effect of the du p is to copy the ﬁle descriptor for the pipe (read side) to ﬁle
descriptor 0; thus the read side of the pipe becomes the standard input. (Yes, this is a bit tricky, but it’s
a standard idiom.) Finally, the old read side of the pipe is closed.
    A similar sequence of operations takes place when the child process is supposed to write from the
parent instead of reading. You may ﬁnd it a useful exercise to step through that case.
     The job is not quite done, for we still need a function pc lo se to close the pipe created by
po pe n. The main reason for using a separate function rather than cl os e is that it is desirable to wait
for the termination of the child process. First, the return value from pc lo se indicates whether the pro-
cess succeeded. Equally important when a process creates several children is that only a bounded
number of unwaited-for children can exist, even if some of them have terminated; performing the wa it
lays the child to rest. Thus:
                                                  - 14 -


        #in clu de <si gna l.h >

        pcl ose (fd ) / * clo se pip e fd * /
        int fd;
        {
            reg ist er r, ( * hst at) (), ( * ist at) (), ( * qst at) ();
            int      sta tus ;
            ext ern int pop en— pid ;

             clo se( fd) ;
             ist at = sig nal (SI GIN T, SIG —IG N);
             qst at = sig nal (SI GQU IT, SIG —IG N);
             hst at = sig nal (SI GHU P, SIG —IG N);
             whi le ((r = wai t(& sta tus )) ! = pop en— pid && r ! = -1) ;
             if (r == -1)
                 sta tus = -1;
             sig nal (SI GIN T, ist at) ;
             sig nal (SI GQU IT, qst at) ;
             sig nal (SI GHU P, hst at) ;
             ret urn (st atu s);
        }

The calls to si gn al make sure that no interrupts, etc., interfere with the waiting process; this is the
topic of the next section.
     The routine as written has the limitation that only one pipe may be open at once, because of the sin-
gle shared variable po pe n— pi d; it really should be an array indexed by ﬁle descriptor. A po pe n
function, with slightly different arguments and return value is available as part of the standard I/O
library discussed below. As currently written, it shares the same limitation.

6. S IG NA LS — I NT ER RU PT S A ND A LL T HA T
   SI GN AL S   IN TE RR UP TS AN D AL L TH AT
     This section is concerned with how to deal gracefully with signals from the outside world (like
interrupts), and with program faults. Since there’s nothing very useful that can be done from within C
about program faults, which arise mainly from illegal memory references or from execution of peculiar
instructions, we’ll discuss only the outside-world signals: interrupt, which is sent when the DEL charac-
ter is typed; quit, generated by the FS character; hangup, caused by hanging up the phone; and ter-
minate, generated by the kill command. When one of these events occurs, the signal is sent to all
processes which were started from the corresponding terminal; unless other arrangements have been
made, the signal terminates the process. In the quit case, a core image ﬁle is written for debugging pur-
poses.
     The routine which alters the default action is called si gn al. It has two arguments: the ﬁrst
speciﬁes the signal, and the second speciﬁes how to treat it. The ﬁrst argument is just a number code,
but the second is the address is either a function, or a somewhat strange code that requests that the sig-
nal either be ignored, or that it be given the default action. The include ﬁle si gn al .h gives names
for the various arguments, and should always be included when signals are used. Thus
        #in clu de <si gna l.h >
         ...
        sig nal (SI GIN T, SIG —IG N);

causes interrupts to be ignored, while
        sig nal (SI GIN T, SIG —DF L);

restores the default action of process termination. In all cases, si gn al returns the previous value of
the signal. The second argument to si gn al may instead be the name of a function (which has to be
declared explicitly if the compiler hasn’t seen it already). In this case, the named routine will be called
when the signal occurs. Most commonly this facility is used to allow the program to clean up
unﬁnished business before terminating, for example to delete a temporary ﬁle:
                                                   - 15 -


         #in clu de <si gna l.h >

         mai n()
         {
             int oni ntr ();

             if (si gna l(S IGI NT, SIG —IG N) ! = SIG —IG N)
                sig nal (SI GIN T, oni ntr );

             / * Pro ces s ... * /

             exi t(0 );
         }

         oni ntr ()
         {
             unl ink (te mpf ile );
             exi t(1 );
         }

     Why the test and the double call to si gn al ? Recall that signals like interrupt are sent to all
processes started from a particular terminal. Accordingly, when a program is to be run non-interactively
(started by &), the shell turns off interrupts for it so it won’t be stopped by interrupts intended for fore-
ground processes. If this program began by announcing that all interrupts were to be sent to the
on in tr routine regardless, that would undo the shell’s effort to protect it when run in the background.
     The solution, shown above, is to test the state of interrupt handling, and to continue to ignore inter-
rupts if they are already being ignored. The code as written depends on the fact that si gn al returns
the previous state of a particular signal. If signals were already being ignored, the process should con-
tinue to ignore them; otherwise, they should be caught.
     A more sophisticated program may wish to intercept an interrupt and interpret it as a request to stop
what it is doing and return to its own command-processing loop. Think of a text editor: interrupting a
long printout should not cause it to terminate and lose the work already done. The outline of the code
for this case is probably best written like this:
         #in clu de <si gna l.h >
         #in clu de <se tjm p.h >
         jmp —bu f sjb uf;

         mai n()
         {
             int ( * ist at) (), oni ntr ();

             ist at = sig nal (SI GIN T, SIG —IG N); / * sav e ori gin al sta tus * /
             set jmp (sj buf ); / * sav e cur ren t sta ck pos iti on * /
             if (is tat ! = SIG —IG N)
                 sig nal (SI GIN T, oni ntr );

             / * mai n pro ces sin g loo p * /
         }

         oni ntr ()
         {
             pri ntf (" \ nIn ter rup t \ n") ;
             lon gjm p(s jbu f);      / * ret urn to sav ed sta te * /
         }

The include ﬁle se tj mp .h declares the type jm p— bu f an object in which the state can be saved.
sj bu f is such an object; it is an array of some sort. The se tj mp routine then saves the state of
                                                   - 16 -


things. When an interrupt occurs, a call is forced to the on in tr routine, which can print a message,
set ﬂags, or whatever. lo ng jm p takes as argument an object stored into by se tj mp, and restores
control to the location after the call to se tj mp, so control (and the stack level) will pop back to the
place in the main routine where the signal is set up and the main loop entered. Notice, by the way, that
the signal gets set again after an interrupt occurs. This is necessary; most signals are automatically reset
to their default action when they occur.
     Some programs that want to detect signals simply can’t be stopped at an arbitrary point, for exam-
ple in the middle of updating a linked list. If the routine called on occurrence of a signal sets a ﬂag and
then returns instead of calling ex it or lo ng jm p, execution will continue at the exact point it was
interrupted. The interrupt ﬂag can then be tested later.
     There is one difﬁculty associated with this approach. Suppose the program is reading the terminal
when the interrupt is sent. The speciﬁed routine is duly called; it sets its ﬂag and returns. If it were
really true, as we said above, that ‘‘execution resumes at the exact point it was interrupted,’’ the pro-
gram would continue reading the terminal until the user typed another line. This behavior might well be
confusing, since the user might not know that the program is reading; he presumably would prefer to
have the signal take effect instantly. The method chosen to resolve this difﬁculty is to terminate the ter-
minal read when execution resumes after the signal, returning an error code which indicates what hap-
pened.
     Thus programs which catch and resume execution after signals should be prepared for ‘‘errors’’
which are caused by interrupted system calls. (The ones to watch out for are reads from a terminal,
wa it, and pa us e.) A program whose on in tr program just sets in tf la g, resets the interrupt sig-
nal, and returns, should usually include code like the following when it reads the standard input:
        if (ge tch ar( ) == EOF )
           if (in tfl ag)
               / * EOF cau sed by int err upt * /
           els e
               / * tru e end -of -fi le * /

     A ﬁnal subtlety to keep in mind becomes important when signal-catching is combined with execu-
tion of other programs. Suppose a program catches interrupts, and also includes a method (like ‘‘!’’ in
the editor) whereby other programs can be executed. Then the code should look something like this:
        if (fo rk( ) == 0)
            exe cl( ... );
        sig nal (SI GIN T, SIG —IG N);    / * ign ore int err upt s * /
        wai t(& sta tus ); / * unt il the chi ld is don e * /
        sig nal (SI GIN T, oni ntr ); / * res tor e int err upt s * /

Why is this? Again, it’s not obvious but not really difﬁcult. Suppose the program you call catches its
own interrupts. If you interrupt the subprogram, it will get the signal and return to its main loop, and
probably read your terminal. But the calling program will also pop out of its wait for the subprogram
and read your terminal. Having two processes reading your terminal is very unfortunate, since the sys-
tem ﬁguratively ﬂips a coin to decide who should get each line of input. A simple way out is to have
the parent program ignore interrupts until the child is done. This reasoning is reﬂected in the standard
I/O library function sy st em:
                                                       - 17 -


           #in clu de <si gna l.h >

           sys tem (s)    / * run com man d str ing s * /
           cha r * s;
           {
               int sta tus , pid , w;
               reg ist er int ( * ist at) (), ( * qst at) ();

                  if ((p id = for k() ) == 0) {
                      exe cl( " / bin / sh" , "sh ", "-c ", s, 0);
                      —ex it( 127 );
                  }
                  ist at = sig nal (SI GIN T, SIG —IG N);
                  qst at = sig nal (SI GQU IT, SIG —IG N);
                  whi le ((w = wai t(& sta tus )) ! = pid && w ! = -1)
                      ;
                  if (w == -1)
                      sta tus = -1;
                  sig nal (SI GIN T, ist at) ;
                  sig nal (SI GQU IT, qst at) ;
                  ret urn (st atu s);
           }

     As an aside on declarations, the function si gn al obviously has a rather strange second argument.
It is in fact a pointer to a function delivering an integer, and this is also the type of the signal routine
itself. The two values SI G— IG N and SI G— DF L have the right type, but are chosen so they coincide
with no possible actual functions. For the enthusiast, here is how they are deﬁned for the PDP-11; the
deﬁnitions should be sufﬁciently ugly and nonportable to encourage use of the include ﬁle.
           #de fin e    SIG —DF L   (in t ( * )() )0
           #de fin e    SIG —IG N   (in t ( * )() )1


R ef er en ce s
Re fe re nc es
[1] K. L. Thompson and D. M. Ritchie, The UNIX Programmer’s Manual, Bell Laboratories, 1978.
[2] B. W. Kernighan and D. M. Ritchie, The C Programming Language, Prentice-Hall, Inc., 1978.
[3] B. W. Kernighan, ‘‘UNIX for Beginners — Second Edition.’’ Bell Laboratories, 1978.
                                                     - 18 -


                                 Appendix — The Standard I/O Library

                                                   D. M. Ritchie
                                               Bell Laboratories
                                         Murray Hill, New Jersey 07974
     The standard I/O library was designed with the following goals in mind.
1.   It must be as efﬁcient as possible, both in time and in space, so that there will be no hesitation in
     using it no matter how critical the application.
2.   It must be simple to use, and also free of the magic numbers and mysterious calls whose use mars
     the understandability and portability of many programs using older packages.
3.   The interface provided should be applicable on all machines, whether or not the programs which
     implement it are directly portable to other systems, or to machines other than the PDP-11 running a
     version of UNIX.

1 . G en er al U sa ge
1. Ge ne ra l Us ag e
     Each program using the library must have the line
                   #in clu de <st dio .h>

which deﬁnes certain macros and variables. The routines are in the normal C library, so no special
library argument is needed for loading. All names in the include ﬁle intended only for internal use
begin with an underscore — to reduce the possibility of collision with a user name. The names intended
to be visible outside the package are
st di n       The name of the standard input ﬁle
st do ut      The name of the standard output ﬁle
st de rr      The name of the standard error ﬁle
EO F          is actually – 1, and is the value returned by the read routines on end-of-ﬁle or error.
NU LL         is a notation for the null pointer, returned by pointer-valued functions to indicate an error
FI LE         expands to st ru ct —i ob and is a useful shorthand when declaring pointers to streams.
BU FS IZ      is a number (viz. 512) of the size suitable for an I/O buffer supplied by the user. See
              se tb uf, below.
ge tc , ge tc ha r, pu tc , pu tc ha r, fe of , fe rr or , fi le no
           are deﬁned as macros. Their actions are described below; they are mentioned here to point
           out that it is not possible to redeclare them and that they are not actually functions; thus, for
           example, they may not have breakpoints set on them.
     The routines in this package offer the convenience of automatic buffer allocation and output ﬂushing
where appropriate. The names st di n, st do ut, and st de rr are in effect constants and may not be
assigned to.

2 . C al ls
2. Ca ll s
FI LE * fo pe n( fi le na me , ty pe ) ch ar * fi le na me , * ty pe ;
    opens the ﬁle and, if needed, allocates a buffer for it. fi le na me is a character string specifying
    the name. ty pe is a character string (not a single character). It may be "r ", "w ", or "a " to
    indicate intent to read, write, or append. The value returned is a ﬁle pointer. If it is NU LL the
    attempt to open failed.
FI LE * fr eo pe n( fi le na me , ty pe , io pt r) ch ar * fi le na me , * ty pe ; FI LE * io pt r;
    The stream named by io pt r is closed, if necessary, and then reopened as if by fo pe n. If the
    attempt to open fails, NU LL is returned, otherwise io pt r, which will now refer to the new ﬁle.
    Often the reopened stream is st di n or st do ut.
                                                 - 19 -


in t ge tc (i op tr ) FI LE * io pt r;
    returns the next character from the stream named by io pt r, which is a pointer to a ﬁle such as
    returned by fo pe n, or the name st di n. The integer EO F is returned on end-of-ﬁle or when an
    error occurs. The null character \ 0 is a legal character.
in t fg et c( io pt r) FI LE * io pt r;
    acts like ge tc but is a genuine function, not a macro, so it can be pointed to, passed as an argu-
    ment, etc.
pu tc (c , io pt r) FI LE * io pt r;
    pu tc writes the character c on the output stream named by io pt r, which is a value returned
    from fo pe n or perhaps st do ut or st de rr. The character is returned as value, but EO F is
    returned on error.
fp ut c( c, io pt r) FI LE * io pt r;
    acts like pu tc but is a genuine function, not a macro.
fc lo se (i op tr ) FI LE * io pt r;
    The ﬁle corresponding to io pt r is closed after any buffers are emptied. A buffer allocated by the
    I/O system is freed. fc lo se is automatic on normal termination of the program.
ff lu sh (i op tr ) FI LE * io pt r;
    Any buffered information on the (output) stream named by io pt r is written out. Output ﬁles are
    normally buffered if and only if they are not directed to the terminal; however, st de rr always
    starts off unbuffered and remains so unless se tb uf is used, or unless it is reopened.
ex it (e rr co de );
    terminates the process and returns its argument as status to the parent. This is a special version of
    the routine which calls ff lu sh for each output ﬁle. To terminate without ﬂushing, use —e xi t.
fe of (i op tr ) FI LE * io pt r;
    returns non-zero when end-of-ﬁle has occurred on the speciﬁed input stream.
fe rr or (i op tr ) FI LE * io pt r;
    returns non-zero when an error has occurred while reading or writing the named stream. The error
    indication lasts until the ﬁle has been closed.
ge tc ha r( );
    is identical to ge tc (s td in ).
pu tc ha r( c) ;
    is identical to pu tc (c , st do ut ).
ch ar * fg et s( s, n, io pt r) ch ar * s; FI LE * io pt r;
    reads up to n- 1 characters from the stream io pt r into the character pointer s. The read ter-
    minates with a newline character. The newline character is placed in the buffer followed by a null
    character. fg et s returns the ﬁrst argument, or NU LL if error or end-of-ﬁle occurred.
fp ut s( s, io pt r) ch ar * s; FI LE * io pt r;
    writes the null-terminated string (character array) s on the stream io pt r. No newline is appended.
    No value is returned.
un ge tc (c , io pt r) FI LE * io pt r;
    The argument character c is pushed back on the input stream named by io pt r. Only one charac-
    ter may be pushed back.
pr in tf (f or ma t, a1 , .. .) ch ar * fo rm at ;
fp ri nt f( io pt r, fo rm at , a1 , .. .) FI LE * io pt r; ch ar * fo rm at ;
sp ri nt f( s, fo rm at , a1 , .. .) ch ar * s, * fo rm at ;
    pr in tf writes on the standard output. fp ri nt f writes on the named output stream. sp ri nt f
    puts characters in the character array (string) named by s. The speciﬁcations are as described in
    section pr in tf(3) of the UNIX Programmer’s Manual.
                                                   - 20 -


sc an f( fo rm at , a1 , .. .) ch ar * fo rm at ;
fs ca nf (i op tr , fo rm at , a1 , .. .) FI LE * io pt r; ch ar * fo rm at ;
ss ca nf (s , fo rm at , a1 , .. .) ch ar * s, * fo rm at ;
    sc an f reads from the standard input. fs ca nf reads from the named input stream. ss ca nf
    reads from the character string supplied as s. sc an f reads characters, interprets them according to
    a format, and stores the results in its arguments. Each routine expects as arguments a control string
    fo rm at, and a set of arguments, each of which must be a pointer, indicating where the converted
    input should be stored.
    sc an f returns as its value the number of successfully matched and assigned input items. This can
    be used to decide how many input items were found. On end of ﬁle, EO F is returned; note that this
    is different from 0, which means that the next input character does not match what was called for in
    the control string.
fr ea d( pt r, si ze of ( * pt r) , ni te ms , io pt r) FI LE * io pt r;
    reads ni te ms of data beginning at pt r from ﬁle io pt r. No advance notiﬁcation that binary I/O
    is being done is required; when, for portability reasons, it becomes required, it will be done by
    adding an additional character to the mode-string on the fo pe n call.
fw ri te (p tr , si ze of ( * pt r) , ni te ms , io pt r) FI LE * io pt r;
    Like fr ea d, but in the other direction.
re wi nd (i op tr ) FI LE * io pt r;
    rewinds the stream named by io pt r. It is not very useful except on input, since a rewound output
    ﬁle is still open only for output.
sy st em (s tr in g) ch ar * st ri ng ;
    The st ri ng is executed by the shell as if typed at the terminal.
ge tw (i op tr ) FI LE * io pt r;
    returns the next word from the input stream named by io pt r. EO F is returned on end-of-ﬁle or
    error, but since this a perfectly good integer fe of and fe rr or should be used. A ‘‘word’’ is 16
    bits on the PDP-11.
pu tw (w , io pt r) FI LE * io pt r;
    writes the integer w on the named output stream.
se tb uf (i op tr , bu f) FI LE * io pt r; ch ar * bu f;
    se tb uf may be used after a stream has been opened but before I/O has started. If bu f is NU LL,
    the stream will be unbuffered. Otherwise the buffer supplied will be used. It must be a character
    array of sufﬁcient size:
             cha r   buf [BU FSI Z];

fi le no (i op tr ) FI LE * io pt r;
    returns the integer ﬁle descriptor associated with the ﬁle.
fs ee k( io pt r, of fs et , pt rn am e) FI LE * io pt r; lo ng of fs et ;
    The location of the next byte in the stream named by io pt r is adjusted. of fs et is a long
    integer. If pt rn am e is 0, the offset is measured from the beginning of the ﬁle; if pt rn am e is 1,
    the offset is measured from the current read or write pointer; if pt rn am e is 2, the offset is meas-
    ured from the end of the ﬁle. The routine accounts properly for any buffering. (When this routine
    is used on non-UNIX systems, the offset must be a value returned from ft el l and the ptrname
    must be 0).
lo ng ft el l( io pt r) FI LE * io pt r;
    The byte offset, measured from the beginning of the ﬁle, associated with the named stream is
    returned. Any buffering is properly accounted for. (On non-UNIX systems the value of this call is
    useful only for handing to fs ee k, so as to position the ﬁle to the same place it was when ft el l
    was called.)
                                                   - 21 -


ge tp w( ui d, bu f) ch ar * bu f;
    The password ﬁle is searched for the given integer user ID. If an appropriate line is found, it is
    copied into the character array bu f, and 0 is returned. If no line is found corresponding to the user
    ID then 1 is returned.
ch ar * ma ll oc (n um );
    allocates nu m bytes. The pointer returned is sufﬁciently well aligned to be usable for any purpose.
    NU LL is returned if no space is available.
ch ar * ca ll oc (n um , si ze );
    allocates space for nu m items each of size si ze. The space is guaranteed to be set to 0 and the
    pointer is sufﬁciently well aligned to be usable for any purpose. NU LL is returned if no space is
    available .
cf re e( pt r) ch ar * pt r;
    Space is returned to the pool used by ca ll oc. Disorder can be expected if the pointer was not
    obtained from ca ll oc.
The following are macros whose deﬁnitions may be obtained by including <c ty pe .h >.
is al ph a( c) returns non-zero if the argument is alphabetic.
is up pe r( c) returns non-zero if the argument is upper-case alphabetic.
is lo we r( c) returns non-zero if the argument is lower-case alphabetic.
is di gi t( c) returns non-zero if the argument is a digit.
is sp ac e( c) returns non-zero if the argument is a spacing character: tab, newline, carriage return,
vertical tab, form feed, space.
is pu nc t( c) returns non-zero if the argument is any punctuation character, i.e., not a space, letter,
digit or control character.
is al nu m( c) returns non-zero if the argument is a letter or a digit.
is pr in t( c) returns non-zero if the argument is printable — a letter, digit, or punctuation character.
is cn tr l( c) returns non-zero if the argument is a control character.
is as ci i( c) returns non-zero if the argument is an ascii character, i.e., less than octal 0200.
to up pe r( c) returns the upper-case character corresponding to the lower-case letter c.
to lo we r( c) returns the lower-case character corresponding to the upper-case letter c.
                                      A Tutorial Introduction to ADB

                                                   J. F. Maranzano
                                                     S. R. Bourne
                                                   Bell Laboratories
                                             Murray Hill, New Jersey 07974



                                                      ABSTRACT

                Debugging tools generally provide a wealth of information about the inner work-
          ings of programs. These tools have been available on UNIX† to allow users to examine
          ‘‘core’’ ﬁles that result from aborted programs. A new debugging program, ADB, pro-
          vides enhanced capabilities to examine "core" and other program ﬁles in a variety of
          formats, run programs with embedded breakpoints and patch ﬁles.
                ADB is an indispensable but complex tool for debugging crashed systems and/or
          programs. This document provides an introduction to ADB with examples of its use.
          It explains the various formatting options, techniques for debugging C programs, exam-
          ples of printing ﬁle system information and patching.



May 5, 1977




_
______________
†UNIX is a Trademark of Bell Laboratories.
                                      A Tutorial Introduction to ADB

                                                   J. F. Maranzano
                                                     S. R. Bourne
                                                   Bell Laboratories
                                             Murray Hill, New Jersey 07974


1. Introduction
      ADB is a new debugging program that is available on UNIX. It provides capabilities to look at
‘‘core’’ ﬁles resulting from aborted programs, print output in a variety of formats, patch ﬁles, and run
programs with embedded breakpoints. This document provides examples of the more useful features of
ADB. The reader is expected to be familiar with the basic commands on UNIX† with the C language,
and with References 1, 2 and 3.

2. A Quick Survey

2.1. Invocation
       ADB is invoked as:
                    adb objﬁle coreﬁle
where objﬁle is an executable UNIX ﬁle and coreﬁle is a core image ﬁle. Many times this will look
like:
                    adb a.out core
or more simply:
                    adb
where the defaults are a.out and core respectively. The ﬁlename minus (– ) means ignore this argument
as in:
                    adb – core

      ADB has requests for examining locations in either ﬁle. The ? request examines the contents of
objﬁle, the / request examines the coreﬁle. The general form of these requests is:
                    address ? format
or
                    address / format


2.2. Current Address
    ADB maintains a current address, called dot, similar in function to the current pointer in the
UNIX editor. When an address is entered, the current address is set to that location, so that:
                    0126?i
sets dot to octal 126 and prints the instruction at that address. The request:
__________________
†UNIX is a Trademark of Bell Laboratories.
                                                   -2-


                 .,10/d
prints 10 decimal numbers starting at dot. Dot ends up referring to the address of the last item printed.
When used with the ? or / requests, the current address can be advanced by typing newline; it can be
decremented by typing ˆ.
       Addresses are represented by expressions. Expressions are made up from decimal, octal, and hex-
adecimal integers, and symbols from the program under test. These may be combined with the opera-
tors +, – , *, % (integer division), & (bitwise and),  (bitwise inclusive or), # (round up to the next mul-
tiple), and ˜ (not). (All arithmetic within ADB is 32 bits.) When typing a symbolic address for a C
program, the user can type name or _name; ADB will recognize both forms.

2.3. Formats
      To print data, a user speciﬁes a collection of letters and characters that describe the format of the
printout. Formats are "remembered" in the sense that typing a request without one will cause the new
printout to appear in the previous format. The following are the most commonly used format letters.
                 b            one byte in octal
                 c            one byte as a character
                 o            one word in octal
                 d            one word in decimal
                 f            two words in ﬂoating point
                 i            PDP 11 instruction
                 s            a null terminated character string
                 a            the value of dot
                 u            one word as unsigned integer
                 n            print a newline
                 r            print a blank space
                 ˆ            backup dot
(Format letters are also available for "long" values, for example, ‘D’ for long decimal, and ‘F’ for dou-
ble ﬂoating point.) For other formats see the ADB manual.

2.4. General Request Meanings
      The general form of a request is:
                 address,count command modiﬁer
which sets ‘dot’ to address and executes the command count times.
      The following table illustrates some general ADB command meanings:
                 Command      Meaning
                   ?          Print contents from a.out ﬁle
                   /          Print contents from core ﬁle
                   =          Print value of "dot"
                   :          Breakpoint control
                   $          Miscellaneous requests
                   ;          Request separator
                   !          Escape to shell

      ADB catches signals, so a user cannot use a quit signal to exit from ADB. The request $q or $Q
(or cntl-D) must be used to exit from ADB.

3. Debugging C Programs
                                                    -3-


3.1. Debugging A Core Image
      Consider the C program in Figure 1. The program is used to illustrate a common error made by C
programmers. The object of the program is to change the lower case "t" to upper case in the string
pointed to by charp and then write the character string to the ﬁle indicated by argument 1. The bug
shown is that the character "T" is stored in the pointer charp instead of the string pointed to by charp.
Executing the program produces a core ﬁle because of an out of bounds memory reference.
      ADB is invoked by:
                  adb a.out core
The ﬁrst debugging request:
                  $c
is used to give a C backtrace through the subroutines called. As shown in Figure 2 only one function
(main) was called and the arguments argc and argv have octal values 02 and 0177762 respectively.
Both of these values look reasonable; 02 = two arguments, 0177762 = address on stack of parameter
vector.
The next request:
                  $C
is used to give a C backtrace plus an interpretation of all the local variables in each function and their
values in octal. The value of the variable cc looks incorrect since cc was declared as a character.
      The next request:
                  $r
prints out the registers including the program counter and an interpretation of the instruction at that loca-
tion.
      The request:
                  $e
prints out the values of all external variables.
      A map exists for each ﬁle handled by ADB. The map for the a.out ﬁle is referenced by ? whereas
the map for core ﬁle is referenced by /. Furthermore, a good rule of thumb is to use ? for instructions
and / for data when looking at programs. To print out information about the maps type:
                  $m
This produces a report of the contents of the maps. More about these maps later.
      In our example, it is useful to see the contents of the string pointed to by charp. This is done by:
                  *charp/s
which says use charp as a pointer in the core ﬁle and print the information as a character string. This
printout clearly shows that the character buffer was incorrectly overwritten and helps identify the error.
Printing the locations around charp shows that the buffer is unchanged but that the pointer is destroyed.
Using ADB similarly, we could print information about the arguments to a function. The request:
                  main.argc/d
prints the decimal core image value of the argument argc in the function main.
The request:
                  *main.argv,3/o
prints the octal values of the three consecutive cells pointed to by argv in the function main. Note that
these values are the addresses of the arguments to main. Therefore:
                  0177770/s
                                                   -4-


prints the ASCII value of the ﬁrst argument. Another way to print this value would have been
                 *"/s
The " means ditto which remembers the last address typed, in this case main.argc ; the * instructs ADB
to use the address ﬁeld of the core ﬁle as a pointer.
      The request:
                 .=o
prints the current address (not its contents) in octal which has been set to the address of the ﬁrst argu-
ment. The current address, dot, is used by ADB to "remember" its current location. It allows the user
to reference locations relative to the current address, for example:
                 .– 10/d


3.2. Multiple Functions
      Consider the C program illustrated in Figure 3. This program calls functions f, g, and h until the
stack is exhausted and a core image is produced.
      Again you can enter the debugger via:
                 adb
which assumes the names a.out and core for the executable ﬁle and core image ﬁle respectively. The
request:
                 $c
will ﬁll a page of backtrace references to f, g, and h. Figure 4 shows an abbreviated list (typing DEL
will terminate the output and bring you back to ADB request level).
      The request:
                 ,5$C
prints the ﬁve most recent activations.
      Notice that each function (f,g,h) has a counter of the number of times it was called.
      The request:
                 fcnt/d
prints the decimal value of the counter for the function f. Similarly gcnt and hcnt could be printed. To
print the value of an automatic variable, for example the decimal value of x in the last call of the func-
tion h, type:
                 h.x/d
It is currently not possible in the exported version to print stack frames other than the most recent
activation of a function. Therefore, a user can print everything with $C or the occurrence of a variable
in the most recent call of a function. It is possible with the $C request, however, to print the stack
frame starting at some address as address$C.

3.3. Setting Breakpoints
     Consider the C program in Figure 5. This program, which changes tabs into blanks, is adapted
from Software Tools by Kernighan and Plauger, pp. 18-27.
      We will run this program under the control of ADB (see Figure 6a) by:
                 adb a.out –
Breakpoints are set in the program as:
                 address:b [request]
                                                    -5-


The requests:
                  settab+4:b
                  fopen+4:b
                  getc+4:b
                  tabpos+4:b
set breakpoints at the start of these functions. C does not generate statement labels. Therefore it is
currently not possible to plant breakpoints at locations other than function entry points without a
knowledge of the code generated by the C compiler. The above addresses are entered as symbol+4 so
that they will appear in any C backtrace since the ﬁrst instruction of each function is a call to the C save
routine (csv). Note that some of the functions are from the C library.
      To print the location of breakpoints one types:
                  $b
The display indicates a count ﬁeld. A breakpoint is bypassed count – 1 times before causing a stop.
The command ﬁeld indicates the ADB requests to be executed each time the breakpoint is encountered.
In our example no command ﬁelds are present.
       By displaying the original instructions at the function settab we see that the breakpoint is set after
the jsr to the C save routine. We can display the instructions using the ADB request:
                  settab,5?ia
This request displays ﬁve instructions starting at settab with the addresses of each location displayed.
Another variation is:
                  settab,5?i
which displays the instructions with only the starting address.
      Notice that we accessed the addresses from the a.out ﬁle with the ? command. In general when
asking for a printout of multiple items, ADB will advance the current address the number of bytes
necessary to satisfy the request; in the above example ﬁve instructions were displayed and the current
address was advanced 18 (decimal) bytes.
      To run the program one simply types:
                  :r
To delete a breakpoint, for instance the entry to the function settab, one types:
                  settab+4:d
To continue execution of the program from the breakpoint type:
                  :c
      Once the program has stopped (in this case at the breakpoint for fopen), ADB requests can be
used to display the contents of memory. For example:
                  $C
to display a stack trace, or:
                  tabs,3/8o
to print three lines of 8 locations each from the array called tabs. By this time (at location fopen) in the
C program, settab has been called and should have set a one in every eighth location of tabs.

3.4. Advanced Breakpoint Usage
      We continue execution of the program with:
                  :c
                                                             -6-


See Figure 6b. Getc is called three times and the contents of the variable c in the function main are
displayed each time. The single character on the left hand edge is the output from the C program. On
the third occurrence of getc the program stops. We can look at the full buffer of characters by typing:
                     ibuf+6/20c
When we continue the program with:
                     :c
we hit our ﬁrst breakpoint at tabpos since there is a tab following the "This" word of the data.
      Several breakpoints of tabpos will occur until the program has changed the tab into equivalent
blanks. Since we feel that tabpos is working, we can remove the breakpoint at that location by:
                     tabpos+4:d
If the program is continued with:
                     :c
it resumes normal execution after ADB prints the message
                     a.out:running

     The UNIX quit and interrupt signals act on ADB itself rather than on the program being
debugged. If such a signal occurs then the program being debugged is stopped and control is returned
to ADB. The signal is saved by ADB and is passed on to the test program if:
                     :c
is typed. This can be useful when testing interrupt handling routines. The signal is not passed on to the
test program if:
                     :c 0
is typed.
      Now let us reset the breakpoint at settab and display the instructions located there when we reach
the breakpoint. This is accomplished by:
                     settab+4:b settab,5?ia *
It is also possible to execute the ADB requests for each occurrence of the breakpoint but only stop after
the third occurrence by typing:
                     getc+4,3:b main.c?C *
This request will print the local variable c in the function main at each occurrence of the breakpoint.
The semicolon is used to separate multiple ADB requests on a single line.
    Warning: setting a breakpoint causes the value of dot to be changed; executing the program under
ADB does not change dot. Therefore:
                     settab+4:b .,5?ia
                     fopen+4:b
will print the last thing dot was set to (in the example fopen+4) not the current location (settab+4) at
which the program is executing.
__________________
* Owing to a bug in early versions of ADB (including the version distributed in Generic 3 UNIX) these statements must
be written as:
                       settab+4:b             settab,5?ia;0
                       getc+4,3:b main.c?C;0
                       settab+4:b             settab,5?ia; ptab/o;0
Note that ;0 will set dot to zero and stop at the breakpoint.
                                                    -7-


      A breakpoint can be overwritten without ﬁrst deleting the old breakpoint. For example:
                  settab+4:b settab,5?ia; ptab/o *
could be entered after typing the above requests.
      Now the display of breakpoints:
                  $b
shows the above request for the settab breakpoint. When the breakpoint at settab is encountered the
ADB requests are executed. Note that the location at settab+4 has been changed to plant the break-
point; all the other locations match their original value.
      Using the functions, f, g and h shown in Figure 3, we can follow the execution of each function
by planting non-stopping breakpoints. We call ADB with the executable program of Figure 3 as fol-
lows:
                  adb ex3 –
Suppose we enter the following breakpoints:
                  h+4:b       hcnt/d; h.hi/; h.hr/
                  g+4:b       gcnt/d; g.gi/; g.gr/
                  f+4:b       fcnt/d; f.ﬁ/; f.fr/
                  :r
Each request line indicates that the variables are printed in decimal (by the speciﬁcation d). Since the
format is not changed, the d can be left off all but the ﬁrst request.
      The output in Figure 7 illustrates two points. First, the ADB requests in the breakpoint line are
not examined until the program under test is run. That means any errors in those ADB requests is not
detected until run time. At the location of the error ADB stops running the program.
      The second point is the way ADB handles register variables. ADB uses the symbol table to
address variables. Register variables, like f.fr above, have pointers to uninitialized places on the stack.
Therefore the message "symbol not found".
      Another way of getting at the data in this example is to print the variables used in the call as:
                  f+4:b       fcnt/d; f.a/; f.b/; f.ﬁ/
                  g+4:b       gcnt/d; g.p/; g.q/; g.gi/
                  :c
The operator / was used instead of ? to read values from the core ﬁle. The output for each function, as
shown in Figure 7, has the same format. For the function f, for example, it shows the name and value
of the external variable fcnt. It also shows the address on the stack and value of the variables a, b and
ﬁ.
      Notice that the addresses on the stack will continue to decrease until no address space is left for
program execution at which time (after many pages of output) the program under test aborts. A display
with names would be produced by requests like the following:
                  f+4:b       fcnt/d; f.a/"a="d; f.b/"b="d; f.ﬁ/"ﬁ="d
In this format the quoted string is printed literally and the d produces a decimal display of the variables.
The results are shown in Figure 7.

3.5. Other Breakpoint Facilities
•   Arguments and change of standard input and output are passed to a program as:
                       :r arg1 arg2 ... <inﬁle >outﬁle
     This request kills any existing program under test and starts the a.out afresh.
                                                   -8-


•   The program being debugged can be single stepped by:
                        :s
    If necessary, this request will start up the program being debugged and stop after executing the ﬁrst
    instruction.
•   ADB allows a program to be entered at a speciﬁc address by typing:
                        address:r

•   The count ﬁeld can be used to skip the ﬁrst n breakpoints as:
                        ,n:r
    The request:
                        ,n:c
    may also be used for skipping the ﬁrst n breakpoints when continuing a program.

•   A program can be continued at an address different from the breakpoint by:
                        address:c

•   The program being debugged runs as a separate process and can be killed by:
                        :k


4. Maps
       UNIX supports several executable ﬁle formats. These are used to tell the loader how to load the
program ﬁle. File type 407 is the most common and is generated by a C compiler invocation such as cc
pgm.c. A 410 ﬁle is produced by a C compiler command of the form cc -n pgm.c, whereas a 411 ﬁle
is produced by cc -i pgm.c. ADB interprets these different ﬁle formats and provides access to the dif-
ferent segments through a set of maps (see Figure 8). To print the maps type:
                   $m

       In 407 ﬁles, both text (instructions) and data are intermixed. This makes it impossible for ADB to
differentiate data from instructions and some of the printed symbolic addresses look incorrect; for exam-
ple, printing data addresses as offsets from routines.
       In 410 ﬁles (shared text), the instructions are separated from data and ?* accesses the data part of
the a.out ﬁle. The ?* request tells ADB to use the second part of the map in the a.out ﬁle. Accessing
data in the core ﬁle shows the data after it was modiﬁed by the execution of the program. Notice also
that the data segment may have grown during program execution.
       In 411 ﬁles (separated I & D space), the instructions and data are also separated. However, in this
case, since data is mapped through a separate set of segmentation registers, the base of the data segment
is also relative to address zero. In this case since the addresses overlap it is necessary to use the ?*
operator to access the data space of the a.out ﬁle. In both 410 and 411 ﬁles the corresponding core ﬁle
does not contain the program text.
       Figure 9 shows the display of three maps for the same program linked as a 407, 410, 411 respec-
tively. The b, e, and f ﬁelds are used by ADB to map addresses into ﬁle addresses. The "f1" ﬁeld is
the length of the header at the beginning of the ﬁle (020 bytes for an a.out ﬁle and 02000 bytes for a
core ﬁle). The "f2" ﬁeld is the displacement from the beginning of the ﬁle to the data. For a 407 ﬁle
with mixed text and data this is the same as the length of the header; for 410 and 411 ﬁles this is the
length of the header plus the size of the text portion.
      The "b" and "e" ﬁelds are the starting and ending locations for a segment. Given an address, A,
the location in the ﬁle (either a.out or core) is calculated as:
                                                  -9-


                  b1≤A≤e1 = ﬁle address = (A– b1)+f1
                          >
                  b2≤A≤e2 = ﬁle address = (A– b2)+f2
                          >
A user can access locations by using the ADB deﬁned variables. The $v request prints the variables ini-
tialized by ADB:
                  b          base address of data segment
                  d          length of the data segment
                  s          length of the stack
                  t          length of the text
                  m          execution type (407,410,411)

      In Figure 9 those variables not present are zero. Use can be made of these variables by expres-
sions such as:
                  <b
in the address ﬁeld. Similarly the value of the variable can be changed by an assignment request such
as:
                  02000>b
that sets b to octal 2000. These variables are useful to know if the ﬁle under examination is an execut-
able or core image ﬁle.
      ADB reads the header of the core image ﬁle to ﬁnd the values for these variables. If the second
ﬁle speciﬁed does not seem to be a core ﬁle, or if it is missing then the header of the executable ﬁle is
used instead.

5. Advanced Usage
      It is possible with ADB to combine formatting requests to provide elaborate displays. Below are
several examples.

5.1. Formatted dump
      The line:
                  <b,– 1/4o4ˆ8Cn
prints 4 octal words followed by their ASCII interpretation from the data space of the core image ﬁle.
Broken down, the various request pieces mean:

                  <b         The base address of the data segment.

                  <b,– 1     Print from the base address to the end of ﬁle. A negative count is used
                             here and elsewhere to loop indeﬁnitely or until some error condition (like
                             end of ﬁle) is detected.

The format 4o4ˆ8Cn is broken down as follows:

                  4o         Print 4 octal locations.

                  4ˆ         Backup the current address 4 locations (to the original start of the ﬁeld).

                  8C         Print 8 consecutive characters using an escape convention; each character
                             in the range 0 to 037 is printed as @ followed by the corresponding char-
                             acter in the range 0140 to 0177. An @ is printed as @@.

                  n          Print a newline.
                                                  - 10 -


      The request:
                 <b,<d/4o4ˆ8Cn
could have been used instead to allow the printing to stop at the end of the data segment (<d provides
the data segment size in bytes).
     The formatting requests can be combined with ADB’s ability to read in a script to produce a core
image dump script. ADB is invoked as:
                 adb a.out core < dump
to read in a script ﬁle, dump, of requests. An example of such a script is:
                 120$w
                 4095$s
                 $v
                 =3n
                 $m
                 =3n"C Stack Backtrace"
                 $C
                 =3n"C External Variables"
                 $e
                 =3n"Registers"
                 $r
                 0$s
                 =3n"Data Segment"
                 <b,– 1/8ona

       The request 120$w sets the width of the output to 120 characters (normally, the width is 80 char-
acters). ADB attempts to print addresses as:
                 symbol + offset
The request 4095$s increases the maximum permissible offset to the nearest symbolic address from 255
(default) to 4095. The request = can be used to print literal strings. Thus, headings are provided in this
dump program with requests of the form:
                 =3n"C Stack Backtrace"
that spaces three lines and prints the literal string. The request $v prints all non-zero ADB variables
(see Figure 8). The request 0$s sets the maximum offset for symbol matches to zero thus suppressing
the printing of symbolic labels in favor of octal values. Note that this is only done for the printing of
the data segment. The request:
                 <b,– 1/8ona
prints a dump from the base of the data segment to the end of ﬁle with an octal address ﬁeld and eight
octal numbers per line.
      Figure 11 shows the results of some formatting requests on the C program of Figure 10.

5.2. Directory Dump
     As another illustration (Figure 12) consider a set of requests to dump the contents of a directory
(which is made up of an integer inumber followed by a 14 character name):
                 adb dir –
                 =n8t"Inum"8t"Name"
                 0,– 1? u8t14cn
In this example, the u prints the inumber as an unsigned decimal integer, the 8t means that ADB will
space to the next multiple of 8 on the output line, and the 14c prints the 14 character ﬁle name.
                                                   - 11 -


5.3. Ilist Dump
     Similarly the contents of the ilist of a ﬁle system, (e.g. /dev/src, on UNIX systems distributed by
the UNIX Support Group; see UNIX Programmer’s Manual Section V) could be dumped with the fol-
lowing set of requests:
                    adb /dev/src –
                    02000>b
                    ?m <b
                    <b,– 1?"ﬂags"8ton"links,uid,gid"8t3bn",size"8tbrdn"addr"8t8un"times"8t2Y2na
In this example the value of the base for the map was changed to 02000 (by saying ?m<b) since that is
the start of an ilist within a ﬁle system. An artiﬁce (brd above) was used to print the 24 bit size ﬁeld as
a byte, a space, and a decimal integer. The last access time and last modify time are printed with the
2Y operator. Figure 12 shows portions of these requests as applied to a directory and ﬁle system.

5.4. Converting values
         ADB may be used to convert values from one representation to another. For example:
                    072 = odx
will print
                    072         58           #3a
which is the octal, decimal and hexadecimal representations of 072 (octal). The format is remembered
so that typing subsequent numbers will print them in the given formats. Character values may be con-
verted similarly, for example:
                    ’a’ = co
prints
                    a           0141
It may also be used to evaluate expressions but be warned that all binary operators have the same pre-
cedence which is lower than that for unary operators.

6. Patching
       Patching ﬁles with ADB is accomplished with the write, w or W, request (which is not like the ed
editor write command). This is often used in conjunction with the locate, l or L request. In general, the
request syntax for l and w are similar as follows:
                    ?l value
The request l is used to match on two bytes, L is used for four bytes. The request w is used to write
two bytes, whereas W writes four bytes. The value ﬁeld in either locate or write requests is an expres-
sion. Therefore, decimal and octal numbers, or character strings are supported.
         In order to modify a ﬁle, ADB must be called as:
                    adb – w ﬁle1 ﬁle2
When called with this option, ﬁle1 and ﬁle2 are created if necessary and opened for both reading and
writing.
      For example, consider the C program shown in Figure 10. We can change the word "This" to
"The " in the executable ﬁle for this program, ex7, by using the following requests:
                    adb – w ex7 –
                    ?l ’Th’
                    ?W ’The ’
The request ?l starts at dot and stops at the ﬁrst match of "Th" having set dot to the address of the
                                                  - 12 -


location found. Note the use of ? to write to the a.out ﬁle. The form ?* would have been used for a
411 ﬁle.
      More frequently the request will be typed as:
                 ?l ’Th’; ?s
and locates the ﬁrst occurrence of "Th" and print the entire string. Execution of this ADB request will
set dot to the address of the "Th" characters.
      As another example of the utility of the patching facility, consider a C program that has an inter-
nal logic ﬂag. The ﬂag could be set by the user through ADB and the program run. For example:
                 adb a.out –
                 :s arg1 arg2
                 ﬂag/w 1
                 :c
The :s request is normally used to single step through a process or start a process in single step mode.
In this case it starts a.out as a subprocess with arguments arg1 and arg2. If there is a subprocess run-
ning ADB writes to it rather than to the ﬁle so the w request causes ﬂag to be changed in the memory
of the subprocess.

7. Anomalies
      Below is a list of some strange things that users should be aware of.
1.    Function calls and arguments are put on the stack by the C save routine. Putting breakpoints at
      the entry point to routines means that the function appears not to have been called when the break-
      point occurs.
2.    When printing addresses, ADB uses either text or data symbols from the a.out ﬁle. This some-
      times causes unexpected symbol names to be printed with data (e.g. savr5+022). This does not
      happen if ? is used for text (instructions) and / for data.
3.    ADB cannot handle C register variables in the most recently activated function.

8. Acknowledgements
      The authors are grateful for the thoughtful comments on how to organize this document from R.
B. Brandt, E. N. Pinson and B. A. Tague. D. M. Ritchie made the system changes necessary to accom-
modate tracing within ADB. He also participated in discussions during the writing of ADB. His earlier
work with DB and CDB led to many of the features found in ADB.

9. References
1.    D. M. Ritchie and K. Thompson, ‘‘The UNIX Time-Sharing System,’’ CACM, July, 1974.
2.    B. W. Kernighan and D. M. Ritchie, The C Programming Language, Prentice-Hall, 1978.
3.    K. Thompson and D. M. Ritchie, UNIX Programmer’s Manual - 7th Edition, 1978.
4.    B. W. Kernighan and P. J. Plauger, Software Tools, Addison-Wesley, 1976.
                                                       - 13 -


Figure 1: C program with pointer bug

        struct buf {
                  int ﬁldes;
                  int nleft;
                  char *nextp;
                  char buff[512];
                  }bb;
        struct buf *obuf;

        char *charp "this is a sentence.";

        main(argc,argv)
        int argc;
        char **argv;
        {
                  char      cc;

                  if(argc < 2) {
                            printf("Input ﬁle missing\n");
                            exit(8);
                  }

                  if((fcreat(argv[1],obuf)) < 0){
                             printf("%s : not found\n", argv[1]);
                             exit(8);
                  }
                  charp = ´T´;
        printf("debug 1 %s\n",charp);
                  while(cc= *charp++)
                             putc(cc,obuf);
                  fﬂush(obuf);
        }
                                                 - 14 -


Figure 2: ADB output for C program of Figure 1

        adb a.out core
        $c
        ˜main(02,0177762)
        $C
        ˜main(02,0177762)
                 argc:       02
                 argv:       0177762
                 cc:        02124
        $r
        ps       0170010
        pc       0204     ˜main+0152
        sp       0177740
        r5       0177752
        r4       01
        r3       0
        r2       0
        r1       0
        r0       0124
        ˜main+0152:       mov     _obuf,(sp)
        $e
        savr5:       0
        _obuf:       0
        _charp:      0124
        _errno:      0
        _fout:       0
        $m
        text map `ex1´
        b1 = 0                e1 = 02360       f1 = 020
        b2 = 0                e2 = 02360       f2 = 020
        data map `core1´
        b1 = 0                e1 = 03500       f1 = 02000
        b2 = 0175400          e2 = 0200000              f2 = 05500
        *charp/s
        0124:             TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTLx   Nh@x&_
        ˜
        charp/s
        _charp:           T

        _charp+02:       this is a sentence.

        _charp+026:      Input ﬁle missing
        main.argc/d
        0177756: 2
        *main.argv/3o
        0177762: 0177770 0177776 0177777
        0177770/s
        0177770: a.out
        *main.argv/3o
        0177762: 0177770 0177776 0177777
        *"/s
        0177770: a.out
         .=o
                         0177770
         .−10/d
        0177756: 2
        $q
                                                   - 15 -


Figure 3: Multiple function C program for stack trace illustration

         int      fcnt,gcnt,hcnt;
         h(x,y)
         {
                  int hi; register int hr;
                  hi = x+1;
                  hr = x−y+1;
                  hcnt++ ;
                  hj:
                  f(hr,hi);
         }

         g(p,q)
         {
                  int gi; register int gr;
                  gi = q−p;
                  gr = q−p+1;
                  gcnt++ ;
                  gj:
                  h(gr,gi);
         }

         f(a,b)
         {
                  int ﬁ; register int fr;
                  ﬁ = a+2*b;
                  fr = a+b;
                  fcnt++ ;
                  fj:
                  g(fr,ﬁ);
         }

         main()
         {
                  f(1,1);
         }
                                                 - 16 -


Figure 4: ADB output for C program of Figure 3

        adb
        $c
        ˜h(04452,04451)
        ˜g(04453,011124)
        ˜f(02,04451)
        ˜h(04450,04447)
        ˜g(04451,011120)
        ˜f(02,04447)
        ˜h(04446,04445)
        ˜g(04447,011114)
        ˜f(02,04445)
        ˜h(04444,04443)
        HIT DEL KEY
        adb
        ,5$C
        ˜h(04452,04451)
                  x:         04452
                  y:         04451
                  hi:        ?
        ˜g(04453,011124)
                  p:         04453
                  q:         011124
                  gi:        04451
                  gr:        ?
        ˜f(02,04451)
                  a:         02
                  b:         04451
                  ﬁ:         011124
                  fr:        04453
        ˜h(04450,04447)
                  x:         04450
                  y:         04447
                  hi:        04451
                  hr:        02
        ˜g(04451,011120)
                  p:         04451
                  q:         011120
                  gi:        04447
                  gr:        04450
        fcnt/d
        _fcnt:             1173
        gcnt/d
        _gcnt:             1173
        hcnt/d
        _hcnt:             1172
        h.x/d
        022004:            2346
        $q
                                                       - 17 -


Figure 5: C program to decode tabs

        #deﬁne   MAXLINE 80
        #deﬁne   YES                   1
        #deﬁne   NO                    0
        #deﬁne   TABSP                 8
        char      input[] "data";
        char      ibuf[518];
        int       tabs[MAXLINE];
        main()
        {
                  int col, *ptab;
                  char c;
                  ptab = tabs;
                  settab(ptab);        /*Set initial tab stops */
                  col = 1;
                  if(fopen(input,ibuf) < 0) {
                            printf("%s : not found\n",input);
                            exit(8);
                  }
                  while((c = getc(ibuf)) != −1) {
                            switch(c) {
                                       case ′\t′: /* TAB */
                                                  while(tabpos(col) != YES) {
                                                            putchar(′ ′);     /* put BLANK */
                                                            col++ ;
                                                  }
                                                  break;
                                       case ′\n′: /*NEWLINE */
                                                  putchar(′\n′);
                                                  col = 1;
                                                  break;
                                       default:
                                                  putchar(c);
                                                  col++ ;
                            }
                  }
        }
        /* Tabpos return YES if col is a tab stop */
        tabpos(col)
        int col;
        {
                 if(col > MAXLINE)
                           return(YES);
                 else
                           return(tabs[col]);
        }
        /* Settab - Set initial tab stops */
        settab(tabp)
        int *tabp;
        {
                   int i;
                  for(i = 0; i<= MAXLINE; i++)
                             (i%TABSP) ? (tabs[i] = NO) : (tabs[i] = YES);
        }
                                                    - 18 -


Figure 6a: ADB output for C program of Figure 5

        adb a.out −
        settab+4:b
        fopen+4:b
        getc+4:b
        tabpos+4:b
        $b
        breakpoints
        count     bkpt                command
        1         ˜tabpos+04
        1         _getc+04
        1         _fopen+04
        1         ˜settab+04
        settab,5?ia
        ˜settab:            jsr       r5,csv
        ˜settab+04:         tst       −(sp)
        ˜settab+06:         clr       0177770(r5)
        ˜settab+012:        cmp       $0120,0177770(r5)
        ˜settab+020:        blt       ˜settab+076
        ˜settab+022:
        settab,5?i
        ˜settab:            jsr       r5,csv
                            tst       −(sp)
                            clr       0177770(r5)
                            cmp       $0120,0177770(r5)
                            blt       ˜settab+076
        :r
        a.out: running
        breakpoint          ˜settab+04:         tst     −(sp)
        settab+4:d
        :c
        a.out: running
        breakpoint          _fopen+04:          mov     04(r5),nulstr+012
        $C
        _fopen(02302,02472)
        ˜main(01,0177770)
                  col:          01
                  c:            0
                  ptab:         03500
        tabs,3/8o
        03500:              01        0         0       0         0       0   0   0
                            01        0         0       0         0       0   0   0
                            01        0         0       0         0       0   0   0
                                                      - 19 -


Figure 6b: ADB output for C program of Figure 5

        :c
        a.out: running
        breakpoint          _getc+04:          mov        04(r5),r1
        ibuf+6/20c
        __cleanu+0202:               This      is         a test    of
        :c
        a.out: running
        breakpoint          ˜tabpos+04:        cmp        $0120,04(r5)
        tabpos+4:d
        settab+4:b settab,5?ia
        settab+4:b settab,5?ia; 0
        getc+4,3:b main.c?C; 0
        settab+4:b settab,5?ia; ptab/o; 0
        $b
        breakpoints
        count     bkpt               command
        1         ˜tabpos+04
        3         _getc+04 main.c?C;0
        1         _fopen+04
        1         ˜settab+04         settab,5?ia;ptab?o;0
        ˜settab:            jsr      r5,csv
        ˜settab+04:         bpt
        ˜settab+06:         clr      0177770(r5)
        ˜settab+012:        cmp      $0120,0177770(r5)
        ˜settab+020:        blt      ˜settab+076
        ˜settab+022:
        0177766: 0177770
        0177744: @`
        T0177744:           T
        h0177744:           h
        i0177744:           i
        s0177744:           s
                                                          - 20 -


Figure 7: ADB output for C program with breakpoints
        adb ex3 −
        h+4:b hcnt/d; h.hi/; h.hr/
        g+4:b gcnt/d; g.gi/; g.gr/
        f+4:b fcnt/d; f.ﬁ/; f.fr/
        :r
        ex3: running
        _fcnt:        0
        0177732:      214
        symbol not found
        f+4:b fcnt/d; f.a/; f.b/; f.ﬁ/
        g+4:b gcnt/d; g.p/; g.q/; g.gi/
        h+4:b hcnt/d; h.x/; h.y/; h.hi/
        :c
        ex3: running
        _fcnt:        0
        0177746:      1
        0177750:      1
        0177732:      214
        _gcnt:        0
        0177726:      2
        0177730:      3
        0177712:      214
        _hcnt:        0
        0177706:      2
        0177710:      1
        0177672:      214
        _fcnt:        1
        0177666:      2
        0177670:      3
        0177652:      214
        _gcnt:        1
        0177646:      5
        0177650:      8
        0177632:      214
        HIT DEL
        f+4:b fcnt/d; f.a/"a = "d; f.b/"b = "d; f.ﬁ/"ﬁ = "d
        g+4:b gcnt/d; g.p/"p = "d; g.q/"q = "d; g.gi/"gi = "d
        h+4:b hcnt/d; h.x/"x = "d; h.y/"h = "d; h.hi/"hi = "d
        :r
        ex3: running
        _fcnt:        0
        0177746:      a=1
        0177750:      b=1
        0177732:      ﬁ = 214
        _gcnt:        0
        0177726:      p=2
        0177730:      q=3
        0177712:      gi = 214
        _hcnt:        0
        0177706:      x=2
        0177710:      y=1
        0177672:      hi = 214
        _fcnt:        1
        0177666:      a=2
        0177670:      b=3
        0177652:      ﬁ = 214
        HIT DEL
        $q
                                                   - 21 -


Figure 8: ADB address maps
407 ﬁles

a.out                  hdr                        text+data
                    _______ _______________________________________________
                               0                                           D

core                   hdr                        text+data                                  stack
                    ___________ _______________________________________________...... ___________________
                                 0                                             D         S                E


410 ﬁles (shared text)

a.out                  hdr                        text                                     data
                    _______ _______________________________________________ ___________________________
                               0                                           T B                          D

core                   hdr                  data                          stack
                    ___________ ___________________________...... ___________________
                                   B                        D        S                E


411 ﬁles (separated I and D space)

a.out                  hdr                        text                                     data
                    _______ _______________________________________________ ___________________________
                               0                                           T 0                          D

core                   hdr                  data                          stack
                    ___________ ___________________________...... ___________________
                                   0                        D        S                E


The following adb variables are set.

                                                              407              410             411

              b              base of data                     0                B               0
              d              length of data                   D                D−B             D
              s              length of stack                  S                S               S
              t              length of text                   0                T               T
                                             - 22 -


Figure 9: ADB output for maps
        adb map407 core407
        $m
        text map `map407´
        b1 = 0             e1   = 0256           f1 = 020
        b2 = 0             e2   = 0256           f2 = 020
        data map `core407´
        b1 = 0             e1   = 0300            f1 = 02000
        b2 = 0175400       e2   = 0200000   f2 = 02300
        $v
        variables
        d = 0300
        m = 0407
        s = 02400
        $q


        adb map410 core410
        $m
        text map `map410´
        b1 = 0             e1   = 0200            f1 = 020
        b2 = 020000        e2   = 020116    f2 = 0220
        data map `core410´
        b1 = 020000        e1   = 020200    f1 = 02000
        b2 = 0175400       e2   = 0200000   f2 = 02200
        $v
        variables
        b = 020000
        d = 0200
        m = 0410
        s = 02400
        t = 0200
        $q


        adb map411 core411
        $m
        text map `map411´
        b1 = 0             e1   = 0200           f1 = 020
        b2 = 0             e2   = 0116           f2 = 0220
        data map `core411´
        b1 = 0             e1   = 0200            f1 = 02000
        b2 = 0175400       e2   = 0200000   f2 = 02200
        $v
        variables
        d = 0200
        m = 0411
        s = 02400
        t = 0200
        $q
                                                       - 23 -


Figure 10: Simple C program for illustrating formatting and patching

        char     str1[]     "This is a character string";
        int      one        1;
        int      number     456;
        long     lnum       1234;
        ﬂoat     fpt        1.25;
        char     str2[]     "This is the second character string";
        main()
        {
                 one = 2;
        }
                                                    - 24 -


Figure 11: ADB output illustrating fancy formats
adb map410 core410
<b,−1/8ona
020000:        0          064124   071551    064440      020163     020141     064143   071141
_str1+016: 061541         062564   020162    072163      064562     063556    0    02
_number:
_number:    0710 0        02322    040240    0     064124     071551      064440
_str2+06:   020163        064164   020145    062563      067543     062156     061440   060550
_str2+026: 060562         072143   071145    071440      071164     067151    0147 0
savr5+02: 0        0      0    0   0    0    0     0
<b,20/4o4ˆ8Cn
020000:         0         064124   071551    064440   @`@`This i
           020163         020141   064143    071141   s a char
           061541         062564   020162    072163   acter st
           064562         063556   0    02   ring@`@`@b@`
_number:    0710 0     02322      040240    H@a@`@`R@d @@
            0     064124     071551    064440     @`@`This i
            020163     064164     020145    062563      s the se
            067543     062156     061440    060550      cond cha
            060562     072143     071145    071440      racter s
            071164     067151     0147 0    tring@`@`@`
            0     0    0     0    @`@`@`@`@`@`@`@`
            0     0    0     0    @`@`@`@`@`@`@`@`
data address not found
<b,20/4o4ˆ8t8cna
020000:           0    064124     071551    064440             This i
_str1+06: 020163       020141     064143    071141             s a char
_str1+016: 061541      062564     020162    072163             acter st
_str1+026: 064562      063556     0    02         ring
_number:
_number: 0710 0        02322      040240          HR
_fpt+02:    0     064124     071551    064440           This i
_str2+06: 020163       064164     020145    062563             s the se
_str2+016: 067543      062156     061440    060550             cond cha
_str2+026: 060562      072143     071145    071440             racter s
_str2+036: 071164      067151     0147 0          tring
savr5+02: 0       0    0     0
savr5+012: 0      0    0     0
data address not found
<b,10/2b8tˆ2cn
020000:           0    0
_str1:      0124   0150       Th
            0151   0163       is
            040    0151        i
            0163   040        s
            0141   040        a
            0143   0150       ch
            0141   0162       ar
            0141   0143       ac
            0164   0145       te
$Q
                                                 - 25 -


Figure 12: Directory and inode dumps
adb dir −
=nt"Inode"t"Name"
0,−1?ut14cn

          Inode Name
0:        652 .
          82    ..
          5971 cap.c
          5323 cap
          0     pp




adb /dev/src −
02000>b
?m<b
new map        `/dev/src´
b1 = 02000      e1      = 0100000000     f1 = 0
b2 = 0                e2     =0          f2 = 0
$v
variables
b = 02000
<b,−1?"ﬂags"8ton"links,uid,gid"8t3bn"size"8tbrdn"addr"8t8un"times"8t2Y2na
02000:            ﬂags 073145
           links,uid,gid     0163 0164 0141
           size 0162 10356
           addr 28770        8236 25956      27766     25455      8236 25956    25206
           times 1976 Feb 5 08:34:56 1975 Dec 28 10:55:15

02040:           ﬂags 024555
          links,uid,gid    012 0163 0164
          size 0162 25461
          addr 8308 30050       8294 25130     15216      26890       29806     10784
          times 1976 Aug 17 12:16:51 1976 Aug 17 12:16:51

02100:           ﬂags 05173
          links,uid,gid    011 0162 0145
          size 0147 29545
          addr 25972       8306 28265    8308 25642        15216      2314 25970
          times 1977 Apr 2 08:58:01 1977 Feb 5 10:21:44
                                                         - 26 -


                                                 ADB Summary
Command Summary                                                   Format Summary
a)   formatted printing                                           a            the value of dot
                                                                  b            one byte in octal
? format      print from a.out ﬁle according to format            c            one byte as a character
/ format      print from core ﬁle according to format             d            one word in decimal
                                                                  f            two words in ﬂoating point
= format      print the value of dot
                                                                  i            PDP 11 instruction
?w expr       write expression into a.out ﬁle                     o            one word in octal
                                                                  n            print a newline
/w expr       write expression into core ﬁle                      r            print a blank space
                                                                  s            a null terminated character string
?l expr       locate expression in a.out ﬁle
                                                                  nt           move to next n space tab
b)   breakpoint and program control                               u            one word as unsigned integer
:b            set breakpoint at dot                               x            hexadecimal
:c            continue running program                            Y            date
:d            delete breakpoint                                   ˆ            backup dot
:k            kill the program being debugged                     "..."        print string
:r            run a.out ﬁle under ADB control
:s            single step                                         Expression Summary
c)   miscellaneous printing                                       a) expression components
$b            print current breakpoints                           decimal integer        e.g. 256
$c            C stack trace                                       octal integer          e.g. 0277
$e            external variables                                  hexadecimal            e.g. #ff
$f            ﬂoating registers                                   symbols                e.g. ﬂag _main main.argc
$m            print ADB segment maps                              variables              e.g. <b
$q            exit from ADB                                       registers              e.g. <pc <r0
$r            general registers                                   (expression)           expression grouping
$s            set offset for symbol match
                                                                  b) dyadic operators
$v            print ADB variables
$w            set output line width                               +            add
                                                                  −            subtract
d)   calling the shell
                                                                  *            multiply
!             call shell to read rest of line                     %            integer division
e)   assignment to variables                                      &            bitwise and
                                                                              bitwise or
>name         assign dot to variable or register name
                                                                  #            round up to the next multiple
                                                                  c) monadic operators
                                                                  ˜            not
                                                                  *            contents of location
                                                                  −            integer negate
